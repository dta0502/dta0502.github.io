<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小丁的个人博客</title>
  
  <subtitle>世间所有的相遇，都是久别重逢</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tding.top/"/>
  <updated>2019-12-22T14:34:32.607Z</updated>
  <id>https://tding.top/</id>
  
  <author>
    <name>小丁</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ggplot2柱状图按数值大小排序</title>
    <link href="https://tding.top/archives/c363755b.html"/>
    <id>https://tding.top/archives/c363755b.html</id>
    <published>2019-12-22T14:30:00.000Z</published>
    <updated>2019-12-22T14:34:32.607Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>ggplot2柱状图按照数值大小进行排序是比较困难的。<strong>这是因为ggplot2考虑的是因子级别的顺序，而不是数据框中观察到的顺序</strong>。我们可以使用<code>sort()</code>或<code>arrange()</code>对输入数据框进行排序，但是这不会对ggplot2输出产生任何影响（柱状图依旧按照因子的顺序排列）。</p><p>本文主要介绍如何让ggplot2的柱状图按照数值大小排序。</p><a id="more"></a><h2 id="本文用到的数据集"><a href="#本文用到的数据集" class="headerlink" title="本文用到的数据集"></a>本文用到的数据集</h2><p>数据集1——自己定义的：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- data.frame(</span><br><span class="line">  name = c(<span class="string">"north"</span>,<span class="string">"south"</span>,<span class="string">"south-east"</span>,<span class="string">"north-west"</span>,<span class="string">"south-west"</span>,<span class="string">"north-east"</span>,<span class="string">"west"</span>,<span class="string">"east"</span>),</span><br><span class="line">  val=sample(seq(<span class="number">1</span>,<span class="number">10</span>), <span class="number">8</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>数据集2——ggplot2包自带的mpg数据集。</p><h2 id="forecats包实现"><a href="#forecats包实现" class="headerlink" title="forecats包实现"></a>forecats包实现</h2><p><code>forecats</code>库是<code>tidyverse</code>中的一个库，专门用于处理R中的因子，它提供了一组有用的工具来解决因子的常见问题。<strong>其中<code>fact_reorder()</code>函数允许通过另一列<code>data$val</code>的值对因子<code>data$name</code>进行重新排序</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(dplyr)</span><br><span class="line"><span class="keyword">library</span>(forcats)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过另一列的值来对因子重新排序（升序）</span></span><br><span class="line">data %&gt;%</span><br><span class="line">  mutate(name = fct_reorder(name, val)) %&gt;%</span><br><span class="line">  ggplot(aes(x=name, y=val)) +</span><br><span class="line">    geom_bar(stat=<span class="string">"identity"</span>, fill=<span class="string">"#f68060"</span>, alpha=<span class="number">.6</span>, width=<span class="number">.4</span>) +</span><br><span class="line">    coord_flip() +</span><br><span class="line">    xlab(<span class="string">""</span>) +</span><br><span class="line">    theme_bw()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过另一列的值来对因子重新排序（降序）</span></span><br><span class="line">data %&gt;%</span><br><span class="line">  mutate(name = fct_reorder(name, desc(val))) %&gt;%</span><br><span class="line">  ggplot(aes(x=name, y=val)) +</span><br><span class="line">    geom_bar(stat=<span class="string">"identity"</span>, fill=<span class="string">"#f68060"</span>, alpha=<span class="number">.6</span>, width=<span class="number">.4</span>) +</span><br><span class="line">    coord_flip() +</span><br><span class="line">    xlab(<span class="string">""</span>) +</span><br><span class="line">    theme_bw()</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/1.png" title="图1"><p>我们可以指定用哪个函数<code>.fun</code>来确定顺序。默认值是使用中位数，我们也可以使用每组的数据点数来排序：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中位数（默认）</span></span><br><span class="line">mpg %&gt;%</span><br><span class="line">  mutate(class = fct_reorder(class, hwy, .fun=<span class="string">'median'</span>)) %&gt;%</span><br><span class="line">  ggplot(aes(x=class, y=hwy, fill=class)) + </span><br><span class="line">    geom_boxplot() +</span><br><span class="line">    xlab(<span class="string">"class"</span>) +</span><br><span class="line">    theme(legend.position=<span class="string">"none"</span>) +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据点数</span></span><br><span class="line">mpg %&gt;%</span><br><span class="line">  mutate(class = fct_reorder(class, hwy, .fun=<span class="string">'length'</span>)) %&gt;%</span><br><span class="line">  ggplot(aes(x=class, y=hwy, fill=class)) + </span><br><span class="line">    geom_boxplot() +</span><br><span class="line">    xlab(<span class="string">"class"</span>) +</span><br><span class="line">    theme(legend.position=<span class="string">"none"</span>) +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/2.png" title="图2"><p>当然我们也可以自己指定因子的顺序：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data %&gt;%</span><br><span class="line">  mutate(name = fct_relevel(name, </span><br><span class="line">            <span class="string">"north"</span>, <span class="string">"north-east"</span>, <span class="string">"east"</span>, </span><br><span class="line">            <span class="string">"south-east"</span>, <span class="string">"south"</span>, <span class="string">"south-west"</span>, </span><br><span class="line">            <span class="string">"west"</span>, <span class="string">"north-west"</span>)) %&gt;%</span><br><span class="line">  ggplot( aes(x=name, y=val)) +</span><br><span class="line">    geom_bar(stat=<span class="string">"identity"</span>) +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/3.png" title="图3"><h2 id="dplyr包实现"><a href="#dplyr包实现" class="headerlink" title="dplyr包实现"></a>dplyr包实现</h2><p><code>dplyr</code>的<code>mutate()</code>函数允许创建新变量或修改现有变量，我们可以用它来重新创建具有特定顺序的因子。下面是两个例子：</p><ul><li>采用<code>arrange()</code>对数据框进行排序，然后按照这个顺序对因子进行重新排序。</li><li>自定义因子顺序。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用arrange()对数据框排序，然后按照这个顺序对因子进行重新排序</span></span><br><span class="line">data %&gt;%</span><br><span class="line">  <span class="comment"># 按照val进行排序，但是这只对数据框进行了排序而没有对因子进行排序</span></span><br><span class="line">  arrange(val) %&gt;%</span><br><span class="line">  <span class="comment"># 通过下面这个小技巧可以直接更新因子</span></span><br><span class="line">  mutate(name=factor(name, levels=name)) %&gt;%</span><br><span class="line">  ggplot(aes(x=name, y=val)) +</span><br><span class="line">    geom_segment(aes(xend=name, yend=<span class="number">0</span>)) +</span><br><span class="line">    geom_point(size=<span class="number">4</span>, color=<span class="string">"orange"</span>) +</span><br><span class="line">    coord_flip() +</span><br><span class="line">    theme_bw() +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义因子顺序</span></span><br><span class="line">data %&gt;%</span><br><span class="line">  arrange(val) %&gt;%</span><br><span class="line">  mutate(name = factor(name, levels=c(<span class="string">"north"</span>, <span class="string">"north-east"</span>, <span class="string">"east"</span>, <span class="string">"south-east"</span>, <span class="string">"south"</span>, <span class="string">"south-west"</span>, <span class="string">"west"</span>, <span class="string">"north-west"</span>))) %&gt;%</span><br><span class="line">  ggplot(aes(x=name, y=val)) +</span><br><span class="line">    geom_segment(aes(xend=name, yend=<span class="number">0</span>)) +</span><br><span class="line">    geom_point(size=<span class="number">4</span>, color=<span class="string">"orange"</span>) +</span><br><span class="line">    theme_bw() +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/4.png" title="图4"><h2 id="base包的reorder-函数实现"><a href="#base包的reorder-函数实现" class="headerlink" title="base包的reorder()函数实现"></a>base包的reorder()函数实现</h2><p><code>reorder()</code>函数用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reorder(x, X, FUN = mean, <span class="keyword">...</span>, order = is.ordered(x))</span><br></pre></td></tr></table></figure><ul><li><code>x</code>：因子型向量</li><li><code>X</code>：用来排序的数值型向量</li><li><code>FUN</code>：汇总数据的函数</li><li><code>...</code>：<code>FUN</code>的参数（可选）</li><li><code>order</code>：我们可以通过这个参数直接指定因子型向量的顺序</li></ul><p>按照x对X进行分组，对每一组组成的向量计算后面的函数，最后根据计算结果从小到大指定x中元素的顺序。</p><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mpg$class = with(mpg, reorder(class, hwy, median))</span><br><span class="line"></span><br><span class="line">p &lt;- mpg %&gt;%</span><br><span class="line">  ggplot( aes(x=class, y=hwy, fill=class)) + </span><br><span class="line">    geom_violin() +</span><br><span class="line">    xlab(<span class="string">"class"</span>) +</span><br><span class="line">    theme(legend.position=<span class="string">"none"</span>) +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/5.png" title="图5"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.r-graph-gallery.com/267-reorder-a-variable-in-ggplot2.html" rel="external nofollow noopener noreferrer" target="_blank">Reorder a variable with ggplot2</a></li><li><a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/reorder.factor.html" rel="external nofollow noopener noreferrer" target="_blank">Reorder Levels of a Factor</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;ggplot2柱状图按照数值大小进行排序是比较困难的。&lt;strong&gt;这是因为ggplot2考虑的是因子级别的顺序，而不是数据框中观察到的顺序&lt;/strong&gt;。我们可以使用&lt;code&gt;sort()&lt;/code&gt;或&lt;code&gt;arrange()&lt;/code&gt;对输入数据框进行排序，但是这不会对ggplot2输出产生任何影响（柱状图依旧按照因子的顺序排列）。&lt;/p&gt;&lt;p&gt;本文主要介绍如何让ggplot2的柱状图按照数值大小排序。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="柱状图" scheme="https://tding.top/tags/%E6%9F%B1%E7%8A%B6%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>微信聊天记录解密并导出</title>
    <link href="https://tding.top/archives/e872e04.html"/>
    <id>https://tding.top/archives/e872e04.html</id>
    <published>2019-12-18T15:30:00.000Z</published>
    <updated>2019-12-19T15:55:37.603Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>我们知道，微信的聊天记录是加密的，因而我们不能从文件中直接查看、导出。本文主要介绍如何把聊天记录解密、导出成SQL或csv文件。</p><a id="more"></a><h2 id="手机微信数据库导出"><a href="#手机微信数据库导出" class="headerlink" title="手机微信数据库导出"></a>手机微信数据库导出</h2><h3 id="方法1——某些手机无需root即可备份"><a href="#方法1——某些手机无需root即可备份" class="headerlink" title="方法1——某些手机无需root即可备份"></a>方法1——某些手机无需root即可备份</h3><p>某些手机（比如某米、某为）通过官方的APP（无需root）即可把微信手机端的应用数据备份到电脑或者SD卡上。</p><p>但是我在实际操作的时候碰到了困难，我用的是某为手机，在电脑端和手机端均安装了官方提供的手机助手软件以后，正准备备份微信这个应用的数据，<strong>竟然一定要我输入密码进行加密</strong>，备份数据加密后就无法进行后续的操作了。我只好放弃了这个办法。</p><h3 id="方法2——root"><a href="#方法2——root" class="headerlink" title="方法2——root"></a>方法2——root</h3><p>如果你的手机已经root，那么你可以直接使用<code>adb</code>将<code>/data/data/com.tencent.mm</code>复制即可。</p><blockquote><p><code>/data/data/&lt;package_name&gt;</code>目录是app的私有目录，本身可以访问，外部程序没有访问权限，一些不想让用户看到的文件可以放在这里。此目录在程序卸载后将被删除，对应的是设置中的“数据”一项，如果清空数据，这个目录将会被清空。app自身对此目录的读写不需要额外的权限。<strong>注意：没root过的手机是看不到这个目录的</strong>。</p></blockquote><p>考虑到安全因素，我没有选择这种方法。</p><h3 id="方法3——安卓模拟器"><a href="#方法3——安卓模拟器" class="headerlink" title="方法3——安卓模拟器"></a>方法3——安卓模拟器</h3><p>我们可以在电脑上安装一款安卓模拟器，然后里面下载手机微信并登录，<strong>然后将手机端聊天记录备份到电脑端微信，再将电脑端聊天记录恢复到安卓虚拟器里的微信</strong>。现在对安卓虚拟器进行root，然后我就可以进入<code>/data/data/&lt;package_name&gt;</code>目录，从而把数据库复制到电脑上了。</p><p>下面我简单讲一下整个步骤：</p><ol><li>我选择了蓝叠这个安卓模拟器。首先在模拟器上下载了微信APP，然后我把自己手机微信上的聊天数据备份到电脑微信中，然后退出手机微信，在模拟器上登录微信，再把数据恢复到模拟器上的微信中。</li><li>在模拟器右上角的设置中打开root权限。</li><li>打开文件浏览器，找到数据库文件，它在<code>/data/data/com.tencent.mm/MicroMsg/[weixin_name]/EnMicroMsg.db</code>。<strong>其中文件夹 <code>[weixin_name]</code> 的名字为32位的md5值，如 <code>85794836981744a4472f69d89aeb2152</code>，一个微信号对应一个文件夹</strong>。如果有多个 <code>[weixin_name]</code>，那么此微信肯定登录过多个微信号。</li><li>把数据库文件拷贝到<code>/sdcard/windows/BstSharedFolder</code>这个共享文件夹中，这个文件夹在Windows上就是<code>BluestacksCN/Engine/ProgramData/Engine/UserData/SharedFolder</code>，当我们在模拟器中拷贝完数据后，在Windows上就能看到了。注意：数据是互通的。</li></ol><h2 id="破解数据库密码"><a href="#破解数据库密码" class="headerlink" title="破解数据库密码"></a>破解数据库密码</h2><p>根据前人的分析，微信数据库 <code>EnMicroMsg.db</code> 的密码是由 <code>MD5(IMEI + uin).substring(0, 7)</code> 生成的。因此，我们需要找到<code>IMEI</code>和<code>uin</code>值。</p><h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>我通过在模拟器上安装这个工具：<a href="https://apkpure.com/find-imei/com.imeino" rel="external nofollow noopener noreferrer" target="_blank">Find IMEI</a>来查看<code>IMEI</code>。</p><p>下载apk，然后把apk放入到<code>BluestacksCN/Engine/ProgramData/Engine/UserData/SharedFolder</code>这个文件夹中，我们就可以在模拟器的<code>/sdcard/windows/BstSharedFolder</code>文件夹中找到了，然后直接安装，打开就直接显示出<code>IMEI</code>了。</p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>我们也可以在<code>/data/data/com.tencent.mm/shared_prefs/DENGTA_META.xml</code>中查找名为 <code>IMEI_DENGTA</code> 的值。</p><h3 id="uin"><a href="#uin" class="headerlink" title="uin"></a>uin</h3><p><code>uin</code>（<code>unique identifier</code>）是唯一标识符（整数类型），微信分配每个用户的唯一标识符，它具有不可重复性，也就是说这个世界上没有两个 <code>uin</code> 相同的微信号。</p><h4 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h4><p>我们可以在<code>/data/data/com.tencent.mm/shared_prefs/system_config_prefs.xml</code>找到<code>default_uin</code>，后面的数字就是我们要找的<code>uin</code>了。</p><h4 id="方法2-1"><a href="#方法2-1" class="headerlink" title="方法2"></a>方法2</h4><p>我们也可以登录 web 微信，按 F12 打开网页调试工具，然后 <code>ctrl+F</code> 搜索 <code>uin</code>，可以找到一串长长的 URL，里面的 <code>uin</code> 就是当前登录的微信的 <code>uin</code>。</p><h3 id="计算密码"><a href="#计算密码" class="headerlink" title="计算密码"></a>计算密码</h3><p>注意：</p><ul><li><code>IMEI</code>中的字母必须为<strong>大写</strong></li><li><code>MD5</code>中的字母必须为<strong>小写</strong></li></ul><p>我们可以使用：<a href="http://emn178.github.io/online-tools/md5.html" rel="external nofollow noopener noreferrer" target="_blank">MD5在线计算</a>来计算MD5值，<strong>密码即为32位的前7位（小写）</strong>。</p><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><p>微信使用了<code>sqlcipher</code>加密了数据库，因此，我们也可以使用<code>sqlcipher</code>进行解密。</p><blockquote><p>SQLCipher是一个在SQLite基础之上进行扩展的开源数据库，它主要是在SQLite的基础之上增加了数据加密功能，如果我们在项目中使用它来存储数据的话，就可以大大提高程序的安全性。</p></blockquote><h3 id="Windows下打开"><a href="#Windows下打开" class="headerlink" title="Windows下打开"></a>Windows下打开</h3><p>Windows用户可以直接使用 <code>sqlcipher.exe</code> 打开 <code>com.tencent.mm/MicroMsg/[weixin_name]/EnMicroMsg.db</code>，在弹出的窗口输入刚刚生成的7位密码。</p><blockquote><p><code>sqlcipher.exe</code>其实是SQLite Database Browser软件再嵌套了解密功能。</p></blockquote><p><strong>注意：sqlcipher不同版本使用的加密方式不同，如果解密用<code>sqlcipher</code>版本和加密用的<code>sqlcipher</code>版本不一样，会提示<code>file is not a database</code>，实际错误是解密失败。目前发现<code>2.1</code>版本的sqlcipher可以正常解密</strong>。</p><p>然后我们可以在 <code>Browse Data</code> 菜单栏处查看数据中各个数据表。</p><p>我们可以点击菜单栏的<code>File-Export-Table as CSV file</code>，选择message表，导出成<code>csv</code>文件。如果直接用Excel打开这个表格，可能会显示乱码。所以我们新建一个Excel表格，点击数据-来自文本，然后导入这个<code>.csv</code>文件。在弹出的第一个下拉框中选择<code>GB2312</code>，然后载入就不会出现乱码。</p><h3 id="Ubuntu下打开"><a href="#Ubuntu下打开" class="headerlink" title="Ubuntu下打开"></a>Ubuntu下打开</h3><p>安装sqlicipher：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sqlcipher</span><br></pre></td></tr></table></figure><p>解密数据库文件，这里我们要输入前面得到的密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlcipher EnMicroMsg.db <span class="string">'PRAGMA key = "yourkey"; PRAGMA cipher_use_hmac = off; PRAGMA kdf_iter = 4000; ATTACH DATABASE "decrypted_database.db" AS decrypted_database KEY "";SELECT sqlcipher_export("decrypted_database");DETACH DATABASE decrypted_database;'</span></span><br></pre></td></tr></table></figure><p>然后我们就得到了解密的数据库<code>decrypted_database.db</code>，我们可以用自己熟悉的数据库软件打开。</p><h3 id="了解数据表"><a href="#了解数据表" class="headerlink" title="了解数据表"></a>了解数据表</h3><p>我们主要使用以下三个表：</p><ul><li><code>rcontact</code>：通讯录表</li><li><code>chatroom</code>：群聊表</li><li><code>message</code>：聊天记录表</li></ul><p>微信文字聊天记录在数据表<code>message</code>中。我们可以根据<code>talker</code>这个字段来筛选出特定用户的聊天记录。如果为群聊，那么<code>message.talker = chatroom.chatroomname</code>。<code>message.content</code>中存储形式为：<code>群成员wxid:\n内容</code>。</p><p>比如，我们可以查询与某人的聊天记录，下面是SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> datetime(<span class="keyword">subStr</span>(<span class="keyword">cast</span>(m.createTime <span class="keyword">as</span> <span class="built_in">text</span>),<span class="number">1</span>,<span class="number">10</span>),<span class="string">'unixepoch'</span>, <span class="string">'localtime'</span>) <span class="keyword">as</span> theTime,</span><br><span class="line"><span class="keyword">case</span> m.isSend </span><br><span class="line">    <span class="keyword">when</span> <span class="number">0</span> <span class="keyword">then</span> r.nickname </span><br><span class="line">    <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> <span class="string">'我'</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> person, m.content </span><br><span class="line"><span class="keyword">from</span> message m <span class="keyword">inner</span> <span class="keyword">join</span> rcontact r </span><br><span class="line"><span class="keyword">on</span> m.talker = r.username </span><br><span class="line"><span class="keyword">where</span> m.type = <span class="number">1</span> <span class="keyword">and</span> r.nickname = <span class="string">'对方微信昵称'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> theTime;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.imwxz.com/guide/134.html" rel="external nofollow noopener noreferrer" target="_blank">免root提取微信聊天记录数据库</a></li><li><a href="https://www.shixuen.com/android/weixin.html" rel="external nofollow noopener noreferrer" target="_blank">手机微信聊天记录的解密与恢复</a></li><li><a href="https://godweiyang.com/2019/08/09/wechat-explore/" rel="external nofollow noopener noreferrer" target="_blank">微信聊天记录导出为电脑txt文件教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;我们知道，微信的聊天记录是加密的，因而我们不能从文件中直接查看、导出。本文主要介绍如何把聊天记录解密、导出成SQL或csv文件。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="软件" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="微信" scheme="https://tding.top/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="sqlcipher" scheme="https://tding.top/tags/sqlcipher/"/>
    
      <category term="Android" scheme="https://tding.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Python requests在HTTP2.0下的问题</title>
    <link href="https://tding.top/archives/9bd92731.html"/>
    <id>https://tding.top/archives/9bd92731.html</id>
    <published>2019-12-17T14:32:15.000Z</published>
    <updated>2019-12-17T14:38:43.234Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>今天在用Python中的requests包爬数据时，发现了一个很特殊的请求头，其中有<code>:authority</code>、<code>:method</code>、<code>:path</code>、<code>:scheme</code>这几个参数，这些参数说明这个网站用了HTTP2.0。然后我发现我们不能用requests包直接构造请求头进行爬取了。本文简单分析并解决这个问题。</p><a id="more"></a><blockquote><p>HTTP2.0：请求/响应首部的定义基本没有改变，只是所有首部键必须全部小写，而且请求行要独立为<code>:method</code>、<code>:scheme</code>、<code>:host</code>、<code>:path</code>这些键值对。</p></blockquote><p>如果我们按照以前的设置构造headers进行爬取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"https://xxxxxx.com/tag/xxxx/page/1.html"</span></span><br><span class="line">headers = &#123;<span class="string">':authority'</span>: <span class="string">'xxxxxx.com'</span>,</span><br><span class="line">           <span class="string">':method'</span>: <span class="string">'GET'</span>,</span><br><span class="line">           <span class="string">':path'</span>: <span class="string">'/tag/xxxx/page/1'</span>,</span><br><span class="line">           <span class="string">':scheme'</span>: <span class="string">'https'</span>,</span><br><span class="line">           <span class="string">'accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span>,</span><br><span class="line">           <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">           <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-Mode'</span>:<span class="string">'navigate'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-Site'</span>:<span class="string">'none'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-User'</span>:<span class="string">'?1'</span>,</span><br><span class="line">           <span class="string">'Upgrade-Insecure-Requests'</span>:<span class="string">'1'</span>,</span><br><span class="line">           <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">requests.get(url = url, headers = headers)</span><br></pre></td></tr></table></figure><p>会报出以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Invalid header name b&apos;:authority&apos;</span><br></pre></td></tr></table></figure><p>这是因为HTTP的请求头不能以分号开头。源码不能解析这样的请求头，具体可以见<a href="https://github.com/python/cpython/blob/master/Lib/http/client.py#L1196" rel="external nofollow noopener noreferrer" target="_blank">源码</a>。</p><p>我们可以使用hyper这个第三方包来解决这个问题，我们将代码改写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hyper.contrib <span class="keyword">import</span> HTTP20Adapter</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://xxxxxx.com/tag/xxxx/page/1.html"</span></span><br><span class="line">headers = &#123;<span class="string">':authority'</span>: <span class="string">'xxxxxx.com'</span>,</span><br><span class="line">           <span class="string">':method'</span>: <span class="string">'GET'</span>,</span><br><span class="line">           <span class="string">':path'</span>: <span class="string">'/tag/xxxx/page/1'</span>,</span><br><span class="line">           <span class="string">':scheme'</span>: <span class="string">'https'</span>,</span><br><span class="line">           <span class="string">'accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span>,</span><br><span class="line">           <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">           <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-Mode'</span>:<span class="string">'navigate'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-Site'</span>:<span class="string">'none'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-User'</span>:<span class="string">'?1'</span>,</span><br><span class="line">           <span class="string">'Upgrade-Insecure-Requests'</span>:<span class="string">'1'</span>,</span><br><span class="line">           <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">sessions = requests.session()</span><br><span class="line">sessions.mount(<span class="string">'https://xxxx.com'</span>, HTTP20Adapter())</span><br><span class="line">response = sessions.get(url = url,headers = headers)</span><br></pre></td></tr></table></figure><p>OK，问题解决！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/51630571/http-headers-requests-python" rel="external nofollow noopener noreferrer" target="_blank">HTTP headers - Requests - Python</a></li><li><a href="https://www.jianshu.com/p/1335a518151f" rel="external nofollow noopener noreferrer" target="_blank">Python 请求头header在http/http2下的问题</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;今天在用Python中的requests包爬数据时，发现了一个很特殊的请求头，其中有&lt;code&gt;:authority&lt;/code&gt;、&lt;code&gt;:method&lt;/code&gt;、&lt;code&gt;:path&lt;/code&gt;、&lt;code&gt;:scheme&lt;/code&gt;这几个参数，这些参数说明这个网站用了HTTP2.0。然后我发现我们不能用requests包直接构造请求头进行爬取了。本文简单分析并解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://tding.top/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="问题" scheme="https://tding.top/categories/%E7%88%AC%E8%99%AB/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="Python" scheme="https://tding.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://tding.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="requests" scheme="https://tding.top/tags/requests/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu内置的Python3.5安装pip模块</title>
    <link href="https://tding.top/archives/399c2726.html"/>
    <id>https://tding.top/archives/399c2726.html</id>
    <published>2019-12-16T14:55:30.000Z</published>
    <updated>2019-12-17T14:38:43.245Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>本文首先介绍了如何给Ubuntu16.04内置的Python3.5安装pip模块，然后扩展介绍了多版本Python安装对应pip以及对pip对应Python版本进行管理的方法。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>当我想通过Ubuntu16.04内置的Python3.5的pip安装第三方包时，出现如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/home<span class="comment"># python3 -m pip install numpy</span></span><br><span class="line">/usr/bin/python3: No module named pip</span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>从错误描述来看，pip包不存在。</p><p>我们知道：</p><ul><li>Debian软件管理器（<code>sudo apt-get install</code>）安装的package存放在 <code>/usr/lib/python2.7/dist-packages</code>目录中</li><li>Python软件管理器（<code>easy_install</code>和<code>pip</code>）安装的package存放在<code>/usr/local/lib/python2.7/dist-packages</code>目录中</li><li>手动从源代码安装的package会直接使用目录<code>site-packages</code></li></ul><p>然后我进入到以下目录，看下是否存在pip文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/home<span class="comment"># cd /usr/local/lib/python3.5/dist-packages/</span></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.5/dist-packages<span class="comment"># ll</span></span><br><span class="line">total 8</span><br><span class="line">drwxrwsr-x 2 root staff 4096 Nov 14 08:10 ./</span><br><span class="line">drwxrwsr-x 3 root staff 4096 Nov 14 08:10 ../</span><br></pre></td></tr></table></figure><p>发现当前目录是空的，并没有pip，说明并没有装上pip，因此，我们需要<strong>手动安装pip</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">sudo python3.5 get-pip.py</span><br></pre></td></tr></table></figure><p><strong>注意：这里的Python3.5根据你Python的版本进行替换</strong>。</p><p>然后查看一下是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br></pre></td></tr></table></figure><p>显示下面说明安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip 19.3.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)</span><br></pre></td></tr></table></figure><p>然后我们就可以使用pip来安装别的包了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install XXX</span><br></pre></td></tr></table></figure><h2 id="pip版本管理"><a href="#pip版本管理" class="headerlink" title="pip版本管理"></a>pip版本管理</h2><p>首先我通过上面的方法安装了Python2.7的pip，此时查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python2.7/dist-packages<span class="comment"># pip -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/pip (python 2.7)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python2.7/dist-packages<span class="comment"># pip2 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/pip (python 2.7)</span><br></pre></td></tr></table></figure><p>然后我用同样的方法安装了Python3.5的pip，此时查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.5/dist-packages<span class="comment"># pip -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.5/dist-packages/pip (python 3.5)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.5/dist-packages<span class="comment"># pip3 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.5/dist-packages/pip (python 3.5)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.5/dist-packages<span class="comment"># pip3.5 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.5/dist-packages/pip (python 3.5)</span><br></pre></td></tr></table></figure><p>然后我用同样的方法安装了Python3.6的pip，此时查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># pip -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.6/dist-packages/pip (python 3.6)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># pip3 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.6/dist-packages/pip (python 3.6)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># pip3.5 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.5/dist-packages/pip (python 3.5)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># pip3.6 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.6/dist-packages/pip (python 3.6)</span><br></pre></td></tr></table></figure><p>我们发现，<strong>每次安装pip，它都会把默认pip对应的Python修改，导致pip对应版本混乱</strong>。</p><p>现在系统中安装了Python2.7、Python3.5、Python3.6。各个pip对应的Python版本如下：</p><ul><li><code>pip</code>对应<code>Python3.6</code></li><li><code>pip2</code>对应<code>Python2.7</code></li><li><code>pip3</code>对应<code>Python3.6</code></li><li><code>pip3.5</code>对应<code>Python3.5</code></li><li><code>pip3.6</code>对应<code>Python3.6</code></li></ul><p><strong>现在我们想要让<code>pip</code>对应<code>Python2.7</code>，让<code>pip3</code>对应<code>Python3.5</code></strong>。</p><p>然后我们进入到<code>/usr/local/bin</code>，发现里面有很多<code>pip</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># cd /usr/local/bin/</span></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/bin<span class="comment"># ll</span></span><br><span class="line">total 52</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 15 03:37 ./</span><br><span class="line">drwxr-xr-x 10 root root 4096 Nov 14 08:09 ../</span><br><span class="line">-rwxr-xr-x  1 root root  232 Dec 15 03:37 easy_install*</span><br><span class="line">-rwxr-xr-x  1 root root  232 Dec 15 03:19 easy_install-2.7*</span><br><span class="line">-rwxr-xr-x  1 root root  232 Dec 15 03:20 easy_install-3.5*</span><br><span class="line">-rwxr-xr-x  1 root root  232 Dec 15 03:37 easy_install-3.6*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:37 pip*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:19 pip2*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:19 pip2.7*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:37 pip3*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:20 pip3.5*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:37 pip3.6*</span><br><span class="line">-rwxr-xr-x  1 root root  210 Dec 15 03:37 wheel*</span><br></pre></td></tr></table></figure><p>这些pip文件其实是Python脚本文件，我们可以用vim打开<code>pip</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3.6</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pip._internal.main <span class="keyword">import</span> main</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sys.argv[<span class="number">0</span>] = re.sub(<span class="string">r'(-script\.pyw|\.exe)?$'</span>, <span class="string">''</span>, sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure><p><strong>这个文件的第一行指定了这个脚本对应的Python版本，如果想把pip对应的Python版本改为2.7的，只需修改Python3.6为Python2.7即可</strong>。修改保存后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/bin<span class="comment"># pip -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/pip (python 2.7)</span><br></pre></td></tr></table></figure><p>我们已经成功的把pip对应的Python版本改为了2.7，同理也可以修改pip3对应的版本。</p><p>注意：<strong>不同版本的pip对应的这个脚本文件的内容不同</strong>，上面显示的是<code>pip 19.3.1</code>版本的，其它版本的脚本文件内容可能与之不同。直接改这个脚本文件来修改pip对应的Python版本的前提是：当前脚本文件对应的Python版本与要修改对应的Python版本的pip包版本最好一致，不一致很可能出错。<strong>最简单的解决办法是都升级为最新的pip版本</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/9387928/whats-the-difference-between-dist-packages-and-site-packages" rel="external nofollow noopener noreferrer" target="_blank">What’s the difference between dist-packages and site-packages?</a></li><li><a href="https://zhuanlan.zhihu.com/p/37473690" rel="external nofollow noopener noreferrer" target="_blank">多版本Python安装pip及pip版本管理终极教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本文首先介绍了如何给Ubuntu16.04内置的Python3.5安装pip模块，然后扩展介绍了多版本Python安装对应pip以及对pip对应Python版本进行管理的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://tding.top/categories/Python/"/>
    
      <category term="pip" scheme="https://tding.top/categories/Python/pip/"/>
    
    
      <category term="Python" scheme="https://tding.top/tags/Python/"/>
    
      <category term="pip" scheme="https://tding.top/tags/pip/"/>
    
      <category term="Ubuntu" scheme="https://tding.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置Cloudflare免费CDN</title>
    <link href="https://tding.top/archives/12c6c559.html"/>
    <id>https://tding.top/archives/12c6c559.html</id>
    <published>2019-12-14T13:56:00.000Z</published>
    <updated>2019-12-14T12:44:33.880Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:00 GMT+0800 (中国标准时间) --><p>由于 GitHub Pages 的服务器在国外，国内访问速度可能会非常慢。目前有以下几种解决方案：</p><ul><li>博客双线部署在GitHub Pages和Coding Pages上，其中国内流量解析到Coding Pages，国外流量解析到GitHub Pages<ul><li>优势：无需购买VPS、速度比较快、不用备案</li><li>劣势：Coding Pages的服务并不是那么稳定，近期出现多次不能正常部署或访问Pages的问题</li></ul></li><li>博客部署到国内的VPS<ul><li>优势：速度快</li><li>劣势：需要购买VPS、需要备案</li></ul></li><li>博客部署在GitHub Pages上并采用CDN加速<ul><li>优势：速度快、无需备案、稳定</li><li>劣势：CDN比较贵，hhh</li></ul></li></ul><p>本文主要介绍Hexo博客部署在GitHub Pages上并且配置CDN进行加速的方法。</p><p>这里我们假设博客已经部署在GitHub Pages并启用了个性域名。如果你还没有绑定个性域名，可以参考这篇教程：<a href="https://tding.top/archives/b48e2719.html">GitHub Pages 绑定域名</a>，其中域名服务器修改到DNSPod这部分可以不看，因为这里我们会用Cloudflare来完成域名解析。</p><a id="more"></a><h2 id="CDN介绍"><a href="#CDN介绍" class="headerlink" title="CDN介绍"></a>CDN介绍</h2><blockquote><p>内容分发网络（Content delivery network或Content distribution network，缩写：CDN）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p></blockquote><p>简单来说，CDN 就是部署在世界各地的缓存服务器，它们会提前缓存网站上的资源，然后当用户想要访问相关资源时，直接从 CDN 服务器上取就可以了。这样不仅可以增加访问速度减少访问延迟，还可以减缓网站服务器上的压力。</p><h2 id="为什么选择Cloudflare？"><a href="#为什么选择Cloudflare？" class="headerlink" title="为什么选择Cloudflare？"></a>为什么选择Cloudflare？</h2><p>国内的CDN服务提供商有不少，但是基本都需要备案，因此我转向了Cloudflare这个国外的CDN服务提供商。</p><p>Cloudflare 是全球最大的 DNS 服务提供商之一。除此之外他们还提供CDN、SSL证书、DDos保护等服务，并且 Cloudflare 与百度有合作，在国内也部署有大量的节点，还能顺便解决百度爬无法抓取 GitHub Pages 的问题。</p><h2 id="CDN配置"><a href="#CDN配置" class="headerlink" title="CDN配置"></a>CDN配置</h2><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><ol><li><p>首先要去 Cloudflare 注册一个帐号。<strong>注意：我们需要的是国际版的 CloudFlare，而不是 CloudFlare 与百度合作的百度云加速</strong>。</p></li><li><p>注册好后点击 <code>Add site</code> 添加你的网站个性化域名。</p></li><li><p>添加好后选择免费的那个计划（Plan），有钱也可以选择收费的，提供的服务更多。</p></li><li><p>然后点击 <code>Scan DNS Records</code>，等待扫描完成。即使没有扫到 DNS 记录也没有关系，我们可以在后面自己添加，我们只需要添加下图框起来的那两条：</p></li></ol><img src="/archives/12c6c559/DNS设置.png" title="DNS设置"><ol start="5"><li>然后 Cloudflare 会要你把你的 DNS 服务器替换成他提供的，我们只需要去域名商那里设置一下即可。<strong>CloudFlare 既是一个 CDN 服务商，同样也是一个 DNS 服务商</strong>。DNS修改完成后可以点击 <code>Recheck Nameservers</code> 来复查 NS 记录是否正确设置。</li></ol><p>然后过个几分钟，显示 <code>Great news! Cloudflare is now protecting your site</code> 就说明设置成功。</p><h3 id="Cloudflare设置详解"><a href="#Cloudflare设置详解" class="headerlink" title="Cloudflare设置详解"></a>Cloudflare设置详解</h3><h4 id="Overview菜单设置"><a href="#Overview菜单设置" class="headerlink" title="Overview菜单设置"></a>Overview菜单设置</h4><p>主要关注下面两个快捷设置：</p><ul><li><code>under attack mode</code>：当你的网站被攻击的时候打开它，这样可以阻止攻击。</li><li><code>development mode</code>：由于cloudflare采用了缓存技术，当你更新了网站的内容，不一定能马上在前台看到更新的内容。这个时候你只要打开development mode就可以马上看到网站更新的内容。当然，正常情况下还是关掉比较好。</li></ul><img src="/archives/12c6c559/Overview菜单设置.png" title="Overview菜单设置"><h4 id="Analytics菜单设置"><a href="#Analytics菜单设置" class="headerlink" title="Analytics菜单设置"></a>Analytics菜单设置</h4><p>这里主要是看网站使用cloudflare之后的一些分析数据，Analytics下面包含几个子菜单：Traffic、security、Performance、DNS。</p><ul><li>Traffic子菜单：主要是网站在过去某一个时间段的请求、带宽、访客情况。</li><li>Security子菜单：主要是某一段时间内受到的威胁数据，包括威胁次数、来自哪些国家、威胁的类型等等。</li><li>Performance子菜单：付费功能。</li><li>DNS子菜单：主要是DNS查询的数据。</li></ul><h4 id="DNS菜单设置"><a href="#DNS菜单设置" class="headerlink" title="DNS菜单设置"></a>DNS菜单设置</h4><p>在DNS菜单里面，你可以随意添加或删除所有DNS记录，也可以选择使用或不使用cloudflare的CDN服务。</p><p>注意：只有A记录和CNAME记录才可以设置使用CDN服务，我们只需要点亮<code>Proxy status</code>处的云彩小图标即可切换成使用CDN的状态。</p><h4 id="SSL-TLS菜单设置"><a href="#SSL-TLS菜单设置" class="headerlink" title="SSL/TLS菜单设置"></a>SSL/TLS菜单设置</h4><p>这里面主要是网站加密的设置。</p><ul><li><code>SSL</code>设置：如果你本来的网站有SSL证书，这里选择full即可，即浏览器到Cloudflare和Cloudflare到服务器都是加密的。</li><li><strong><code>Always Use HTTPS</code>设置：这个打开，一直使用https链接</strong>。</li><li><code>Authenticated Origin Pulls</code> &amp; <code>Opportunistic Encryption</code> &amp; <code>Onion Routing</code>设置：这些设置都打开</li><li><code>Minimum TLS Version</code>设置：选择1.1即可，如果选择太高可能导致网站打不开。</li></ul><h4 id="Firewall菜单设置"><a href="#Firewall菜单设置" class="headerlink" title="Firewall菜单设置"></a>Firewall菜单设置</h4><p>Firewall菜单里面可以对网站安全进一步设置，限制某些IP或地区的用户访问等。</p><ul><li>Events子菜单：这里面可以查看防火墙的一些小事件，比如屏蔽的一些访问。</li><li>Managed Rules子菜单：付费功能。</li><li>Firewall Rules子菜单：这里可以设置限制其他人访问你的网站的规则，每个账户只能设置5个限制规则。</li><li>TOOLS子菜单：这里的功能是firewall rules功能的补充，都是对用户访问你的网站的一些设置。<ul><li><code>IP Access Rules</code>：主要是针对IP、IP范围及国家和ASN设置一些规则。</li><li><code>User Agent Blocking</code>：对用户使用的代理设置规则，比如浏览器类型、CPU、操作系统。</li></ul></li><li>Settting子菜单：<ul><li><code>Security Level</code>：这个设置low即可，如果设置太高，就会过于敏感，导致很多用户受影响。</li><li><code>Challenge Passage</code>：这是验证的有效期，可以设置久一点，比如<code>1 hour</code>。</li><li><code>Browser Integrity Check</code> 和 <code>Privacy Pass Support</code>：全部打开。</li></ul></li></ul><h4 id="Speed菜单设置"><a href="#Speed菜单设置" class="headerlink" title="Speed菜单设置"></a>Speed菜单设置</h4><ul><li><code>Auto Minify</code>：网页最小化处理，把Javascript, css html前面都打勾即可。</li><li><code>Brotli</code>：这是一种比gzip更好的网页压缩方式，打开即可。</li><li><code>Rocket Loader</code>：这个需要测试决定是否需要打开，没有固定的答案，你可以打开之后，然后在不同的浏览器上面查看网页的效果，如果出现网页排版等问题，那就将它关闭。</li></ul><h4 id="Caching菜单设置"><a href="#Caching菜单设置" class="headerlink" title="Caching菜单设置"></a>Caching菜单设置</h4><ul><li><code>Purge Cache</code>：这个设置是清除缓存，其中：<ul><li><code>Custom Purge</code>：清除指定页面的缓存，我们可以点击<code>custom purge</code>, 然后在框里面输入要清除的链接，再点击<code>purge</code>即可。</li><li><code>Purge Everything</code>：清除整个网站的缓存。</li></ul></li><li><code>Caching Level</code>：缓存水平设置，决定缓存哪些内容，这里选择standard即可。</li><li><code>Browser Cache TTL</code>：即浏览器缓存过期时间，决定浏览器多久向网站获取一次新缓存。</li></ul><h4 id="Page-Rules菜单设置"><a href="#Page-Rules菜单设置" class="headerlink" title="Page Rules菜单设置"></a>Page Rules菜单设置</h4><p>免费版本可以设置3个页面的规则。</p><p>这里我们可以设置forwarding，也就是301跳转，比如我想要让<code>tding.me</code>整个站都跳转到<code>tding.top</code>，具体设置如下图：</p><img src="/archives/12c6c559/跳转设置.png" title="跳转设置"><p>注意：如果<code>Forwarding URL</code>设置为<code>https://tding.top</code>，当我们访问<code>tding.me/about.html</code>时会跳转到<code>https://tding.top</code>而不是我们期望的<code>https://tding.top/about.html</code>。解决办法就是使用<strong>变量</strong>，每个通配符对应于可在转发地址中引用的变量。变量用 <code>$</code> 后跟一个数字表示，如果要引用第一个通配符，我们可以使用 <code>$1</code>，如果要引用第二个通配符，我们可以使用 <code>$2</code>，依此类推。<strong>因此，<code>Forwarding URL</code>应该设置成<code>https://tding.top/$1</code></strong>。</p><h2 id="测速"><a href="#测速" class="headerlink" title="测速"></a>测速</h2><p>下面是Cloudflare CDN加速后（左图）于GitHub Pages本身（右图）的速度对比：</p><img src="/archives/12c6c559/测速.png" title="测速"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mogeko.me/2019/056/" rel="external nofollow noopener noreferrer" target="_blank">为博客添加免费的 CDN (Cloudflare)</a></li><li><a href="https://www.imhunk.com/cloudflare-tutorials/" rel="external nofollow noopener noreferrer" target="_blank">如何用CDN加速你的网站 – Cloudflare免费版详细使用教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:00 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;由于 GitHub Pages 的服务器在国外，国内访问速度可能会非常慢。目前有以下几种解决方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;博客双线部署在GitHub Pages和Coding Pages上，其中国内流量解析到Coding Pages，国外流量解析到GitHub Pages&lt;ul&gt;&lt;li&gt;优势：无需购买VPS、速度比较快、不用备案&lt;/li&gt;&lt;li&gt;劣势：Coding Pages的服务并不是那么稳定，近期出现多次不能正常部署或访问Pages的问题&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;博客部署到国内的VPS&lt;ul&gt;&lt;li&gt;优势：速度快&lt;/li&gt;&lt;li&gt;劣势：需要购买VPS、需要备案&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;博客部署在GitHub Pages上并采用CDN加速&lt;ul&gt;&lt;li&gt;优势：速度快、无需备案、稳定&lt;/li&gt;&lt;li&gt;劣势：CDN比较贵，hhh&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文主要介绍Hexo博客部署在GitHub Pages上并且配置CDN进行加速的方法。&lt;/p&gt;&lt;p&gt;这里我们假设博客已经部署在GitHub Pages并启用了个性域名。如果你还没有绑定个性域名，可以参考这篇教程：&lt;a href=&quot;https://tding.top/archives/b48e2719.html&quot;&gt;GitHub Pages 绑定域名&lt;/a&gt;，其中域名服务器修改到DNSPod这部分可以不看，因为这里我们会用Cloudflare来完成域名解析。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Hexo" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://tding.top/tags/Hexo/"/>
    
      <category term="GitHub Pages" scheme="https://tding.top/tags/GitHub-Pages/"/>
    
      <category term="CDN" scheme="https://tding.top/tags/CDN/"/>
    
      <category term="Cloudflare" scheme="https://tding.top/tags/Cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-相关矩阵热力图</title>
    <link href="https://tding.top/archives/7fa1138e.html"/>
    <id>https://tding.top/archives/7fa1138e.html</id>
    <published>2019-12-12T15:30:00.000Z</published>
    <updated>2019-12-12T15:39:02.981Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>在数据分析时，我们经常需要看变量之间的相关性，一般采用相关矩阵热力图进行可视化，而ggplot2本身不能直接绘制热图，因此我们需要做数据变换把相关矩阵转换为一个3列的数据框（变量名Var1、变量名Var2、数值value），然后再分别映射给x、y和fill参数，绘制出热力图。</p><a id="more"></a><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>这里我用的是ggplot2内置的mtcars数据集：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- mtcars[, c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)]</span><br><span class="line">head(df)</span><br></pre></td></tr></table></figure><p>这个数据前6行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                   mpg disp  hp drat    wt  qsec</span><br><span class="line">Mazda RX4         21.0  160 110 3.90 2.620 16.46</span><br><span class="line">Mazda RX4 Wag     21.0  160 110 3.90 2.875 17.02</span><br><span class="line">Datsun 710        22.8  108  93 3.85 2.320 18.61</span><br><span class="line">Hornet 4 Drive    21.4  258 110 3.08 3.215 19.44</span><br><span class="line">Hornet Sportabout 18.7  360 175 3.15 3.440 17.02</span><br><span class="line">Valiant           18.1  225 105 2.76 3.460 20.22</span><br></pre></td></tr></table></figure><p>然后计算相关矩阵：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">round(cor(df), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       mpg  disp    hp  drat    wt  qsec</span><br><span class="line">mpg   1.00 -0.85 -0.78  0.68 -0.87  0.42</span><br><span class="line">disp -0.85  1.00  0.79 -0.71  0.89 -0.43</span><br><span class="line">hp   -0.78  0.79  1.00 -0.45  0.66 -0.71</span><br><span class="line">drat  0.68 -0.71 -0.45  1.00 -0.71  0.09</span><br><span class="line">wt   -0.87  0.89  0.66 -0.71  1.00 -0.17</span><br><span class="line">qsec  0.42 -0.43 -0.71  0.09 -0.17  1.00</span><br></pre></td></tr></table></figure><p>然后我用reshape2包中的<code>melt()</code>函数将这个相关矩阵转换为3列的数据框格式：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_cor &lt;- round(cor(df), <span class="number">2</span>)</span><br><span class="line">melt(df_cor)</span><br></pre></td></tr></table></figure><p>下面是输出的前6行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Var1 Var2 value</span><br><span class="line">1  mpg  mpg  1.00</span><br><span class="line">2 disp  mpg -0.85</span><br><span class="line">3   hp  mpg -0.78</span><br><span class="line">4 drat  mpg  0.68</span><br><span class="line">5   wt  mpg -0.87</span><br><span class="line">6 qsec  mpg  0.42</span><br></pre></td></tr></table></figure><h2 id="相关矩阵热力图绘制"><a href="#相关矩阵热力图绘制" class="headerlink" title="相关矩阵热力图绘制"></a>相关矩阵热力图绘制</h2><h3 id="基本相关矩阵热力图绘制"><a href="#基本相关矩阵热力图绘制" class="headerlink" title="基本相关矩阵热力图绘制"></a>基本相关矩阵热力图绘制</h3><p>前面我们已经得到了3列的数据框（变量名Var1、变量名Var2、数值value），现在我们只需要将它们分别映射给x、y和fill参数，就能够绘制出热力图。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df_cor &lt;- round(cor(df), <span class="number">2</span>) </span><br><span class="line">df_cor %&gt;%</span><br><span class="line">    melt() %&gt;%</span><br><span class="line">    ggplot(aes(x = Var1, y = Var2, fill = value)) + </span><br><span class="line">    geom_tile()</span><br></pre></td></tr></table></figure><img src="/archives/7fa1138e/1.png" title="图1"><p>默认的绘图样式比较丑，也不太直观。</p><h3 id="相关矩阵的下三角绘制热力图"><a href="#相关矩阵的下三角绘制热力图" class="headerlink" title="相关矩阵的下三角绘制热力图"></a>相关矩阵的下三角绘制热力图</h3><p>相关矩阵具有冗余信息，因此，我们可以将其中的上三角部分设置为NA：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_cor &lt;- round(cor(df), <span class="number">2</span>)</span><br><span class="line">df_cor[upper.tri(df_cor)] &lt;- <span class="literal">NA</span></span><br></pre></td></tr></table></figure><p>下面是<code>df_cor</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       mpg  disp    hp  drat    wt  qsec</span><br><span class="line">mpg   1.00    NA    NA    NA    NA    NA</span><br><span class="line">disp -0.85  1.00    NA    NA    NA    NA</span><br><span class="line">hp   -0.78  0.79  1.00    NA    NA    NA</span><br><span class="line">drat  0.68 -0.71 -0.45  1.00    NA    NA</span><br><span class="line">wt   -0.87  0.89  0.66 -0.71  1.00    NA</span><br><span class="line">qsec  0.42 -0.43 -0.71  0.09 -0.17  1.00</span><br></pre></td></tr></table></figure><p>下面绘制热力图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相关矩阵的上三角-左图</span></span><br><span class="line">df_cor %&gt;% </span><br><span class="line">    melt(na.rm = <span class="literal">TRUE</span>) %&gt;%</span><br><span class="line">    ggplot(aes(x = Var1, y = Var2, fill = value)) + </span><br><span class="line">    geom_tile()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相关矩阵的上三角+颜色标度+样式美化-右图</span></span><br><span class="line">df_cor %&gt;% </span><br><span class="line">    melt(na.rm = <span class="literal">TRUE</span>) %&gt;%</span><br><span class="line">    ggplot(aes(x = Var1, y = Var2, fill = value)) + </span><br><span class="line">    geom_tile() + </span><br><span class="line">    scale_fill_gradient2(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>, mid = <span class="string">"white"</span>, midpoint = <span class="number">0</span>, limit = c(-<span class="number">1</span>,<span class="number">1</span>), space = <span class="string">"Lab"</span>, name=<span class="string">"Pearson\nCorrelation"</span>) + </span><br><span class="line">    coord_fixed()</span><br></pre></td></tr></table></figure><img src="/archives/7fa1138e/2.png" title="图2"><ul><li><code>coord_fixed()</code>：使得x轴上的一个单位与y轴上的一个单位的长度相同。</li></ul><h3 id="相关矩阵重新排序"><a href="#相关矩阵重新排序" class="headerlink" title="相关矩阵重新排序"></a>相关矩阵重新排序</h3><p>我们可以根据相关系数对相关矩阵进行重新排序，这样可以更容易地识别矩阵中的隐藏模式。</p><p>下面我们用分层聚类<code>hclust()</code>函数对相关矩阵进行重新排序：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df_cor &lt;- round(cor(df), <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 根据距离重新排序</span></span><br><span class="line">dd &lt;- as.dist((<span class="number">1</span> - df_cor)/<span class="number">2</span>)</span><br><span class="line">hc &lt;- hclust(dd)</span><br><span class="line">df_cor &lt;- df_cor[hc$order, hc$order]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上三角部分设置为NA</span></span><br><span class="line">df_cor[upper.tri(df_cor)] &lt;- <span class="literal">NA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 热力图绘制</span></span><br><span class="line">heatmap_1 &lt;- df_cor %&gt;% </span><br><span class="line">    melt(na.rm = <span class="literal">TRUE</span>) %&gt;%</span><br><span class="line">    ggplot(aes(x = Var1, y = Var2, fill = value)) + </span><br><span class="line">    geom_tile() + </span><br><span class="line">    scale_fill_gradient2(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>, mid = <span class="string">"white"</span>, midpoint = <span class="number">0</span>, limit = c(-<span class="number">1</span>,<span class="number">1</span>), space = <span class="string">"Lab"</span>, name=<span class="string">"Pearson\nCorrelation"</span>) + </span><br><span class="line">    coord_fixed()</span><br></pre></td></tr></table></figure><p>下面左图是相关矩阵未排序的热力图，右图是相关矩阵排序后的热力图：</p><img src="/archives/7fa1138e/3.png" title="图3"><h3 id="热力图上显示相关系数值"><a href="#热力图上显示相关系数值" class="headerlink" title="热力图上显示相关系数值"></a>热力图上显示相关系数值</h3><p>我们可以用<code>geom_text()</code>函数在热力图上<strong>添加相关系数值</strong>，这样更加直观。然后我可以把主题<code>theme()</code>设置为<strong>空白主题（删除轴标签、轴刻度、面板网格、背景）</strong>，最后改变图例位置。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 热力图上显示相关系数值-左图</span></span><br><span class="line">heatmap_1 + </span><br><span class="line">    geom_text(aes(Var1, Var2, label = value), color = <span class="string">"black"</span>, size = <span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 热力图上显示相关系数值+主题、图例美化-右图</span></span><br><span class="line">heatmap_1 + </span><br><span class="line">    geom_text(aes(Var1, Var2, label = value), color = <span class="string">"black"</span>, size = <span class="number">4</span>)  + </span><br><span class="line">    theme(</span><br><span class="line">        axis.title.x = element_blank(),</span><br><span class="line">        axis.title.y = element_blank(),</span><br><span class="line">        panel.grid.major = element_blank(),</span><br><span class="line">        panel.border = element_blank(),</span><br><span class="line">        panel.background = element_blank(),</span><br><span class="line">        axis.ticks = element_blank(),</span><br><span class="line">        legend.justification = c(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        legend.position = c(<span class="number">0.6</span>, <span class="number">0.7</span>),</span><br><span class="line">        legend.direction = <span class="string">"horizontal"</span></span><br><span class="line">    ) +</span><br><span class="line">    guides(fill = guide_colorbar(barwidth = <span class="number">7</span>, barheight = <span class="number">1</span>, title.position = <span class="string">"top"</span>, title.hjust = <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><img src="/archives/7fa1138e/4.png" title="图4"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zhouhucheng00/article/details/86143828" rel="external nofollow noopener noreferrer" target="_blank">数据可视化——R语言ggplot2包绘制相关矩阵为热图</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在数据分析时，我们经常需要看变量之间的相关性，一般采用相关矩阵热力图进行可视化，而ggplot2本身不能直接绘制热图，因此我们需要做数据变换把相关矩阵转换为一个3列的数据框（变量名Var1、变量名Var2、数值value），然后再分别映射给x、y和fill参数，绘制出热力图。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="热力图" scheme="https://tding.top/tags/%E7%83%AD%E5%8A%9B%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>ggplot2去除箱型图中的离群点</title>
    <link href="https://tding.top/archives/67c7ad2c.html"/>
    <id>https://tding.top/archives/67c7ad2c.html</id>
    <published>2019-12-12T06:30:00.000Z</published>
    <updated>2019-12-12T15:39:02.988Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>我们在用ggplot2的箱型图<code>boxplot()</code>可视化时会发现，部分特别异常的离群点导致箱型图自身被压缩的很扁，而我们一般更关注箱型图本身。因此，我们需要<strong>在不影响箱型图自身的分布的同时去除这些离群点</strong>。</p><a id="more"></a><h2 id="方法1——通过geom-boxplot-中的参数设置"><a href="#方法1——通过geom-boxplot-中的参数设置" class="headerlink" title="方法1——通过geom_boxplot()中的参数设置"></a>方法1——通过<code>geom_boxplot()</code>中的参数设置</h2><p>我们可以通过箱型图函数<code>geom_boxplot()</code>中的参数设置来不显示这些离群点：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geom_boxplot(outlier.shape = <span class="literal">NA</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geom_boxplot(outlier.colour = <span class="literal">NA</span>)</span><br></pre></td></tr></table></figure><img src="/archives/67c7ad2c/1.png" title="图1"><p>但是这个方法不能满足我们的需求，这里虽然离群点都不再显示了，但是箱型图本身却没有被放大，没有达到我们的目的。</p><h2 id="方法2——通过位置标度设置"><a href="#方法2——通过位置标度设置" class="headerlink" title="方法2——通过位置标度设置"></a>方法2——通过位置标度设置</h2><p>我们可以通过位置标度函数<code>scale_y_continuous()</code>来改变y轴范围：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scale_y_continuous(limits = c(<span class="number">0</span>,<span class="number">2e+8</span>))</span><br></pre></td></tr></table></figure><img src="/archives/67c7ad2c/2.png" title="图2"><p>这个方法把处于范围外的数据点也删除了，然后在新设置的范围内重新计算绘图，这很可能会改变最后绘制的箱型图。这个方法也不能达到我们的目的。</p><h2 id="方法3——笛卡尔坐标系变换"><a href="#方法3——笛卡尔坐标系变换" class="headerlink" title="方法3——笛卡尔坐标系变换"></a>方法3——笛卡尔坐标系变换</h2><p>我们可以用笛卡尔坐标系变换函数<code>coord_trans()</code>对图进行放大：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_trans(x = <span class="string">"identity"</span>, y = <span class="string">"identity"</span>, limx = <span class="literal">NULL</span>, limy = c(<span class="number">0</span>,<span class="number">2e+8</span>))</span><br></pre></td></tr></table></figure><img src="/archives/67c7ad2c/3.png" title="图3"><p>这个方法比较完美的解决了我的问题。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;我们在用ggplot2的箱型图&lt;code&gt;boxplot()&lt;/code&gt;可视化时会发现，部分特别异常的离群点导致箱型图自身被压缩的很扁，而我们一般更关注箱型图本身。因此，我们需要&lt;strong&gt;在不影响箱型图自身的分布的同时去除这些离群点&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="箱型图" scheme="https://tding.top/tags/%E7%AE%B1%E5%9E%8B%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>VPS上自建临时邮箱</title>
    <link href="https://tding.top/archives/73a8979d.html"/>
    <id>https://tding.top/archives/73a8979d.html</id>
    <published>2019-12-11T15:55:00.000Z</published>
    <updated>2019-12-11T16:04:30.278Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>当我们不想使用自己的真实邮箱，或者想批量注册账号的时候，就可以用<strong>临时搭建的即用即毁的邮箱系统</strong>。当我们通过IP或者域名访问这个临时邮箱系统时，系统会自动分配随机邮箱，收到新邮件后页面会自动刷新，页面关闭后邮件即丢失。</p><p>本文介绍的临时邮箱是<a href="https://github.com/denghongcai/forsaken-mail" rel="external nofollow noopener noreferrer" target="_blank">Forsaken Mail</a>，使用的是node.js。</p><a id="more"></a><h2 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h2><ul><li>系统版本：Ubuntu 16.04</li></ul><p>nodejs官方推荐安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p>确认nodejs版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h2 id="安装Forsaken-Mail"><a href="#安装Forsaken-Mail" class="headerlink" title="安装Forsaken Mail"></a>安装Forsaken Mail</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>从GitHub下载Forsaken Mail源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/malaohu/forsaken-mail/archive/master.zip</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><p>下面我们用npm安装Forsaken Mail：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> forsaken-mail-master</span><br><span class="line">npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure><p>如果没有报错，服务器已经开启了。我们可以访问<code>VPS IP:3000</code>，看看是否正常工作。</p><h3 id="Forsaken-Mail在后台运行"><a href="#Forsaken-Mail在后台运行" class="headerlink" title="Forsaken Mail在后台运行"></a>Forsaken Mail在后台运行</h3><p>当我们关闭ssh窗口后，终端会收到 HUP（hangup）信号从而关闭其所有子进程，导致nodejs进程被关闭。下面我使用screen让nodejs在后台运行：</p><ol><li>启动一个名字为<code>mail</code>的screen：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S mail</span><br></pre></td></tr></table></figure><ol start="2"><li>启动Forsaken Mail</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><ol start="3"><li>回到前一个screen，当时在当前screen运行的程序不会停止</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + a + d</span><br></pre></td></tr></table></figure><ol start="4"><li>列出所有的screen</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure><ol start="5"><li>回到我们建的名为mail的screen</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r mail</span><br></pre></td></tr></table></figure><p>screen的使用教程可以看：</p><ul><li><a href="https://tding.top/archives/97c310a3.html">Linux screen 使用技巧</a></li></ul><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>除了通过IP地址访问，还可以自定义邮箱域名，我们只需要在域名服务商的域名设置里面添加以下两条域名解析记录即可：</p><ul><li>添加MX记录：MX记录指向到自定义二级域名<code>mail.tding.top.</code>，其中主机记录设置为<code>@</code>，优先级设置10</li><li>添加A记录：A记录指向到服务器ip地址，其中主机记录设置为<code>mail</code></li></ul><p>域名解析设置见下图：</p><img src="/archives/73a8979d/域名解析.png" title="域名解析"><p>说明：<strong>MX记录的记录值的最后有一个点</strong>，代表主机名结束。在有些域名服务商网站设置的时候不会自动帮您加上，如果漏掉的话 DNS 服务器在解析的时候，会自动并上你的域名，这样会引起解析错误。</p><p>这样，我们可以通过<code>http://自定义域名:3000/</code>来访问临时邮箱了。</p><blockquote><p><strong>最后，欢迎大家用我搭建的临时邮箱来测试：<a href="http://mail.tding.top:3000" rel="external nofollow noopener noreferrer" target="_blank">邮箱地址</a></strong></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;当我们不想使用自己的真实邮箱，或者想批量注册账号的时候，就可以用&lt;strong&gt;临时搭建的即用即毁的邮箱系统&lt;/strong&gt;。当我们通过IP或者域名访问这个临时邮箱系统时，系统会自动分配随机邮箱，收到新邮件后页面会自动刷新，页面关闭后邮件即丢失。&lt;/p&gt;&lt;p&gt;本文介绍的临时邮箱是&lt;a href=&quot;https://github.com/denghongcai/forsaken-mail&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Forsaken Mail&lt;/a&gt;，使用的是node.js。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="软件" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="VPS" scheme="https://tding.top/tags/VPS/"/>
    
      <category term="临时邮箱" scheme="https://tding.top/tags/%E4%B8%B4%E6%97%B6%E9%82%AE%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的KMS服务器激活Windows&amp;Office</title>
    <link href="https://tding.top/archives/1df8b972.html"/>
    <id>https://tding.top/archives/1df8b972.html</id>
    <published>2019-12-10T15:37:00.000Z</published>
    <updated>2019-12-11T16:04:12.873Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>KMS全称Key Management Service ，这个功能是在Windows Vista之后的产品中的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。</p><p>我们知道，Windows XP和Server 2003要想避开激活机制的最好办法就是去下载VOL版或者MSDN的操作系统，只要输入正确的序列号，甚至有的根本不需要序列号，安装完以后也根本不用激活，并且只要运行一个脚本程序，一个免费的正版Windows就诞生了。为什么我们能这么容易的下载到MSDN或VOL版的XP和2003？其实Windows XP系列系统的MSDN版是Microsoft内部使用的系统，而VOL版是企业版，所以都不需要激活。然而这些版本最终被泄露，导致XP的盗版风无法停住，即使WGA也无能为力。但是从Windows Vista之后，Microsoft已吸取了这个教训，取消了Windows Vista及之后版本的VOL版，取而代之提供给批量激活的是利用KMS机制的Windows VL版本，遏制了不经微软激活服务器就进行激活的非法授权(盗版)行为。</p><p>由于Windows VL都是为批量激活而诞生，所以在一个激活单位中肯定会有很多台配置相等的计算机，并用一个服务器建立起一个局域网（LAN），而KMS正好利用这一点，它要求局域网中必须有一台KMS服务器，KMS服务器的作用是给局域网中的所有计算机的操作系统定周期(一般是180天)提供一个随机的激活ID(不同于产品激活密钥)，然后计算机里面的KMS服务就会自动将系统激活，实现正常的系统软件服务与操作。所以计算机必须保持与KMS服务器的定期连接，以便KMS激活服务的自动检查实现激活的自动续期，这样就实现了限制于公司域内的激活范围，避免了对于外界计算机的非法授权，当非法激活者离开公司域后，由于客户端KMS服务不能连接位于域内的KMS激活服务器，让它提供一个新的序列号，超过180天以后就会因为激活ID过期而重新回到试用版本状态，而合法授权者则能够定期获得ID更新，保持一直正确的激活状态。</p><a id="more"></a><h2 id="VPS安装KMS服务器"><a href="#VPS安装KMS服务器" class="headerlink" title="VPS安装KMS服务器"></a>VPS安装KMS服务器</h2><p>这里，我使用秋水逸冰开发的适用于三大 Linux 发行版的一键安装 KMS 服务的脚本在VPS上安装KMS服务器。</p><h3 id="本脚本适用环境"><a href="#本脚本适用环境" class="headerlink" title="本脚本适用环境"></a>本脚本适用环境</h3><ul><li>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+</li><li>虚拟技术：任意</li><li>内存要求：≥128M</li></ul><h3 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h3><ol><li>本脚本适用于三大 Linux 发行版，其他版本则不支持。</li><li>KMS 服务安装完成后会加入开机自启动。</li><li>默认记录日志，其日志位于 <code>/var/log/vlmcsd.log</code>。</li></ol><h3 id="一键脚本安装方法"><a href="#一键脚本安装方法" class="headerlink" title="一键脚本安装方法"></a>一键脚本安装方法</h3><p>使用root用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/kms.sh &amp;&amp; chmod +x kms.sh &amp;&amp; ./kms.sh</span><br></pre></td></tr></table></figure><p>安装完成后，输入以下命令查看端口号 1688 的监听情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nxtlp | grep 1688</span><br></pre></td></tr></table></figure><p>返回值类似于如下这样就表示OK了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp        0      0 0.0.0.0:1688                0.0.0.0:*                   LISTEN      3200/vlmcsd         </span><br><span class="line">tcp        0      0 :::1688                     :::*                        LISTEN      3200/vlmcsd</span><br></pre></td></tr></table></figure><h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><ul><li>启动：<code>/etc/init.d/kms start</code></li><li>停止：<code>/etc/init.d/kms stop</code></li><li>重启：<code>/etc/init.d/kms restart</code></li><li>状态：<code>/etc/init.d/kms status</code></li></ul><h3 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h3><p>使用 root 用户登录，进入到<code>kms.sh</code>所在的目录下，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kms.sh uninstall</span><br></pre></td></tr></table></figure><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><h3 id="激活Windows"><a href="#激活Windows" class="headerlink" title="激活Windows"></a>激活Windows</h3><p>KMS 激活服务只能激活批量授权版 Windows (VOL 版)，无法激活零售版 Windows (Retail 版)。</p><p>以 Windows 10 Pro 为例 想要激活 VOL 版 Windows 10 pro，只需要用<strong>管理员权限</strong>打开一个 cmd，然后依次执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slmgr -upk</span><br><span class="line">slmgr -ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr -skms IP:PORT</span><br><span class="line">slmgr -ato</span><br><span class="line">slmgr -dlv</span><br></pre></td></tr></table></figure><p>激活 Windows 8、Windows 7类似，只需要把上面的 KEY 替换一下即可。</p><p>注意：VOL 版本的镜像一般内置 GVLK key，用于 KMS 激活。如果你手动输过其他 key，那么这个内置的 key 就会被替换掉，这个时候如果你想用 KMS，那么就需要把 GVLK key 输回去。具体的KEY见后面的附录。</p><p>如果不知道自己的系统是什么版本，可以运行以下命令查看系统版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic os get caption</span><br></pre></td></tr></table></figure><p>我们得到对应key之后，使用管理员权限运行cmd执行安装key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr -ipk xxxxx-xxxxx-xxxxx-xxxxx</span><br></pre></td></tr></table></figure><h3 id="激活Office"><a href="#激活Office" class="headerlink" title="激活Office"></a>激活Office</h3><p>KMS 激活服务只能激活 VOL 版的 Office，不过零售版的 Office 可以通过脚本转换为 VOL 版。</p><p>如果不知道自己安装的是什么版本的 Office，可以使用这个方法查看：</p><blockquote><p><strong>判断你安装的 Office 是哪个版本</strong>：</p><p>以<strong>管理员权限</strong>打开一个 cmd，<strong>进入Office的安装目录</strong>，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cscript ospp.vbs /dstatus</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果输出的信息中包含下面这句话说明你安装的是零售版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LICENSE DESCRIPTION: Office 15, RETAIL(Grace) channel</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果输出的信息中包含下面这句话说明你安装的是批量授权版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LICENSE DESCRIPTION: Office 15, VOLUME_KMSCLIENT channel</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>激活 Office 的关键在于找到 <code>ospp.vbs</code> 这个文件。<code>ospp.vbs</code> 一般在 Office 的安装目录里。 Office 2016 的默认安装目录是：<code>C:\Program Files\Microsoft Office\Office16</code>。 以<strong>管理员权限</strong>打开一个cmd，然后执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"C:\Program Files\Microsoft Office\Office16"</span></span><br></pre></td></tr></table></figure><p>如果你系统是 64 位的但 Office 安装的是 32 位的，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"C:\Program Files (x86)\Microsoft Office\Office16"</span></span><br></pre></td></tr></table></figure><p>这样我们就进入到Office的安装目录，然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cscript ospp.vbs /sethst:IP:PORT</span><br><span class="line">cscript ospp.vbs /act</span><br></pre></td></tr></table></figure><h2 id="附录-Office-Visio-Project下载"><a href="#附录-Office-Visio-Project下载" class="headerlink" title="附录-Office_Visio_Project下载"></a>附录-Office_Visio_Project下载</h2><blockquote><p>下载地址：链接: <a href="https://pan.baidu.com/s/1i6Tx4DB" rel="external nofollow noopener noreferrer" target="_blank">https://pan.baidu.com/s/1i6Tx4DB</a> 密码: 5t1i</p></blockquote><p>本光盘集成了以下程序：</p><ul><li>Microsoft Office 专业增强版 2016 （简体中文）</li><li>Microsoft Project Professional 2016 （简体中文）</li><li>Microsoft Visio 专业版 2016 （简体中文）</li></ul><p>以上程序均为VL版本。</p><p>下载后务必校验镜像hash，否则可能会造成你的安装出错：</p><p>64位版本：<a href="mailto:`X64_OVP@03K.OR" rel="external nofollow noopener noreferrer" target="_blank">`X64_OVP@03K.OR</a>G_17.11.iso`</p><ul><li>大小：3.03 GB</li><li>CRC-32: e86507f9</li><li>MD4: 7f920801005b2fbca6bc3eee9518cac4</li><li>MD5: a5b85d589a949b4d0e419424d14e1be2</li><li>SHA-1: 8e991e451fcc4c31c1515cd2c5470bfaf2380317</li></ul><p>32位版本：<a href="mailto:`X86_OVP@03K.OR" rel="external nofollow noopener noreferrer" target="_blank">`X86_OVP@03K.OR</a>G_17.11.iso`</p><ul><li>大小：1.54 GB</li><li>CRC-32: 4ed2dadd</li><li>MD4: 9d74cc7dc2cd4363b30a4390d884eca4</li><li>MD5: f1bee496870a071692b231418f55848e</li><li>SHA-1: 3167a81e2fb16262bd10506d234e40ab494fd970</li></ul><blockquote><p>Hash校验插件：</p><ul><li><a href="http://implbits.com/products/hashtab/" rel="external nofollow noopener noreferrer" target="_blank">HashTab</a></li><li><a href="http://code.kliu.org/hashcheck/" rel="external nofollow noopener noreferrer" target="_blank">HashCheck Shell Extension</a></li></ul><p>这两款插件安装即可使用，只需要选中一个或多个文件，然后右键查看属性，其中就会有“Hashtab”、“文件校验”标签，非常方便。</p></blockquote><h2 id="附录-KEY"><a href="#附录-KEY" class="headerlink" title="附录-KEY"></a>附录-KEY</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="Windows-10-版本-1803"><a href="#Windows-10-版本-1803" class="headerlink" title="Windows 10 版本 1803"></a>Windows 10 版本 1803</h4><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Windows 10 教育版</td><td>NW6C2-QMPVW-D7KKK-3GKT6-VCFB2</td></tr><tr><td>Windows 10 教育版 N</td><td>2WH4N-8QGBV-H22JP-CT43Q-MDWWJ</td></tr><tr><td>Windows 10 企业版</td><td>NPPR9-FWDCX-D2C8J-H872K-2YT43</td></tr><tr><td>Windows 10 企业版 G</td><td>YYVX9-NTFWV-6MDM3-9PT4T-4M68B</td></tr><tr><td>Windows 10 企业版 G N</td><td>44RPN-FTY23-9VTTB-MP9BX-T84FV</td></tr><tr><td>Windows 10 企业版 N</td><td>DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4</td></tr><tr><td>Windows 10 专业版</td><td>W269N-WFGWX-YVC9B-4J6C9-T83GX</td></tr><tr><td>Windows 10 专业教育版</td><td>6TP4R-GNPTD-KYYHQ-7B7DP-J447Y</td></tr><tr><td>Windows 10 专业教育版 N</td><td>YVWGF-BXNMC-HTQYQ-CPQ99-66QFC</td></tr><tr><td>Windows 10 专业版 N</td><td>MH37W-N47XK-V7XM9-C7227-GCQG9</td></tr><tr><td>Windows 10 Professional Workstation</td><td>NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J</td></tr><tr><td>Windows 10 Professional Workstation N</td><td>9FNHH-K3HBT-3W4TD-6383H-6XYWF</td></tr></tbody></table><h4 id="Windows-10-版本-1709"><a href="#Windows-10-版本-1709" class="headerlink" title="Windows 10 版本 1709"></a>Windows 10 版本 1709</h4><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Windows 10 Professional Workstation</td><td>NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J</td></tr><tr><td>Windows 10 Professional Workstation N</td><td>9FNHH-K3HBT-3W4TD-6383H-6XYWF</td></tr></tbody></table><h4 id="Windows-10"><a href="#Windows-10" class="headerlink" title="Windows 10"></a>Windows 10</h4><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Windows 10 专业版</td><td>W269N-WFGWX-YVC9B-4J6C9-T83GX</td></tr><tr><td>Windows 10 专业版 N</td><td>MH37W-N47XK-V7XM9-C7227-GCQG9</td></tr><tr><td>Windows 10 企业版</td><td>NPPR9-FWDCX-D2C8J-H872K-2YT43</td></tr><tr><td>Windows 10 企业版 N</td><td>DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4</td></tr><tr><td>Windows 10 教育版</td><td>NW6C2-QMPVW-D7KKK-3GKT6-VCFB2</td></tr><tr><td>Windows 10 教育版 N</td><td>2WH4N-8QGBV-H22JP-CT43Q-MDWWJ</td></tr><tr><td>Windows 10 企业版 2015 长期服务</td><td>WNMTR-4C88C-JK8YV-HQ7T2-76DF9</td></tr><tr><td>Windows 10 企业版 2015 长期服务 N</td><td>2F77B-TNFGY-69QQF-B8YKP-D69TJ</td></tr><tr><td>Windows 10 企业版 2016 长期服务</td><td>DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ</td></tr><tr><td>Windows 10 企业版 2016 长期服务 N</td><td>QFFDN-GRT3P-VKWWX-X7T3R-8B639</td></tr></tbody></table><h4 id="Windows-7-和-Windows-Server-2008-R2"><a href="#Windows-7-和-Windows-Server-2008-R2" class="headerlink" title="Windows 7 和 Windows Server 2008 R2"></a>Windows 7 和 Windows Server 2008 R2</h4><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Windows 7 专业版</td><td>FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4</td></tr><tr><td>Windows 7 专业版 N</td><td>MRPKT-YTG23-K7D7T-X2JMM-QY7MG</td></tr><tr><td>Windows 7 专业版 E</td><td>W82YF-2Q76Y-63HXB-FGJG9-GF7QX</td></tr><tr><td>Windows7 企业版</td><td>33PXH-7Y6KF-2VJC9-XBBR8-HVTHH</td></tr><tr><td>Windows 7 企业版 N</td><td>YDRBP-3D83W-TY26F-D46B2-XCKRJ</td></tr><tr><td>Windows 7 企业版 E</td><td>C29WB-22CC8-VJ326-GHFJW-H9DH4</td></tr><tr><td>Windows Server 2008 R2 Web 版</td><td>6TPJF-RBVHG-WBW2R-86QPH-6RTM4</td></tr><tr><td>Windows Server 2008 R2 HPC 版</td><td>TT8MH-CG224-D3D7Q-498W2-9QCTX</td></tr><tr><td>WindowsServer 2008 R2 Standard</td><td>YC6KT-GKW9T-YTKYR-T4X34-R7VHC</td></tr><tr><td>WindowsServer 2008 R2 企业版</td><td>489J6-VHDMP-X63PK-3K798-CPX3Y</td></tr><tr><td>WindowsServer 2008 R2 Datacenter</td><td>74YFP-3QFB3-KQT8W-PMXWJ-7M648</td></tr><tr><td>面向基于 Itanium 系统的 Windows Server 2008 R2</td><td>GT63C-RJFQ3-4GMB6-BRFB9-CB83V</td></tr></tbody></table><h3 id="Office"><a href="#Office" class="headerlink" title="Office"></a>Office</h3><h4 id="Office-2016"><a href="#Office-2016" class="headerlink" title="Office 2016"></a>Office 2016</h4><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Office Professional Plus 2016</td><td>XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99</td></tr><tr><td>Office Standard 2016</td><td>JNRGM-WHDWX-FJJG3-K47QV-DRTFM</td></tr><tr><td>Project Professional 2016</td><td>YG9NW-3K39V-2T3HJ-93F3Q-G83KT</td></tr><tr><td>Project Standard 2016</td><td>GNFHQ-F6YQM-KQDGJ-327XX-KQBVC</td></tr><tr><td>Visio Professional 2016</td><td>PD3PC-RHNGV-FXJ29-8JK7D-RJRJK</td></tr><tr><td>Visio Standard 2016</td><td>7WHWN-4T7MP-G96JF-G33KR-W8GF4</td></tr><tr><td>Access 2016</td><td>GNH9Y-D2J4T-FJHGG-QRVH7-QPFDW</td></tr><tr><td>Excel 2016</td><td>9C2PK-NWTVB-JMPW8-BFT28-7FTBF</td></tr><tr><td>OneNote 2016</td><td>DR92N-9HTF2-97XKM-XW2WJ-XW3J6</td></tr><tr><td>Outlook 2016</td><td>R69KK-NTPKF-7M3Q4-QYBHW-6MT9B</td></tr><tr><td>PowerPoint 2016</td><td>J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6</td></tr><tr><td>Publisher 2016</td><td>F47MM-N3XJP-TQXJ9-BP99D-8837K</td></tr><tr><td>Skype for Business 2016</td><td>869NQ-FJ69K-466HW-QYCP2-DDBV6</td></tr><tr><td>Word 2016</td><td>WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6</td></tr></tbody></table><h4 id="Office-2013"><a href="#Office-2013" class="headerlink" title="Office 2013"></a>Office 2013</h4><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Office 2013 Professional Plus</td><td>YC7DK-G2NP3-2QQC3-J6H88-GVGXT</td></tr><tr><td>Office 2013 Standard</td><td>KBKQT-2NMXY-JJWGP-M62JB-92CD4</td></tr><tr><td>Project 2013 Professional</td><td>FN8TT-7WMH6-2D4X9-M337T-2342K</td></tr><tr><td>Project 2013 Standard</td><td>6NTH3-CW976-3G3Y2-JK3TX-8QHTT</td></tr><tr><td>Visio 2013 Professional</td><td>C2FG9-N6J68-H8BTJ-BW3QX-RM3B3</td></tr><tr><td>Visio 2013 Standard</td><td>J484Y-4NKBF-W2HMG-DBMJC-PGWR7</td></tr><tr><td>Access 2013</td><td>NG2JY-H4JBT-HQXYP-78QH9-4JM2D</td></tr><tr><td>Excel 2013</td><td>VGPNG-Y7HQW-9RHP7-TKPV3-BG7GB</td></tr><tr><td>InfoPath 2013</td><td>DKT8B-N7VXH-D963P-Q4PHY-F8894</td></tr><tr><td>Lync 2013</td><td>2MG3G-3BNTT-3MFW9-KDQW3-TCK7R</td></tr><tr><td>OneNote 2013</td><td>TGN6P-8MMBC-37P2F-XHXXK-P34VW</td></tr><tr><td>Outlook 2013</td><td>QPN8Q-BJBTJ-334K3-93TGY-2PMBT</td></tr><tr><td>PowerPoint 2013</td><td>4NT99-8RJFH-Q2VDH-KYG2C-4RD4F</td></tr><tr><td>Publisher 2013</td><td>PN2WF-29XG2-T9HJ7-JQPJR-FCXK4</td></tr><tr><td>Word 2013</td><td>6Q7VD-NX8JD-WJ2VH-88V73-4GBJ7</td></tr></tbody></table><h4 id="Office-2010"><a href="#Office-2010" class="headerlink" title="Office 2010"></a>Office 2010</h4><p>Office 套件：</p><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Office Professional Plus 2010</td><td>VYBBJ-TRJPB-QFQRF-QFT4D-H3GVB</td></tr><tr><td>Office Standard 2010</td><td>V7QKV-4XVVR-XYV4D-F7DFM-8R6BM</td></tr><tr><td>Office Home and Business 2010</td><td>D6QFG-VBYP2-XQHM7-J97RH-VVRCK</td></tr></tbody></table><p>独立产品：</p><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Access 2010</td><td>V7Y44-9T38C-R2VJK-666HK-T7DDX</td></tr><tr><td>Excel 2010</td><td>H62QG-HXVKF-PP4HP-66KMR-CW9BM</td></tr><tr><td>SharePoint Workspace 2010</td><td>QYYW6-QP4CB-MBV6G-HYMCJ-4T3J4</td></tr><tr><td>InfoPath 2010</td><td>K96W8-67RPQ-62T9Y-J8FQJ-BT37T</td></tr><tr><td>OneNote 2010</td><td>Q4Y4M-RHWJM-PY37F-MTKWH-D3XHX</td></tr><tr><td>Outlook 2010</td><td>7YDC2-CWM8M-RRTJC-8MDVC-X3DWQ</td></tr><tr><td>PowerPoint 2010</td><td>RC8FX-88JRY-3PF7C-X8P67-P4VTT</td></tr><tr><td>Project Professional 2010</td><td>YGX6F-PGV49-PGW3J-9BTGG-VHKC6</td></tr><tr><td>Project Standard 2010</td><td>4HP3K-88W3F-W2K3D-6677X-F9PGB</td></tr><tr><td>Publisher 2010</td><td>BFK7F-9MYHM-V68C7-DRQ66-83YTP</td></tr><tr><td>Word 2010</td><td>HVHB3-C6FV7-KQX9W-YQG79-CRY7T</td></tr></tbody></table><p>Visio：</p><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Visio Premium 2010</td><td>D9DWC-HPYVV-JGF4P-BTWQB-WX8BJ</td></tr><tr><td>Visio Professional 2010</td><td>7MCW8-VRQVK-G677T-PDJCM-Q8TCP</td></tr><tr><td>Visio Standard 2010</td><td>767HD-QGMWX-8QTDB-9G3R2-KHFGJ</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.keye.work/2018/07/24/kms.html" rel="external nofollow noopener noreferrer" target="_blank">KMS介绍</a></li><li><a href="https://mogeko.me/2018/017/" rel="external nofollow noopener noreferrer" target="_blank">本地搭建 KMS 激活服务</a></li><li><a href="https://teddysun.com/530.html" rel="external nofollow noopener noreferrer" target="_blank">一键安装KMS服务脚本</a></li><li><a href="https://03k.org/2016_ovp.html" rel="external nofollow noopener noreferrer" target="_blank">Office 2016_Visio_Project_VL多合一_集成补丁2017.11</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;KMS全称Key Management Service ，这个功能是在Windows Vista之后的产品中的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。&lt;/p&gt;&lt;p&gt;我们知道，Windows XP和Server 2003要想避开激活机制的最好办法就是去下载VOL版或者MSDN的操作系统，只要输入正确的序列号，甚至有的根本不需要序列号，安装完以后也根本不用激活，并且只要运行一个脚本程序，一个免费的正版Windows就诞生了。为什么我们能这么容易的下载到MSDN或VOL版的XP和2003？其实Windows XP系列系统的MSDN版是Microsoft内部使用的系统，而VOL版是企业版，所以都不需要激活。然而这些版本最终被泄露，导致XP的盗版风无法停住，即使WGA也无能为力。但是从Windows Vista之后，Microsoft已吸取了这个教训，取消了Windows Vista及之后版本的VOL版，取而代之提供给批量激活的是利用KMS机制的Windows VL版本，遏制了不经微软激活服务器就进行激活的非法授权(盗版)行为。&lt;/p&gt;&lt;p&gt;由于Windows VL都是为批量激活而诞生，所以在一个激活单位中肯定会有很多台配置相等的计算机，并用一个服务器建立起一个局域网（LAN），而KMS正好利用这一点，它要求局域网中必须有一台KMS服务器，KMS服务器的作用是给局域网中的所有计算机的操作系统定周期(一般是180天)提供一个随机的激活ID(不同于产品激活密钥)，然后计算机里面的KMS服务就会自动将系统激活，实现正常的系统软件服务与操作。所以计算机必须保持与KMS服务器的定期连接，以便KMS激活服务的自动检查实现激活的自动续期，这样就实现了限制于公司域内的激活范围，避免了对于外界计算机的非法授权，当非法激活者离开公司域后，由于客户端KMS服务不能连接位于域内的KMS激活服务器，让它提供一个新的序列号，超过180天以后就会因为激活ID过期而重新回到试用版本状态，而合法授权者则能够定期获得ID更新，保持一直正确的激活状态。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="软件" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Windows" scheme="https://tding.top/tags/Windows/"/>
    
      <category term="Office" scheme="https://tding.top/tags/Office/"/>
    
      <category term="KMS" scheme="https://tding.top/tags/KMS/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2的几何对象与统计变换</title>
    <link href="https://tding.top/archives/71d12648.html"/>
    <id>https://tding.top/archives/71d12648.html</id>
    <published>2019-12-10T04:30:00.000Z</published>
    <updated>2019-12-22T12:34:07.555Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><ul><li><strong>几何对象</strong>执行着图层的实际渲染，控制着生成的图像类型。<ul><li><code>geom_point()</code>将会生成散点图</li><li><code>geom_line()</code>将会生成折线图</li><li><code>geom_bar()</code>将会生成柱状图</li><li><code>geom_boxplot()</code>将会生成箱型图</li><li><code>geom_histogram()</code>将会生成直方图</li></ul></li><li><strong>统计变换</strong>通常以某种方式对数据信息进行汇总。<ul><li><code>stat_smooth()</code>添加光滑曲线</li></ul></li></ul><a id="more"></a><p><strong>任何一个ggplot2图层都包括stat和geom两部分，<code>stat_</code>和<code>geom_</code>是两种绘图方法这个说法是不对的</strong>，下面我们简单解释下。</p><p>举个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>)) </span><br><span class="line">y &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">p &lt;- ggplot(data= <span class="literal">NULL</span>, aes(x = x, y = y))</span><br><span class="line">p &lt;- p + geom_point(color = <span class="string">"darkred"</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/几何对象-1.png" title="几何对象-1"><p>我们查看码源会发现<code>geom_point()</code>这个几何对象的默认stat是<code>identity</code>，即不做任何统计变换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function (mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, </span><br><span class="line">    ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </span><br><span class="line">&#123;</span><br><span class="line">    layer(data = data, mapping = mapping, stat = stat, geom = GeomPoint, </span><br><span class="line">        position = position, show.legend = show.legend, inherit.aes = inherit.aes, </span><br><span class="line">        params = list(na.rm = na.rm, ...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码我们可以发现，坐标<code>(20，20)</code>这个点的数据事实上有20个，但由于没做<strong>统计转换</strong>，<code>(20,20)</code>这个点被画了20次，因此我们看到的点其实是最后一次画的那个点。</p><p>因此，下面我们<strong>按照某一点出现的频率换算成大小</strong>（指定<code>stat = &quot;sum&quot;</code>）来作图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>)) </span><br><span class="line">y &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">p &lt;- ggplot(data= <span class="literal">NULL</span>, aes(x = x, y = y))</span><br><span class="line">p &lt;- p + geom_point(color = <span class="string">"darkred"</span>,stat = <span class="string">"sum"</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/几何对象-2.png" title="几何对象-2"><p>根据以上，我们可以发现一个单纯的<code>geom_point</code>里面也是带有<code>stat_</code>的，同样，我们也可以用<code>stat_sum</code>作为主函数来绘制这幅图，里面有参数<code>geom</code>，这里我们设置成<code>geom = “point”</code>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>)) </span><br><span class="line">y &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">p &lt;- ggplot(data= <span class="literal">NULL</span>, aes(x = x, y = y))</span><br><span class="line">p &lt;- p + stat_sum(color = <span class="string">"darkred"</span>,geom = <span class="string">"point"</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><p>画出来的图跟前面用<code>geom_point</code>函数是一样的。</p><p>因此，<strong>我们需要认识到<code>stat_</code>和<code>geom_</code>是两种绘图方法这个说法是不对的，其实它们是ggplot2每一个图层绘制都必须有的，是一个图层的一体两面</strong>。</p><p>下面简单介绍几个常用的绘图函数。</p><h2 id="geom-point-散点图"><a href="#geom-point-散点图" class="headerlink" title="geom_point()散点图"></a><code>geom_point()</code>散点图</h2><p>绘制散点图可以使用<code>geom_point()</code>函数，气泡图（bubble chart）也是一个散点图，只不过点的大小由一个变量（size）来控制。</p><p>散点图潜在的最大问题是过度绘图：当一个位置或相邻的位置上出现有多个点，就可能把点绘制在彼此之上，这会严重扭曲散点图的视觉外观，我们可以通过使点变得透明或者设置点的形状来解决该问题。</p><p><code>geom_point()</code>参数如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geom_point(mapping = <span class="literal">NULL</span>, data = <span class="literal">NULL</span>, stat = <span class="string">"identity"</span>, position = <span class="string">"identity"</span>, <span class="keyword">...</span>, na.rm = <span class="literal">FALSE</span>, show.legend = <span class="literal">NA</span>, inherit.aes = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>这里我从数据集中随机选出了100个样本，作为一个小数据集：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让样本可重复</span></span><br><span class="line">set.seed(<span class="number">1410</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始数据的一个容量为100的随机样本</span></span><br><span class="line">dsmall &lt;- diamonds[sample(nrow(diamonds),<span class="number">100</span>),]</span><br></pre></td></tr></table></figure><p>下面是散点图的绘制：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = dsmall, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point(aes(color = color, size = cut), shape = <span class="number">19</span>, alpha = <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/散点图.png" title="散点图"><h2 id="geom-bar-柱状图"><a href="#geom-bar-柱状图" class="headerlink" title="geom_bar()柱状图"></a><code>geom_bar()</code>柱状图</h2><h3 id="离散单变量的柱状图"><a href="#离散单变量的柱状图" class="headerlink" title="离散单变量的柱状图"></a>离散单变量的柱状图</h3><p>明细数据集绘制柱状图-左图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = cut))</span><br><span class="line">p &lt;- p + geom_bar()</span><br></pre></td></tr></table></figure><p><code>geom_bar()</code>函数中的<code>stat</code>参数的默认值为<code>stat = &#39;count&#39;</code>，即观测数量，统计的是每个离散变量出现的频次。</p><p>汇总好的数据集绘制柱状图-右图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = cut, y = price))</span><br><span class="line">p &lt;- p + geom_bar(stat = <span class="string">"identity"</span>)</span><br></pre></td></tr></table></figure><p>我们只需要在<code>geom_bar()</code>中更改默认的<code>count</code>为<code>identity</code>就可以接受两个变量作图。</p><img src="/archives/71d12648/柱状图-离散单变量.png" title="柱状图-离散单变量"><h3 id="分组柱状图"><a href="#分组柱状图" class="headerlink" title="分组柱状图"></a>分组柱状图</h3><p>分组柱状图一共有三种展现形式，我们可以使用<code>position</code>参数调整：</p><ul><li>并排放置<code>position=&quot;dodge&quot;</code></li><li>堆叠<code>position=&quot;stack&quot;</code></li><li>填充比例<code>position=&quot;fill&quot;</code></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = cut,fill = color))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并排放置-左图</span></span><br><span class="line">p + geom_bar(position = <span class="string">"dodge"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠-中图</span></span><br><span class="line">p + geom_bar(position = <span class="string">"stack"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充比例-右图</span></span><br><span class="line">p + geom_bar(position = <span class="string">"fill"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/柱状图-分组柱状图.png" title="柱状图-分组柱状图"><h3 id="柱状图排序"><a href="#柱状图排序" class="headerlink" title="柱状图排序"></a>柱状图排序</h3><p>其实前面我们在画柱状图时，使用的变量并不规范，当横坐标是离散型变量时，<strong>x参数接的应该是一个因子型数据（factor）</strong>。</p><p>当x没有用因子型数据的时候，横轴可能会没有把所有的标签全标上，这表示把横轴当成连续性变量来看了，所以只标了一部分标签以表示大小关系。</p><p>同样的，fill也是作为离散分类变量，也应该接一个factor，我们可以看到不加时，图例是一个连续性渐变颜色的形式。</p><p>我们会发现，转化为因子型之后数据的排列方式，不是根据元素出现的前后顺序，而是<strong>按照首字母顺序</strong>。现在我们想让<strong>x轴按y轴数值大小排序</strong>。</p><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>我们可以自定义一个函数来实现柱子从高到低排列：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因子型数据，按照首字母排序-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = factor(cut)))</span><br><span class="line">p &lt;- p + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line">reorder_size &lt;- <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  factor(x, levels = names(sort(table(x), decreasing = <span class="literal">TRUE</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从高到低排序-右图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = reorder_size(cut)))</span><br><span class="line">p &lt;- p + geom_bar()</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/柱状图-排序.png" title="柱状图-排序"><h4 id="reorder-函数"><a href="#reorder-函数" class="headerlink" title="reorder()函数"></a>reorder()函数</h4><p><code>reorder()</code>函数用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reorder(x, X, FUN = mean, <span class="keyword">...</span>, order = is.ordered(x))</span><br></pre></td></tr></table></figure><ul><li><code>x</code>：因子型向量</li><li><code>X</code>：用来排序的数值型向量</li><li><code>FUN</code>：汇总数据的函数</li><li><code>...</code>：<code>FUN</code>的参数（可选）</li><li><code>order</code>：我们可以通过这个参数直接指定因子型向量的顺序</li></ul><p>按照x对X进行分组，对每一组组成的向量计算后面的函数，最后根据计算结果从小到大指定x中元素的顺序。</p><p>下面是<code>reorder()</code>实现柱子从高到低排列，结果和前面自定义函数是一样的：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(reorder(cut,rep(<span class="number">1</span>,length(cut)),sum)))</span><br><span class="line">p &lt;- p + geom_bar()</span><br></pre></td></tr></table></figure><p>我们可以根据cut对一个全是1的向量分组求和（相当于计算了cut中每一个元素出现的个数），再根据求和结果指定顺序。</p><h3 id="柱状图添加标签文字"><a href="#柱状图添加标签文字" class="headerlink" title="柱状图添加标签文字"></a>柱状图添加标签文字</h3><p>我们可以使用<code>geom_text()</code>为柱状图添加文本，显示柱状图的高度，并调整文本的位置和大小。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = factor(cut),fill = color))</span><br><span class="line">p &lt;- p + geom_bar(position = <span class="string">"fill"</span>)</span><br><span class="line">p &lt;- p + geom_text(stat = <span class="string">"count"</span>,mapping = aes(label = ..count..), size = <span class="number">5</span>, colour = <span class="string">'white'</span>, vjust = <span class="number">1</span>, hjust = <span class="number">.5</span>, position = position_fill(<span class="number">0.9</span>))</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/柱状图-标签文字.png" title="柱状图-标签文字"><ul><li>label设置<ul><li>当<code>stat=&quot;count&quot;</code>时，设置文本的标签需要使用一个特殊的变量 <code>aes(label=..count..)</code>， 表示的是变量值的数量</li><li>当<code>stat=&quot;identity&quot;</code>时，设置文本的标签需要设置y轴的值，<code>aes(label=price)</code>，表示的变量的值</li></ul></li><li>size设置：标签字体大小，默认值为5号</li><li>color设置：标签文字的颜色</li><li>vjust设置：调整标签位置，1为分界线，越大于1，标签越在柱状图上界下方，反之则越在柱状图上界上方</li><li>hjust设置：<code>hjust = 0.5</code>将标签水平居中放置</li><li>position设置：这里的图形位置与标签位置摆放必须一致，即图形位置<code>geom_bar()</code>函数设置为<code>position = &#39;fill&#39;</code>，那么标签位置<code>geom_text()</code>函数设置为<code>position = position_fill(0.9)</code>参数</li></ul><h3 id="正负柱状图"><a href="#正负柱状图" class="headerlink" title="正负柱状图"></a>正负柱状图</h3><p>只要数据是负数，就能画出往下方的柱状图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d &lt;- data.frame(a=letters[<span class="number">1</span>:<span class="number">7</span>], b=c(<span class="number">4</span>,-<span class="number">6</span>,<span class="number">5</span>,-<span class="number">4</span>,-<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>))</span><br><span class="line">p &lt;- ggplot(d,aes(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左图</span></span><br><span class="line">p1 &lt;- p + geom_bar(stat=<span class="string">"identity"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右图</span></span><br><span class="line">p2 &lt;- p + geom_bar(aes(fill=factor((b&gt;<span class="number">0</span>)+<span class="number">1</span>)),stat=<span class="string">"identity"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/柱状图-正负柱状图.png" title="柱状图-正负柱状图"><h2 id="geom-boxplot-箱型图"><a href="#geom-boxplot-箱型图" class="headerlink" title="geom_boxplot()箱型图"></a><code>geom_boxplot()</code>箱型图</h2><p><code>geom_boxplot()</code>函数中有outlier开头的多个参数，用于修改离群点的属性：</p><ul><li><code>outlier.colour</code>：离群点的颜色</li><li><code>outlier.fill</code>：离群点的填充色</li><li><code>outlier.shape</code>：离群点的形状</li><li><code>outlier.size</code>：离群点的大小</li><li><code>outlier.alpha</code>：离群点的透明度</li></ul><p>箱形图可以用fill参数指定填充颜色，color参数指定边框颜色。</p><p>下面是一个示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = cut, y = price))</span><br><span class="line">p &lt;- p + geom_boxplot(fill = <span class="string">"white"</span>, color = <span class="string">"darkgreen"</span>, outlier.shape=<span class="number">21</span>, outlier.size=<span class="number">4</span>, outlier.stroke = <span class="number">1</span>, outlier.color = <span class="string">"gray"</span>, outlier.fill = <span class="string">"orange"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/箱型图.png" title="箱型图"><p>在添加有<strong>多分类变量</strong>时，箱线图默认使用的<code>position</code>参数是<code>dodge</code>，使用堆积方式<code>stack</code>、堆积百分比<code>fill</code>来呈现多维箱线图是会失败的。</p><h2 id="geom-histogram-直方图"><a href="#geom-histogram-直方图" class="headerlink" title="geom_histogram()直方图"></a><code>geom_histogram()</code>直方图</h2><p>直方图函数<code>geom_histogram()</code>与柱形图函数<code>geom_bar()</code>大致相同。</p><h3 id="直方图组距调整"><a href="#直方图组距调整" class="headerlink" title="直方图组距调整"></a>直方图组距调整</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认组距-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p + geom_histogram()</span><br><span class="line"></span><br><span class="line"><span class="comment"># binwidth参数控制直方图组距大小-右图</span></span><br><span class="line">p + geom_histogram(binwidth = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/直方图-组距调整.png" title="直方图-组距调整"><h3 id="分组直方图"><a href="#分组直方图" class="headerlink" title="分组直方图"></a>分组直方图</h3><p>直方图参数中添加颜色映射来区分不同组，这时默认直方图输出为堆积直方图。我们也可以通过设置position参数对多序列柱形进行簇状、堆积百分比转换。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price, fill = factor(cut)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认分组直方图（stack）-左上图</span></span><br><span class="line">p + geom_histogram()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不做任何转换（identity）-右上图</span></span><br><span class="line">p + geom_histogram(position = <span class="string">'identity'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 簇状分组柱状图（dodge）-左下图</span></span><br><span class="line">p + geom_histogram(position = <span class="string">'dodge'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠百分比分组柱状图（fill）-右下图</span></span><br><span class="line">p + geom_histogram(position = <span class="string">'fill'</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/直方图-分组直方图.png" title="直方图-分组直方图"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/24779017" rel="external nofollow noopener noreferrer" target="_blank">如何使用 ggplot2 ？</a></li><li><a href="https://zhuanlan.zhihu.com/p/27093478" rel="external nofollow noopener noreferrer" target="_blank">R|ggplot2(二)|覆盖柱状图各种需求</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;几何对象&lt;/strong&gt;执行着图层的实际渲染，控制着生成的图像类型。&lt;ul&gt;&lt;li&gt;&lt;code&gt;geom_point()&lt;/code&gt;将会生成散点图&lt;/li&gt;&lt;li&gt;&lt;code&gt;geom_line()&lt;/code&gt;将会生成折线图&lt;/li&gt;&lt;li&gt;&lt;code&gt;geom_bar()&lt;/code&gt;将会生成柱状图&lt;/li&gt;&lt;li&gt;&lt;code&gt;geom_boxplot()&lt;/code&gt;将会生成箱型图&lt;/li&gt;&lt;li&gt;&lt;code&gt;geom_histogram()&lt;/code&gt;将会生成直方图&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;统计变换&lt;/strong&gt;通常以某种方式对数据信息进行汇总。&lt;ul&gt;&lt;li&gt;&lt;code&gt;stat_smooth()&lt;/code&gt;添加光滑曲线&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2的标度</title>
    <link href="https://tding.top/archives/99c6f91.html"/>
    <id>https://tding.top/archives/99c6f91.html</id>
    <published>2019-12-08T15:30:00.000Z</published>
    <updated>2019-12-08T15:53:55.846Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>标度控制着<strong>数据到图形属性的映射</strong>，标度将我们的数据转化为视觉上可以感知的东西，如大小、颜色、位置和形状，所以通过标度可以修改坐标轴和图例的参数。</p><p>每一种图形属性都拥有一个默认的标度，此标度将在我们每次使用这个图形属性时被自动添加到图形中，这些标度列于下表中，默认属性粗体显示：</p><table><thead><tr><th>图形属性</th><th>离散型</th><th>连续型</th></tr></thead><tbody><tr><td>颜色和填充色</td><td>brewer grey <strong>hue</strong> identity manual</td><td><strong>gradient</strong> gradient2 gradientn</td></tr><tr><td>位置</td><td><strong>discrete</strong></td><td><strong>continuous</strong> date</td></tr><tr><td>形状</td><td><strong>shape</strong> identity manual</td><td></td></tr><tr><td>线条类型</td><td><strong>linetype</strong> identity manual</td><td></td></tr><tr><td>大小</td><td>identity manual</td><td><strong>size</strong></td></tr></tbody></table><p>如果要添加一个不同的标度或修改默认标度的某些特征，<strong>我们必须构建一个新的标度，然后使用<code>+</code>将其添加到图形上</strong>。所有的标度构建器（scale）都拥有一套通用的命名方案，它们以<code>scale_</code>开头，接下来是图形属性的名称（例如：<code>colour_</code>、<code>shape_</code>、<code>x_</code>）最后以标度的名称结尾（<code>gradient</code>、<code>hue</code>、<code>manual</code>）。</p><ul><li>离散图形的颜色属性采用默认标度：<code>scale_colour_hue()</code></li><li>离散图形的填充色属性采用ColorBrewer配色标度：<code>scale_fill_brewer()</code></li></ul><a id="more"></a><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认标度-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整标度的参数-右图</span></span><br><span class="line">p + scale_colour_hue(<span class="string">"cut"</span>,breaks=c(<span class="string">"Fair"</span>,<span class="string">"Good"</span>,<span class="string">"Very Good"</span>),labels=c(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-示例.png" title="标度-示例"><h2 id="标度系列函数"><a href="#标度系列函数" class="headerlink" title="标度系列函数"></a>标度系列函数</h2><p>标度系列函数可以粗略的分为4类：</p><ul><li><strong>位置标度</strong>：用于将连续型、离散型和日期-时间型变量映射到绘图区域，以及构造对应的坐标轴</li><li><strong>颜色标度</strong>：用于将连续型和离散型变量映射到颜色</li><li><strong>手动离散型标度</strong>：用于将离散型变量映射到我们选择的符号大小、线条类型、形状或颜色，以及创建对应的图例</li><li><strong>同一型标度</strong>：用于直接将变量值绘制为图形属性，而不去映射他们</li></ul><h3 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h3><p>上面这些标度系列函数都会有一些参数，这些就是通用参数，下面简单介绍一下这些通用参数。</p><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p><strong>name：设置坐标轴或图例上出现的标签</strong>。可以使用三个辅助函数<code>xlab()</code>、<code>ylab()</code>、<code>labs()</code>来减少代码。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认-左上</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加x标签-右上</span></span><br><span class="line">p + scale_x_continuous(<span class="string">"Diamonds carat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加x标签（使用xlab()这个辅助函数）</span></span><br><span class="line">p + xlab(<span class="string">"Diamonds carat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时添加x、y及colour标度-左下</span></span><br><span class="line">p + labs(x = <span class="string">"Diamonds carat"</span>, y = <span class="string">"Diamonds price"</span>, colour = <span class="string">"Diamond Cut"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加x标度为表达式-右下</span></span><br><span class="line">p + xlab(expression(frac(carat,<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-name.png" title="标度-name"><h4 id="limits"><a href="#limits" class="headerlink" title="limits"></a>limits</h4><p><strong>limits：固定标度的定义域</strong>。</p><ul><li>连续型标度接受一个长度为2的数值型向量</li><li>离散型标度接受一个字符型向量</li></ul><p>我们可以通过设定limits来移除不想在图形上展示的数据，<strong>任何不在此范围内的数据将会被丢弃</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定x轴的范围-左图</span></span><br><span class="line">p + scale_x_continuous(limits = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定colour的范围-右图</span></span><br><span class="line">p + scale_colour_hue(limits = <span class="string">"Fair"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-limits.png" title="标度-limits"><h4 id="breaks、labels"><a href="#breaks、labels" class="headerlink" title="breaks、labels"></a>breaks、labels</h4><ul><li>breaks表示在坐标轴/图例上哪些点的位置标标签</li><li>labels表示标什么标签，若设定labels，则必须同时指定breaks。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定x轴的坐标轴的值-左图</span></span><br><span class="line">p + scale_x_continuous(breaks = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定图例上的值-右图</span></span><br><span class="line">p + scale_colour_hue(breaks = <span class="string">"Fair"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-breaks.png" title="标度-breaks"><h3 id="位置标度"><a href="#位置标度" class="headerlink" title="位置标度"></a>位置标度</h3><p>每幅图都一定拥有两个位置标度，一个指定水平位置（x标度），另外一个指定竖直位置（y标度）。ggplot2提供了连续型、离散型（针对因子型、字符型和逻辑型向量）以及日期型标度。</p><h4 id="连续型位置标度"><a href="#连续型位置标度" class="headerlink" title="连续型位置标度"></a>连续型位置标度</h4><p>最常用的连续型位置标度是<code>scale_x_continuous</code>和<code>scale_y_continuous</code>，它们均将数据映射到x轴和y轴。而最有趣的变式是通过变换来生成的，每一个连续型标度都可以接受一个trans 参数，允许指定若干种线性或非线性的变换。</p><p>下面是支持的变换：</p><table><thead><tr><th>名称</th><th>变换函数$f(x)$</th><th>逆变换函数$f^{−1}(x)$</th></tr></thead><tbody><tr><td>asn</td><td>$tanh^{−1}(x)$</td><td>$tanh(y)$</td></tr><tr><td>exp</td><td>$e^x$</td><td>$log(y)$</td></tr><tr><td>identity</td><td>$x$</td><td>$y$</td></tr><tr><td>log</td><td>$log(x)$</td><td>$e^y$</td></tr><tr><td>log10</td><td>$log_{10}(x)$</td><td>$10^y$</td></tr><tr><td>log2</td><td>$log_2(x)$</td><td>$2^y$</td></tr><tr><td>logit</td><td>$log(\frac{x}{1−x})$</td><td>$\frac{1}{1+e(y)}$</td></tr><tr><td>pow10</td><td>$10^x$</td><td>$log_{10}(y)$</td></tr><tr><td>probit</td><td>$\phi(x)$</td><td>$\phi^{−1}(y)$</td></tr><tr><td>recip</td><td>$x^{−1}$</td><td>$y^{−1}$</td></tr><tr><td>reverse</td><td>$−x$</td><td>$−y$</td></tr><tr><td>sqrt</td><td>$x^{\frac{1}{2}}$</td><td>$y^2$</td></tr></tbody></table><p><strong>对于连续型位置标度，变换有简写形式</strong>，比如<code>scale_x_continuous(trans = “log10”)</code>可以简写为<code>scale_x_log10()</code>。参数trans对任意连续型标度均有效，但只有位置标度有简写形式。</p><p>当然，可以直接对变量进行变换，而不使用标度变换。比如我们可以直接绘制<code>log10(x)</code>，而不去使用<code>scale_x_log10()</code>。</p><p><strong>这两种做法将在绘图区域生成完全相同的结果，但是坐标轴和刻度标签却是不同的</strong>。</p><p>下面是一个对比：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自行变换log10()-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = log10(carat), y = log10(price), color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># scale_x_log10()变换-右图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + scale_x_log10() + scale_y_log10()</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-位置-连续型.png" title="标度-位置-连续型"><h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>日期和时间值基本上属于连续型标度，但在标注坐标轴时有着特殊的处理方式。目前我们仅支持属于<code>date</code>类的日期值和属于<code>POSIXct</code>类的时间值。如果你的日期和时间值是其他格式的，则需要<code>as.Date()</code>或<code>as.POSIXct()</code>对其进行转换。</p><p>一共有三个参数可以控制坐标轴外观和刻度的位置：major、minor、format：</p><ul><li>major、minor：以时间的单位（即年月周日时分秒）来指定主要和次要断点的位置，并且允许以这些单位的倍数出现，比如，<code>major = &quot;2weeks&quot;</code>将在每隔两周的位置放置一个主刻度。如果未指定，日期刻度可以自动选出合适的默认值。</li><li>format：指定了刻度标签的格式。</li></ul><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(scales)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间序列-左上</span></span><br><span class="line">p &lt;- ggplot(data = economics, mapping = aes(x = date, y = psavert))</span><br><span class="line">p &lt;- p + geom_line()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加水平线-右上</span></span><br><span class="line">p &lt;- p + geom_hline(xintercept = <span class="number">0</span>, yintercept = <span class="number">0</span>, colour = <span class="string">"gray50"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔10年为一个断点-左下</span></span><br><span class="line">p + scale_x_date(breaks = date_breaks(<span class="string">"10 years"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用年月日的格式仅显示在2004年内的图形-右下</span></span><br><span class="line">p + scale_x_date(limits = as.Date(c(<span class="string">"2004-01-01"</span>,<span class="string">"2005-01-01"</span>)), labels = date_format(<span class="string">"%Y-%m-%d"</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-位置-时间.png" title="标度-位置-时间"><h4 id="离散型位置标度"><a href="#离散型位置标度" class="headerlink" title="离散型位置标度"></a>离散型位置标度</h4><p>离散型位置标度<code>scale_x_discrete</code>、<code>scale_y_discrete</code>将输入中的各个水平映射为整数。结果的顺序可用参数breaks进行控制，不想要的水平可以使用limits（或xlim、ylim）进行丢弃。</p><p>由于我们经常也会在图形的非整点位置放置标签和标注，所以离散型位置标度也可以接受连续型的值。如果你尚未调整breaks或limits，某个因子水平的所在位置的数值表示可以使用<code>as.numeric()</code>进行计算：以从1开始的整数表示。</p><p>离散型位置标度的参数主要是前面提到的<strong>通用参数</strong>。</p><p>下面看一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认方案-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(cut, price))</span><br><span class="line">p &lt;- p + geom_boxplot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改横轴标度-中图</span></span><br><span class="line">p + scale_x_discrete(labels = c(<span class="string">"Fair"</span> = <span class="string">"A"</span>,<span class="string">"Good"</span> = <span class="string">"B"</span>, <span class="string">"Very Good"</span> = <span class="string">"C"</span>,<span class="string">"Premium"</span> = <span class="string">"D"</span>,<span class="string">"Ideal"</span> = <span class="string">"E"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不想展示的cut-右图</span></span><br><span class="line">p + scale_x_discrete(limits = c(<span class="string">"Fair"</span>,<span class="string">"Good"</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-位置-离散型.png" title="标度-位置-离散型"><h3 id="颜色标度"><a href="#颜色标度" class="headerlink" title="颜色标度"></a>颜色标度</h3><p>以下标度对<strong>边界色（colour）图形属性</strong>和<strong>填充色（fill）图形属性</strong>均有效。</p><h4 id="连续型颜色标度"><a href="#连续型颜色标度" class="headerlink" title="连续型颜色标度"></a>连续型颜色标度</h4><p>根据颜色梯度中的色彩数量划分，共有三类连续型颜色梯度（即渐变色）：</p><ul><li><strong><code>scale_colour_gradient()</code>、<code>scale_fill_gradient()</code>：双色梯度</strong>。参数low和high控制梯度两端的颜色</li><li><strong><code>scale_colour_gradient2()</code>、<code>scale_fill_gradient2()</code>：三色梯度</strong>。顺序为低-中-高，这两种标度还在中点处拥有一个中间色</li><li><strong><code>scale_colour_gradientn()</code>、<code>scale_fill_gradientn()</code>：自定义n色梯度</strong></li></ul><p><strong>颜色梯度常被用来展示一个二维表面的高度，用以描述第三维度，颜色的深浅代表着不同的值</strong>。例如描述地势高低时，地势的高低常常用颜色深浅来展现。</p><p>下面我们用R自带的一个向量数据集volcano，因为ggplot2只接受数据框格式，因此我们先把数据转换成数据框格式：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(reshape2)</span><br><span class="line"></span><br><span class="line">volcano3d &lt;- melt(volcano)</span><br><span class="line">names(volcano3d) &lt;- c(<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>)</span><br></pre></td></tr></table></figure><p>下面展示双色梯度<code>scale_fill_gradient()</code>的用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认参数-左图</span></span><br><span class="line">p &lt;- ggplot(data = volcano3d,mapping = aes(x,y,fill=z))</span><br><span class="line">p &lt;- p + geom_tile()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制填充颜色的值范围-中图</span></span><br><span class="line">p + scale_fill_gradient(limits = c(<span class="number">120</span>,<span class="number">170</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过参数low与high，控制颜色在low与high之间渐变-右图</span></span><br><span class="line">p + scale_fill_gradient(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-颜色-连续型-1.png" title="标度-颜色-连续型-1"><p>下面展示三色梯度<code>scale_fill_gradient2()</code>的用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认参数，即midpoint=0-左图</span></span><br><span class="line">p + scale_fill_gradient2(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置midpoint=150-右图</span></span><br><span class="line">p + scale_fill_gradient2(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>, midpoint = <span class="number">150</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-颜色-连续型-2.png" title="标度-颜色-连续型-2"><p>以上两图都设定了颜色由 blue 到 red 渐变，但是左图使用默认参数 <code>midpoint=0</code>，右图使用参数<code>midpoint=150</code>，而 z 值的范围是 <code>94~195</code>，所有他们在图中实际渐变色为，<strong>左图：浅红-红，右图：蓝-白-红</strong>。</p><p>下面展示自定义n色梯度<code>scale_fill_gradientn()</code>的用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动设置颜色-左图</span></span><br><span class="line">p + scale_fill_gradientn(colours = c(<span class="string">"black"</span>,<span class="string">"blue"</span>,<span class="string">"red"</span>,<span class="string">"white"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用R语言预设的调色盘-右图</span></span><br><span class="line">p + scale_fill_gradientn(colours = topo.colors(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-颜色-连续型-3.png" title="标度-颜色-连续型-3"><h4 id="离散型颜色标度"><a href="#离散型颜色标度" class="headerlink" title="离散型颜色标度"></a>离散型颜色标度</h4><p>离散型数据有两种颜色标度。一种可以自动选择颜色，另一种可以手工从颜色集中选择颜色。</p><ul><li><p>默认的配色方案，即<code>scale_colour_hue()</code>、<code>scale_fill_hue()</code>，可通过沿着hcl色轮选取均匀分布的色相来生成颜色。这种方案对颜色较少时有比较好的效果，但对于更多不同的颜色就不好区分开来。</p></li><li><p>另一种可选的方案是<a href="http://colorbrewer.org" rel="external nofollow noopener noreferrer" target="_blank">ColorBrewer配色</a>。即<code>scale_colour_brewer()</code>、<code>scale_fill_brewer()</code>。要想了解所有的调色板，可以使用<code>RColorBrewer::display.brewer.all()</code>查看。我们可以用参数<code>palette=”调色板名称或者数字”</code>来使用。例如，使用第二个调色板时用<code>palette = 2</code>（等价于<code>palette = &#39;YIOrBr&#39;</code>）。</p></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认方案，即scale_colour_hue()-左上图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(cut, price, fill = color))</span><br><span class="line">p &lt;- p + geom_boxplot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用ColorBrewer配色-右上图</span></span><br><span class="line">p + scale_fill_brewer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用ColorBrewer配色中第二个调色板-左下图</span></span><br><span class="line">p + scale_fill_brewer(palette = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用ColorBrewer配色中'Spectral'调色板-右下图</span></span><br><span class="line">p + scale_fill_brewer(palette = <span class="string">"Spectral"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-颜色-离散型.png" title="标度-颜色-离散型"><h3 id="手动离散型标度"><a href="#手动离散型标度" class="headerlink" title="手动离散型标度"></a>手动离散型标度</h3><p>离散型标度<code>scale_linetype()</code>、<code>scale_colour_manual()</code>、<code>scale_size_discrete()</code>、<code>scale_shape()</code>是按一定的顺序将因子的水平映射到一系列取值中。<strong>如果想要定制这些标度，需要使用以下手动型标度创建新的标度</strong>：</p><ul><li><code>scale_linetype_manual()</code></li><li><code>scale_colour_manual()</code></li><li><code>scale_size_discrete()</code></li><li><code>scale_shape_manual()</code></li></ul><p>手动型标度拥有一个重要参数values，我们可以用它来指定这个标度应该生成的值。</p><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认颜色-左上图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动改变颜色-右上图</span></span><br><span class="line">p + scale_colour_manual(values = c(<span class="string">"Fair"</span> = <span class="string">"red"</span>,<span class="string">"Good"</span> = <span class="string">"yellow"</span>,<span class="string">"Very Good"</span> = <span class="string">"green"</span>,<span class="string">"Premium"</span> = <span class="string">"blue"</span>,<span class="string">"Ideal"</span> = <span class="string">"black"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认大小-左下图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, size = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动改变大小-右下图</span></span><br><span class="line">p + scale_size_manual(values = c(<span class="number">10</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-手动离散型.png" title="标度-手动离散型"><h3 id="同一型标度"><a href="#同一型标度" class="headerlink" title="同一型标度"></a>同一型标度</h3><p>当你的数据能被R中的绘图函数理解时，即数据空间和图形属性空间相同时，可以使用同一性标度(identity scale)，这意味着此时无法仅从数据本身派生出有意义的图例，所以默认是不绘制图例。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/lantingg/p/7999251.html" rel="external nofollow noopener noreferrer" target="_blank">ggplot2入门与进阶（上）</a></li><li><a href="https://www.cnblogs.com/lizhilei-123/p/6808370.html" rel="external nofollow noopener noreferrer" target="_blank">R数据可视化—-ggplot2之标度、坐标轴和图例详解</a></li><li><a href="https://blog.csdn.net/songzhilian22/article/details/49388677" rel="external nofollow noopener noreferrer" target="_blank">ggplot2学习笔记之颜色标度</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;标度控制着&lt;strong&gt;数据到图形属性的映射&lt;/strong&gt;，标度将我们的数据转化为视觉上可以感知的东西，如大小、颜色、位置和形状，所以通过标度可以修改坐标轴和图例的参数。&lt;/p&gt;&lt;p&gt;每一种图形属性都拥有一个默认的标度，此标度将在我们每次使用这个图形属性时被自动添加到图形中，这些标度列于下表中，默认属性粗体显示：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;图形属性&lt;/th&gt;&lt;th&gt;离散型&lt;/th&gt;&lt;th&gt;连续型&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;颜色和填充色&lt;/td&gt;&lt;td&gt;brewer grey &lt;strong&gt;hue&lt;/strong&gt; identity manual&lt;/td&gt;&lt;td&gt;&lt;strong&gt;gradient&lt;/strong&gt; gradient2 gradientn&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;位置&lt;/td&gt;&lt;td&gt;&lt;strong&gt;discrete&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;continuous&lt;/strong&gt; date&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;形状&lt;/td&gt;&lt;td&gt;&lt;strong&gt;shape&lt;/strong&gt; identity manual&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;线条类型&lt;/td&gt;&lt;td&gt;&lt;strong&gt;linetype&lt;/strong&gt; identity manual&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;大小&lt;/td&gt;&lt;td&gt;identity manual&lt;/td&gt;&lt;td&gt;&lt;strong&gt;size&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果要添加一个不同的标度或修改默认标度的某些特征，&lt;strong&gt;我们必须构建一个新的标度，然后使用&lt;code&gt;+&lt;/code&gt;将其添加到图形上&lt;/strong&gt;。所有的标度构建器（scale）都拥有一套通用的命名方案，它们以&lt;code&gt;scale_&lt;/code&gt;开头，接下来是图形属性的名称（例如：&lt;code&gt;colour_&lt;/code&gt;、&lt;code&gt;shape_&lt;/code&gt;、&lt;code&gt;x_&lt;/code&gt;）最后以标度的名称结尾（&lt;code&gt;gradient&lt;/code&gt;、&lt;code&gt;hue&lt;/code&gt;、&lt;code&gt;manual&lt;/code&gt;）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;离散图形的颜色属性采用默认标度：&lt;code&gt;scale_colour_hue()&lt;/code&gt;&lt;/li&gt;&lt;li&gt;离散图形的填充色属性采用ColorBrewer配色标度：&lt;code&gt;scale_fill_brewer()&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2的坐标系</title>
    <link href="https://tding.top/archives/16cc1f7e.html"/>
    <id>https://tding.top/archives/16cc1f7e.html</id>
    <published>2019-12-07T14:30:00.000Z</published>
    <updated>2019-12-08T13:13:32.081Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>在ggplot2中，为了得到更好的数据可视化效果，我们可能要用到一些坐标转换的操作。</p><p>ggplot2包含了6种不同的坐标系：</p><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>coord_cartesian</code></td><td style="text-align:center">笛卡尔坐标系</td></tr><tr><td style="text-align:center"><code>coord_equal</code></td><td style="text-align:center">同尺度笛卡尔坐标系</td></tr><tr><td style="text-align:center"><code>coord_flip</code></td><td style="text-align:center">翻转的笛卡尔坐标系</td></tr><tr><td style="text-align:center"><code>coord_trans</code></td><td style="text-align:center">变换的笛卡尔坐标系</td></tr><tr><td style="text-align:center"><code>coord_map</code></td><td style="text-align:center">地图射影</td></tr><tr><td style="text-align:center"><code>coord_polar</code></td><td style="text-align:center">极坐标系</td></tr></tbody></table><a id="more"></a><h2 id="笛卡尔坐标系"><a href="#笛卡尔坐标系" class="headerlink" title="笛卡尔坐标系"></a>笛卡尔坐标系</h2><p>笛卡尔坐标系参数说明：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_cartesian(xlim = <span class="literal">NULL</span>, ylim = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>xlim、ylim参数用来限定x、y轴的范围。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整数据集-左</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p1 &lt;- p1 + geom_point()</span><br><span class="line">p1 &lt;- p1 + geom_smooth()</span><br><span class="line"></span><br><span class="line"><span class="comment"># x的标度范围设置-中</span></span><br><span class="line">p2 &lt;- p1 + scale_x_continuous(limits = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴坐标系范围设置-右</span></span><br><span class="line">p3 &lt;- p1 + coord_cartesian(xlim = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,p3,ncol=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/笛卡尔坐标系-1.png" title="笛卡尔坐标系-1"><p>左图是完整的数据集，中图为x的标度范围设置，右图为x轴坐标系范围设置。标度的范围设置是对数据取子集，然后再重新拟合曲线。<strong>坐标系的放缩就是图像的放缩</strong>。</p><p>上面的这个图看的不是很明显，下面看个更明显的例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整数据集-左</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p1 &lt;- p1 + stat_bin2d(bins = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x的标度范围设置-中</span></span><br><span class="line">p2 &lt;- p1 + scale_x_continuous(limits = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴坐标系范围设置-右</span></span><br><span class="line">p3 &lt;- p1 + coord_cartesian(xlim = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,p3,ncol=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/笛卡尔坐标系-2.png" title="笛卡尔坐标系-2"><p>这里我们可以通过方块的大小很直观的发现，当设定标度范围时，方块的数目还是相同的，只是覆盖了更少数的区域，当设定坐标系范围时，<strong>方块数目变少，但它们覆盖的区域没变</strong>。</p><h2 id="坐标轴翻转"><a href="#坐标轴翻转" class="headerlink" title="坐标轴翻转"></a>坐标轴翻转</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_flip()</span><br></pre></td></tr></table></figure><p>把x轴和y轴互换，没有特殊参数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常数据集-左</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p1 &lt;- p1 + geom_point()</span><br><span class="line">p1 &lt;- p1 + geom_smooth()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴属性改变-中</span></span><br><span class="line">p2 &lt;- ggplot(data = diamonds, mapping = aes(x = price, y = carat))</span><br><span class="line">p2 &lt;- p2 + geom_point()</span><br><span class="line">p2 &lt;- p2 + geom_smooth()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴翻转-右</span></span><br><span class="line">p3 &lt;- p1 + coord_flip()</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,p3,ncol=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/坐标轴翻转.png" title="坐标轴翻转"><ul><li>左图是原散点图相应的平滑曲线</li><li>中图互换两个属性变量，平滑曲线拟合的是旋转后的变量</li><li>右图<code>coord_flip()</code>拟合原始数据，<strong>然后再翻转输出结果</strong>，就变成是以y为条件变量刻画x的曲线了</li></ul><h2 id="坐标轴变换"><a href="#坐标轴变换" class="headerlink" title="坐标轴变换"></a>坐标轴变换</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_trans(x = <span class="string">"identity"</span>, y = <span class="string">"identity"</span>, limx = <span class="literal">NULL</span>, limy = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>坐标形式转换包括对数转换、平方根转换等，这里x和y的值可以是log10,log2或squal等，另外两个参数也是限定坐标范围。</p><p>这个坐标轴变换函数<code>coord_trans()</code>和<code>scale_x_log10()</code>这类函数是有区别的：</p><ul><li>坐标轴变换函数是其他处理优先，最后作图时再取对数</li><li>标度函数是先将数据取对数，然后再拿进来处理</li></ul><p>我们拿拟合曲线举例子：</p><ul><li>如果用<code>scale_x_log10</code>就相当于把x的数据取了对数放进来做回归，拟合出一条直线。</li><li>如果用<code>coord_trans</code>则是先用原有数据进行回归，得到一条拟合直线之后再变换坐标轴，<strong>曲线也会被弯曲</strong>！</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"><span class="keyword">library</span>(scales)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常数据集-左</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p1 &lt;- p1 + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标度变换-中</span></span><br><span class="line">p2 &lt;- p1 + scale_x_log10() + scale_y_log10() + geom_smooth(method = <span class="string">'lm'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴变换-右</span></span><br><span class="line">p3 &lt;- p2 + coord_trans(x = exp_trans(<span class="number">10</span>),y=exp_trans(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,p3,ncol=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/坐标轴变换.png" title="坐标轴变换"><p><strong>坐标系层面的变换发生再统计变换之后，会影响拟合的曲线形状</strong>。</p><ul><li>左图为克拉和价格的散点图</li><li>中图为克拉和价格<strong>对数变换</strong>后的散点图，直线为回归曲线：<code>log(y)=a+blog(x)</code></li><li>右图将前面的图变换回去，标度还原，因此线性趋势变成指数形式，<code>y=k(c^x)</code></li></ul><h2 id="极坐标转换"><a href="#极坐标转换" class="headerlink" title="极坐标转换"></a>极坐标转换</h2><p>极坐标转换可以做出蜘蛛图或饼图的效果。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_polar(theta = <span class="string">"x"</span>, start = <span class="number">0</span>, direction = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>theta可以选择x或y，表示外延的坐标</li><li>start是坐标开始的角度，默认起始位置是12点钟</li></ul><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱状图-上图</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = factor(<span class="number">1</span>), fill = cut))</span><br><span class="line">p1 &lt;- p1 + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 圆环图效果-下图左</span></span><br><span class="line">p2 &lt;- p1 + coord_polar(theta=<span class="string">"x"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 饼图效果-下图右</span></span><br><span class="line">p3 &lt;- p1 + coord_polar(theta=<span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line">grid.arrange(p2,p3,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/极坐标转换-1.png" title="极坐标转换-1"><ul><li>上图：当使用一个因子变量作为横轴，使用分类变量进行填充时，该柱形图变成了单条堆积柱形图。</li><li>当theta指定为x时，柱形图的x轴会被指定为极坐标的x轴（圆周），而柱形图的y轴则会成为极坐标的y轴（半径）。</li><li>当theta指定为y时，柱形图的y轴为被指定为极坐标的x轴（圆周），而柱形图的x轴则会成为极坐标的y轴（半径）。</li></ul><p>当有多个序列时：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱状图-上图</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = cut, fill = cut))</span><br><span class="line">p1 &lt;- p1 + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 南丁格尔玫瑰图效果-左</span></span><br><span class="line">p2 &lt;- p1 + coord_polar(theta=<span class="string">"x"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 圆环图、圆条图效果-右</span></span><br><span class="line">p3 &lt;- p1 + coord_polar(theta=<span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line">grid.arrange(p2,p3,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/极坐标转换-2.png" title="极坐标转换-2"><p>当有多个序列时，我们可以通过极坐标转换可以实现圆环图、圆条图效果以及南丁格尔玫瑰图效果。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠柱状图-上图</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = color, fill = cut))</span><br><span class="line">p1 &lt;- p1 + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠玫瑰图效果-左</span></span><br><span class="line">p2 &lt;- p1 + coord_polar(theta=<span class="string">"x"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复杂的圆环图效果-右</span></span><br><span class="line">p3 &lt;- p1 + coord_polar(theta=<span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line">grid.arrange(p2,p3,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/极坐标转换-3.png" title="极坐标转换-3"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/wkslearner/p/5718928.html" rel="external nofollow noopener noreferrer" target="_blank">ggplot2 坐标系相关设置（coord）</a></li><li><a href="https://blog.csdn.net/u011596455/article/details/79574080" rel="external nofollow noopener noreferrer" target="_blank">七、R数据可视化–ggplot2定位之坐标系详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/27262426" rel="external nofollow noopener noreferrer" target="_blank">R语言可视化——极坐标变换与衍生图表类型</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在ggplot2中，为了得到更好的数据可视化效果，我们可能要用到一些坐标转换的操作。&lt;/p&gt;&lt;p&gt;ggplot2包含了6种不同的坐标系：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align:center&quot;&gt;名字&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_cartesian&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;笛卡尔坐标系&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_equal&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;同尺度笛卡尔坐标系&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_flip&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;翻转的笛卡尔坐标系&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_trans&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;变换的笛卡尔坐标系&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_map&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;地图射影&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_polar&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;极坐标系&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2的分面</title>
    <link href="https://tding.top/archives/12b79187.html"/>
    <id>https://tding.top/archives/12b79187.html</id>
    <published>2019-12-07T06:30:00.000Z</published>
    <updated>2019-12-07T15:40:04.494Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>分面(facet)是在一个页面上自动摆放多幅图形，这一过程先将数据划分为多个子集，然后将每个子集依次绘制到页面的不同面板中。</p><p>ggplot2提供了两种分面类型：</p><ul><li>网格分面-<code>facet_grid</code>：生成一个2维的面板网格，面板的行与列通过变量来定义。<strong>本质是2维的</strong>。</li><li>封装分面-<code>facet_wrap</code>：首先生成一个1维的面板条块，然后再分装到2维中。<strong>本质是1维的</strong>。</li></ul><a id="more"></a><h2 id="网格分面-facet-grid"><a href="#网格分面-facet-grid" class="headerlink" title="网格分面-facet_grid"></a>网格分面-<code>facet_grid</code></h2><p>网格分面生成的是一个2维的面板网格，面板的行与列通过变量来定义。本质是2维的。</p><h3 id="不进行分面"><a href="#不进行分面" class="headerlink" title="不进行分面"></a>不进行分面</h3><p>不进行分面：即不使用函数<code>facet_grid()</code>或使用<code>facet_null()</code>函数，此时得到的是单独画板。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_null()</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-1.png" title="网格分面-1"><h3 id="一行多列"><a href="#一行多列" class="headerlink" title="一行多列"></a>一行多列</h3><p>一行多列：纵坐标相同，用于y位置的比较。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_grid(<span class="string">'. ~ cut'</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-2.png" title="网格分面-2"><p><strong>电脑屏幕通常较宽，因此这个方向最合适数据的展示</strong>。</p><h3 id="一列多行"><a href="#一列多行" class="headerlink" title="一列多行"></a>一列多行</h3><p>一列多行：横坐标轴相同，利于x位置的比较，<strong>尤其是对数据分布的比较</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p &lt;- p + geom_histogram(binwidth = <span class="number">30</span>)</span><br><span class="line">p &lt;- p + facet_grid(<span class="string">'cut ~ .'</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-3.png" title="网格分面-3"><h3 id="多列多行"><a href="#多列多行" class="headerlink" title="多列多行"></a>多列多行</h3><p>我们通常都将数目最多的变量按列排放，这样可以充分利用屏幕的宽高比。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_grid(<span class="string">'cut ~ color'</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-4.png" title="网格分面-4"><h3 id="facet-grid-函数的参数"><a href="#facet-grid-函数的参数" class="headerlink" title="facet_grid()函数的参数"></a><code>facet_grid()</code>函数的参数</h3><p><code>facet_grid()</code>函数的全部参数如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">facet_grid(facets, margins = <span class="literal">FALSE</span>, scales = <span class="string">"fixed"</span>, space = <span class="string">"fixed"</span>, shrink = <span class="literal">TRUE</span>,</span><br><span class="line">           labeller = <span class="string">"label_value"</span>, as.table = <span class="literal">TRUE</span>, drop = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><ul><li>facets：分面参数</li><li>margins：用于分面的包含每个变量元素所有数据的数据组</li><li>scales：坐标刻度的范围，可以设定四种类型：<ul><li><code>fixed</code>：表示所有小图均使用统一坐标范围</li><li><code>free</code>：表示每个小图按照各自数据范围自由调整坐标刻度范围</li><li><code>free_x</code>：表示可以自由调整x轴刻度范围</li><li><code>free_y</code>：表示可以自由调整y轴刻度范围</li></ul></li><li>space：这个参数要配合scales使用，如果为fixed（默认），所有小图的大小都一样，如果为<code>free/free_x/free_y</code>，小图的大小将按照坐标轴的跨度比例进行设置</li><li>shrinks：这个参数和坐标轴刻度有关，如果为TRUE（默认）则按统计后的数据调整刻度范围，否则按统计前的数据设定坐标</li><li>labeller：这个参数用来设定小图标签</li><li>as.table：小图排列顺序有关的选项。如果为TRUE（默认）则按表格方式排列，即最大值（指分组level值）排在表格最后即右下角，否则排在左上角</li><li>drop：是否丢弃没有数据的分组，如果为TRUE（默认），则空数据组不绘图</li></ul><h4 id="margins"><a href="#margins" class="headerlink" title="margins"></a>margins</h4><p>我们可以用margins来绘制<strong>边际图</strong>。设定<code>margins=TRUE</code>可展示所有的边际图，或者<code>margins=c(&quot;A&quot;,&quot;B&quot;)</code>，列出你要展示的边际图的变量名称。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p &lt;- p + geom_histogram(binwidth = <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认-左图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示所有的边际图（margins = TRUE）-右图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, margins = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-margins.png" title="网格分面-margins"><h4 id="scales"><a href="#scales" class="headerlink" title="scales"></a>scales</h4><p>固定标度可以让我们在相同的基准上对子集进行比较，观察在哪些地方各子集有相似的总体模式。而自由标度可以帮助我们发现更多细节，它在展示不同量纲的时间序列时非常有用。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p &lt;- p + geom_histogram(binwidth = <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个分面中固定标度即横纵坐标范围相同-左图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, scales = <span class="string">'fixed'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自由标度即横纵坐标范围可变-右图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, scales = <span class="string">'free'</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-scales.png" title="网格分面-scales"><h4 id="space"><a href="#space" class="headerlink" title="space"></a>space</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p &lt;- p + geom_histogram(binwidth = <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个分面中固定标度即横纵坐标范围相同-左图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, scales = <span class="string">'fixed'</span>, space = <span class="string">'fixed'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># space设置为free时，每列的宽度与该列的标度范围成比例-右图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, scales = <span class="string">'free'</span>, space = <span class="string">'free'</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-space.png" title="网格分面-space"><h2 id="封装分面-facet-wrap"><a href="#封装分面-facet-wrap" class="headerlink" title="封装分面-facet_wrap"></a>封装分面-<code>facet_wrap</code></h2><p>封装分面首先生成一个1维的面板条块，然后再分装到2维中。<strong>本质是1维的</strong>。</p><h3 id="facet-wrap-函数的参数"><a href="#facet-wrap-函数的参数" class="headerlink" title="facet_wrap()函数的参数"></a><code>facet_wrap()</code>函数的参数</h3><p><code>facet_wrap()</code>函数的全部参数如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">facet_wrap(facets, nrow = <span class="literal">NULL</span>, ncol = <span class="literal">NULL</span>, scales = <span class="string">"fixed"</span>,</span><br><span class="line">           shrink = <span class="literal">TRUE</span>, as.table = <span class="literal">TRUE</span>, drop = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>前面已经介绍过网格分面的参数，这里的封装分面的参数也是类似的，下面介绍不同的几个参数：</p><ul><li>nrow：绘制图形的行数</li><li>ncol：绘制图形的列数，一般<code>nrow/ncol</code>只设定一个即可</li></ul><h3 id="默认设置"><a href="#默认设置" class="headerlink" title="默认设置"></a>默认设置</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认设置</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_wrap(~ color)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/封装分面-1.png" title="封装分面-1"><h3 id="设置列"><a href="#设置列" class="headerlink" title="设置列"></a>设置列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过ncol=2设置为两列</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_wrap(~ color, ncol = <span class="number">2</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/封装分面-2.png" title="封装分面-2"><h2 id="分面与分组对比"><a href="#分面与分组对比" class="headerlink" title="分面与分组对比"></a>分面与分组对比</h2><p>这两种绘图技巧都有相应的优缺点。</p><p>在分面图形中，每个组别都在单独的面板中，相隔较远，组间无重叠。因此组与组之间重叠严重时，分面图形有一定的好处。不过这也会导致组间的细微差别难以被发现。使用图形属性区分各组时，各组将会离得很近甚至可能重叠，不过细微得差别将会容易被发现。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组-左上</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))</span><br><span class="line">p1 &lt;- p1 + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分面-右上</span></span><br><span class="line">p2 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))</span><br><span class="line">p2 &lt;- p2 + geom_point()</span><br><span class="line">p2 &lt;- p2 + facet_grid(<span class="string">'. ~ cut'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组-只显示回归线-左下</span></span><br><span class="line">p3 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))</span><br><span class="line">p3 &lt;- p3 + geom_smooth(method = lm, se = <span class="literal">F</span>, fullrange = <span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分面-只显示回归线-右下</span></span><br><span class="line">p4 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))</span><br><span class="line">p4 &lt;- p4 + geom_smooth(method = lm, se = <span class="literal">F</span>, fullrange = <span class="literal">T</span>)</span><br><span class="line">p4 &lt;- p4 + facet_grid(<span class="string">'. ~ cut'</span>)</span><br><span class="line"></span><br><span class="line">p &lt;- grid.arrange(p1,p2,p3,p4,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/分面与分组对比.png" title="分面与分组对比"><p><strong>我们可以使用color或者fill图形属性来为分面条形图上色</strong>。</p><p>在散点图中，仅使用颜色区分各组，我们可能还没注意到图形重叠了，但是回归线却可以让我们看到Ideal、Premium、Good、Very Good被分组在一起，与Fair组相距甚远。</p><h2 id="分面与并列对比"><a href="#分面与并列对比" class="headerlink" title="分面与并列对比"></a>分面与并列对比</h2><p>分面可绘制出与图形并列类似得图形效果。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并列-左图</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = color, fill = cut))</span><br><span class="line">p1 &lt;- p1 + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分面-右图</span></span><br><span class="line">p2 &lt;- ggplot(data = diamonds, mapping = aes(x = color, fill = cut))</span><br><span class="line">p2 &lt;- p2 + geom_bar()</span><br><span class="line">p2 &lt;- p2 + facet_grid(<span class="string">'. ~ cut'</span>)</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/分面与并列对比.png" title="分面与并列对比"><p><strong>我们可以使用color或者fill图形属性来为分面条形图上色</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/songzhilian22/article/details/49491281" rel="external nofollow noopener noreferrer" target="_blank">ggplot2学习笔记之分面</a></li><li><a href="https://blog.csdn.net/u011596455/article/details/79574072" rel="external nofollow noopener noreferrer" target="_blank">六、R语言可视化–ggplot2定位之分面</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;分面(facet)是在一个页面上自动摆放多幅图形，这一过程先将数据划分为多个子集，然后将每个子集依次绘制到页面的不同面板中。&lt;/p&gt;&lt;p&gt;ggplot2提供了两种分面类型：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;网格分面-&lt;code&gt;facet_grid&lt;/code&gt;：生成一个2维的面板网格，面板的行与列通过变量来定义。&lt;strong&gt;本质是2维的&lt;/strong&gt;。&lt;/li&gt;&lt;li&gt;封装分面-&lt;code&gt;facet_wrap&lt;/code&gt;：首先生成一个1维的面板条块，然后再分装到2维中。&lt;strong&gt;本质是1维的&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2中的qplot函数</title>
    <link href="https://tding.top/archives/8c7eb5d5.html"/>
    <id>https://tding.top/archives/8c7eb5d5.html</id>
    <published>2019-12-06T15:30:00.000Z</published>
    <updated>2019-12-06T15:40:55.920Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p><code>qplot()</code>是ggplot2的一个作图函数，qplot的意思是快速作图（quick plot）。</p><a id="more"></a><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>本文的所有绘图使用的都是ggplot2内置的diamonds数据集，便于我们聚焦于作图的细节。</p><p>diamonds数据集包含了约54000颗钻石的价格和质量的信息。</p><p>数据说明：</p><ul><li>反映钻石质量的四个“C”<ul><li>克拉重量：carat</li><li>切工：cut</li><li>颜色：color</li><li>净度：clarity</li></ul></li><li>五个物理指标<ul><li>深度：depth</li><li>钻面宽度：table</li><li>x</li><li>y</li><li>z</li></ul></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(diamonds)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Classes &apos;tbl_df&apos;, &apos;tbl&apos; and &apos;data.frame&apos;:53940 obs. of  10 variables:</span><br><span class="line"> $ carat  : num  0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...</span><br><span class="line"> $ cut    : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ...</span><br><span class="line"> $ color  : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ...</span><br><span class="line"> $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ...</span><br><span class="line"> $ depth  : num  61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...</span><br><span class="line"> $ table  : num  55 61 65 58 58 57 57 55 61 61 ...</span><br><span class="line"> $ price  : int  326 326 327 334 335 336 336 337 337 338 ...</span><br><span class="line"> $ x      : num  3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...</span><br><span class="line"> $ y      : num  3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...</span><br><span class="line"> $ z      : num  2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(diamonds)</span><br></pre></td></tr></table></figure><table><thead><tr><th>carat</th><th>cut</th><th>color</th><th>clarity</th><th>depth</th><th>table</th><th>price</th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>0.23</td><td>Ideal</td><td>E</td><td>SI2</td><td>61.5</td><td>55</td><td>326</td><td>3.95</td><td>3.98</td><td>2.43</td></tr><tr><td>0.21</td><td>Premium</td><td>E</td><td>SI1</td><td>59.8</td><td>61</td><td>326</td><td>3.89</td><td>3.84</td><td>2.31</td></tr><tr><td>0.23</td><td>Good</td><td>E</td><td>VS1</td><td>56.9</td><td>65</td><td>327</td><td>4.05</td><td>4.07</td><td>2.31</td></tr><tr><td>0.29</td><td>Premium</td><td>I</td><td>VS2</td><td>62.4</td><td>58</td><td>334</td><td>4.20</td><td>4.23</td><td>2.63</td></tr><tr><td>0.31</td><td>Good</td><td>J</td><td>SI2</td><td>63.3</td><td>58</td><td>335</td><td>4.34</td><td>4.35</td><td>2.75</td></tr><tr><td>0.24</td><td>Very Good</td><td>J</td><td>VVS2</td><td>62.8</td><td>57</td><td>336</td><td>3.94</td><td>3.96</td><td>2.48</td></tr></tbody></table><p>下面我们从原始数据中随机选出100个样本作为新数据集<code>dsmall</code>，便于小数据的作图展示：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让样本可重复</span></span><br><span class="line">set.seed(<span class="number">1410</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始数据的一个容量为100的随机样本</span></span><br><span class="line">dsmall &lt;- diamonds[sample(nrow(diamonds),<span class="number">100</span>),]</span><br></pre></td></tr></table></figure><h2 id="qplot-基本用法"><a href="#qplot-基本用法" class="headerlink" title="qplot()基本用法"></a>qplot()基本用法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>下面是钻石的价格和重量之间的关系：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本用法-左图</span></span><br><span class="line">qplot(carat, price, data = diamonds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种相关关系似乎是指数型的，因此我们应该先对变量进行一些变换。</span></span><br><span class="line"><span class="comment"># 变量的函数作为参数-中图</span></span><br><span class="line">qplot(log(carat), log(price), data = diamonds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量的某种组合作为参数-右图</span></span><br><span class="line"><span class="comment"># 钻石的体积（`x * y * z`表示）和重量之间的关系</span></span><br><span class="line">qplot(carat, x * y * z, data = diamonds)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/基本用法.png" title="基本用法"><h2 id="颜色、大小、形状和其他图形属性"><a href="#颜色、大小、形状和其他图形属性" class="headerlink" title="颜色、大小、形状和其他图形属性"></a>颜色、大小、形状和其他图形属性</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分组-颜色-左图</span></span><br><span class="line">qplot(carat, price, data = dsmall, colour = color)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组-形状-右图</span></span><br><span class="line">qplot(carat, price, data = dsmall, shape = cut)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/颜色、形状.png" title="颜色、形状"><p>我们可以使用<code>I()</code>来手动设定图形属性。</p><p>例如：<code>colour = I(&quot;red&quot;)</code>或<code>size = I(2)</code>。</p><p>我们可以通过使用alpha图形属性来调整透明度，例如<code>1/10</code>，其分母表示经过多少次重叠之后颜色将变得不透明，这样我们可以看到大部分的点在哪里进行了重叠。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透明度设置为1/10-左图</span></span><br><span class="line">qplot(carat, price, data = diamonds, alpha = I(<span class="number">1</span>/<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透明度设置为1/200-右图</span></span><br><span class="line">qplot(carat, price, data = diamonds, alpha = I(<span class="number">1</span>/<span class="number">200</span>))</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/透明度设置.png" title="透明度设置"><h2 id="几何对象geom"><a href="#几何对象geom" class="headerlink" title="几何对象geom"></a>几何对象geom</h2><p>我们可以通过改变几何对象画出任何一种类型的图形。</p><p>二维变量关系：</p><ul><li><code>geom = &quot;point&quot;</code>：散点图（默认）</li><li><code>geom = &quot;smooth&quot;</code>：拟合一条平滑曲线</li><li><code>geom = &quot;boxplot&quot;</code>：箱线胡须图</li><li><code>geom = &quot;path&quot;</code>和<code>geom = &quot;line&quot;</code>：数据点之间绘制连线</li></ul><p>一维分布：</p><ul><li>连续变量<ul><li><code>geom = &quot;histogram&quot;</code>：直方图（默认）</li><li><code>geom = &quot;freqplot&quot;</code>：频率多边形</li><li><code>geom = &quot;density&quot;</code>：密度曲线</li></ul></li><li>离散变量<ul><li><code>geom = &quot;bar&quot;</code>：条形图</li></ul></li></ul><h3 id="平滑曲线"><a href="#平滑曲线" class="headerlink" title="平滑曲线"></a>平滑曲线</h3><p>如果散点图中有非常多的数据点，那么数据展示的趋势就不太明显了，这时候，我们可以在图中添加一条平滑曲线。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小数据集-左图</span></span><br><span class="line">qplot(carat, price, data = dsmall, geom = c(<span class="string">"point"</span>, <span class="string">"smooth"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部数据集-右图</span></span><br><span class="line">qplot(carat, price, data = diamonds, geom = c(<span class="string">"point"</span>, <span class="string">"smooth"</span>))</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/平滑曲线-1.png" title="平滑曲线-1"><p>我们可以通过span参数控制曲线的平滑程度。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qplot(carat, price, data = dsmall, geom = c(<span class="string">"point"</span>, <span class="string">"smooth"</span>), span = <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/平滑曲线-2.png" title="平滑曲线-2"><h3 id="箱型图和扰动点图"><a href="#箱型图和扰动点图" class="headerlink" title="箱型图和扰动点图"></a>箱型图和扰动点图</h3><p>当数据集包含了一个分类变量和一个连续变量时，我们可以通过箱型图和扰动点图来看连续变量是如何随着分类变量的变化而变化的。</p><ul><li>扰动点图可以显示所有的点，但是有图形重叠的问题。</li><li>箱型图可以显示出分布的中位数和四分位数，信息更充分。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扰动点图-左图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"jitter"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 箱型图-右图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"boxplot"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/箱型图和扰动点图-1.png" title="箱型图和扰动点图-1"><p>我们可以用半透明度来解决扰动点图的图形重叠问题。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透明度设置为1/5-左图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"jitter"</span>, alpha = I(<span class="number">1</span>/<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透明度设置为1/50-中图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"jitter"</span>, alpha = I(<span class="number">1</span>/<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透明度设置为1/200-右图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"jitter"</span>, alpha = I(<span class="number">1</span>/<span class="number">200</span>))</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/箱型图和扰动点图-2.png" title="箱型图和扰动点图-2"><h3 id="直方图和密度曲线图"><a href="#直方图和密度曲线图" class="headerlink" title="直方图和密度曲线图"></a>直方图和密度曲线图</h3><p>直方图和密度曲线图可以展示单个变量的分布。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直方图-左图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密度曲线图-右图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"density"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/直方图和密度曲线图.png" title="直方图和密度曲线图"><p><strong>在直方图中，应该尝试多种组距。当组距较大时，图形能反映数据的总体特征，当组距较小时，则能显示出更多的细节</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 组距设置为1-左图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>, binwidth = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组距设置为0.1-中图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>, binwidth = <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组距设置为0.01-右图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>, binwidth = <span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/直方图组距对比.png" title="直方图组距对比"><p>如果要对不同组的分布进行对比，只需要再加上一个<strong>图形映射</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 密度图分组对比-左图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"density"</span>, colour = color)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直方图分组对比-右图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>, fill = color)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/直方图和密度图分组对比.png" title="直方图和密度图分组对比"><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><p>条形图几何对象会计算每一个水平下观测的数量，因此无需预先对数据进行汇总。</p><p>下面是钻石颜色的条形图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通条形图（钻石颜色）-左图</span></span><br><span class="line">qplot(color, data = diamonds, geom = <span class="string">"bar"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按重量加权的条形图，即得到的是每种颜色的钻石的总重量-右图</span></span><br><span class="line">qplot(color, data = diamonds, geom = <span class="string">"bar"</span>, weight = carat) + scale_y_continuous(<span class="string">"carat"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/条形图.png" title="条形图"><h3 id="时间序列中的线条图和路径图"><a href="#时间序列中的线条图和路径图" class="headerlink" title="时间序列中的线条图和路径图"></a>时间序列中的线条图和路径图</h3><p>线条图和路径图常用于时间序列的可视化。</p><ul><li>线条图：点从左到右进行连接</li><li>路径图：按照点在数据集中的顺序进行连接</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(economics)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Classes &apos;spec_tbl_df&apos;, &apos;tbl_df&apos;, &apos;tbl&apos; and &apos;data.frame&apos;:574 obs. of  6 variables:</span><br><span class="line"> $ date    : Date, format: &quot;1967-07-01&quot; &quot;1967-08-01&quot; ...</span><br><span class="line"> $ pce     : num  507 510 516 512 517 ...</span><br><span class="line"> $ pop     : num  198712 198911 199113 199311 199498 ...</span><br><span class="line"> $ psavert : num  12.6 12.6 11.9 12.9 12.8 11.8 11.7 12.3 11.7 12.3 ...</span><br><span class="line"> $ uempmed : num  4.5 4.7 4.6 4.9 4.7 4.8 5.1 4.5 4.1 4.6 ...</span><br><span class="line"> $ unemploy: num  2944 2945 2958 3143 3066 ...</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(economics)</span><br></pre></td></tr></table></figure><table><thead><tr><th>date</th><th>pce</th><th>pop</th><th>psavert</th><th>uempmed</th><th>unemploy</th></tr></thead><tbody><tr><td>1967-07-01</td><td>506.7</td><td>198712</td><td>12.6</td><td>4.5</td><td>2944</td></tr><tr><td>1967-08-01</td><td>509.8</td><td>198911</td><td>12.6</td><td>4.7</td><td>2945</td></tr><tr><td>1967-09-01</td><td>515.6</td><td>199113</td><td>11.9</td><td>4.6</td><td>2958</td></tr><tr><td>1967-10-01</td><td>512.2</td><td>199311</td><td>12.9</td><td>4.9</td><td>3143</td></tr><tr><td>1967-11-01</td><td>517.4</td><td>199498</td><td>12.8</td><td>4.7</td><td>3066</td></tr><tr><td>1967-12-01</td><td>525.1</td><td>199657</td><td>11.8</td><td>4.8</td><td>3018</td></tr></tbody></table><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 失业人口的比例-左图</span></span><br><span class="line">qplot(date, unemploy / pop, data = economics, geom = <span class="string">"line"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 失业星期数的中位数-右图</span></span><br><span class="line">qplot(date, uempmed, data = economics, geom = <span class="string">"line"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/时间序列.png" title="时间序列"><h2 id="分面"><a href="#分面" class="headerlink" title="分面"></a>分面</h2><p>比较不同分组可以通过</p><ul><li><strong>图形属性（颜色和形状）</strong>：所有组绘制在同一张图中</li><li><strong>分面</strong>：数据分割成若干子集，然后创建一个图形的矩阵，将每个子集绘制到图形矩阵中</li></ul><p>下面第一张图展示的是频数，第二张图展示的是频率，频率图可以使得比较不同组的分布时不受到该组样本量大小的影响：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 钻石重量的频数（按照颜色分组）-左图</span></span><br><span class="line">qplot(carat, data = diamonds, facets = color ~ ., </span><br><span class="line">      geom = <span class="string">"histogram"</span>, binwidth = <span class="number">0.1</span>, xlim = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 钻石重量的频率（按照颜色分组）-右图</span></span><br><span class="line">qplot(carat, ..density.., data = diamonds, facets = color ~ ., </span><br><span class="line">      geom = <span class="string">"histogram"</span>, binwidth = <span class="number">0.1</span>, xlim = c(<span class="number">0</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/分面.png" title="分面"><p>语法说明：</p><ul><li>我们可以通过<code>row_var ~ col_var</code>的表达式进行指定窗格数。如果想指定一行或一列，可以使用<code>.</code>作为占位符</li><li><code>..density..</code>：这是一个新的语法，告诉ggplot2将密度而不是频数映射到y轴</li></ul><h2 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h2><p>qplot中还有以下选项用于控制图形的外观：</p><ul><li>xlim、ylim：设置x轴和y轴的显示区间。例如：<code>xlim = c(0, 20)</code></li><li>log：一个字符型向量，说明哪个坐标轴应该取对数。例如：<code>log = &quot;xy&quot;</code></li><li>main：图形的主标题，可以是字符串或表达式。例如：<code>main = &quot;plot title&quot;</code>或<code>main = expression(beta[1] == 1)</code></li><li>xlab、ylab：设置x轴和y轴的标签文字，可以是字符串或表达式。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标题、坐标轴标签设置-左图</span></span><br><span class="line">qplot(</span><br><span class="line">    carat, price, data = dsmall, </span><br><span class="line">    xlab = <span class="string">"Price ($)"</span>, ylab = <span class="string">"Weight (carats)"</span>, </span><br><span class="line">    main = <span class="string">"Price-weight relationship"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴设置为对数-右图</span></span><br><span class="line">qplot(carat, price, data = dsmall, log = <span class="string">"xy"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/其他选项.png" title="其他选项"><blockquote><p>本文是《ggplot2-数据分析与图形艺术》的笔记</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;code&gt;qplot()&lt;/code&gt;是ggplot2的一个作图函数，qplot的意思是快速作图（quick plot）。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook中使用R语言</title>
    <link href="https://tding.top/archives/3aa9fd39.html"/>
    <id>https://tding.top/archives/3aa9fd39.html</id>
    <published>2019-12-04T06:40:15.000Z</published>
    <updated>2019-12-04T16:09:41.061Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:00 GMT+0800 (中国标准时间) --><p>既然我们是用R语言来做数据分析，那么就不得不提到Jupyter Notebook。</p><p>Jupyter Notebook是以网页的形式打开，这样我们可以在网页中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示，非常方便直观。如果在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。</p><ul><li>R版本：3.6.1</li><li>Jupyter Notebook版本：1.0.0</li></ul><a id="more"></a><h2 id="Jupyter-Notebook安装"><a href="#Jupyter-Notebook安装" class="headerlink" title="Jupyter Notebook安装"></a>Jupyter Notebook安装</h2><p>安装Jupyter Notebook的前提是需要安装了Python。然后可以通过pip进行安装，cmd中输入：</p><ol><li>升级pip到最新版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>注意：老版本的pip在安装Jupyter Notebook过程中或面临依赖项无法同步安装的问题。因此强烈建议先把pip升级到最新版本。</p><ol start="2"><li>安装Jupyter Notebook</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure><h2 id="运行Jupyter-Notebook"><a href="#运行Jupyter-Notebook" class="headerlink" title="运行Jupyter Notebook"></a>运行Jupyter Notebook</h2><p>直接在终端中输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>执行命令之后，在终端中将会显示一系列notebook的服务器信息，同时浏览器将会自动启动Jupyter Notebook。</p><p>注意：之后在Jupyter Notebook的所有操作，都请保持终端不要关闭，因为一旦关闭终端，就会断开与本地服务器的链接。</p><h2 id="Jupyter-Notebook里添加R核"><a href="#Jupyter-Notebook里添加R核" class="headerlink" title="Jupyter Notebook里添加R核"></a>Jupyter Notebook里添加R核</h2><p>这里需要提前安装好R。</p><ol><li>在R Console中输入</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(c(<span class="string">'repr'</span>, <span class="string">'IRdisplay'</span>, <span class="string">'evaluate'</span>, <span class="string">'crayon'</span>, <span class="string">'pbdZMQ'</span>, <span class="string">'devtools'</span>, <span class="string">'uuid'</span>, <span class="string">'digest'</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li>安装IRkernel包，在R Console中输入</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtools::install_github(<span class="string">'IRkernel/IRkernel'</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>使R在Jupyter Notebook中可以被探测到，在R Console中输入</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRkernel::installspec(user = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p>通过设置<code>user=FALSE</code>安装在系统中，如果缺省，即<code>IRkernel::installspec()</code>，则只在当前用户下安装。</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[InstallKernelSpec] Installed kernelspec ir in C:\ProgramData\jupyter\kernels\ir</span><br></pre></td></tr></table></figure><p>至此，安装完成。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试一下是否安装成功。再次打开jupyter notebook，在<strong>右侧新建的下拉选择</strong>里面出现R，就代表安装成功了。</p><p>至此，Jupyter Notebook里已正确添加R核。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/91365f343585" rel="external nofollow noopener noreferrer" target="_blank">Jupyter Notebook介绍、安装及使用教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:00 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;既然我们是用R语言来做数据分析，那么就不得不提到Jupyter Notebook。&lt;/p&gt;&lt;p&gt;Jupyter Notebook是以网页的形式打开，这样我们可以在网页中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示，非常方便直观。如果在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;R版本：3.6.1&lt;/li&gt;&lt;li&gt;Jupyter Notebook版本：1.0.0&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="环境" scheme="https://tding.top/categories/R/%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="Jupyter Notebook" scheme="https://tding.top/tags/Jupyter-Notebook/"/>
    
  </entry>
  
  <entry>
    <title>VSCode中配置R语言运行环境</title>
    <link href="https://tding.top/archives/eb2dec05.html"/>
    <id>https://tding.top/archives/eb2dec05.html</id>
    <published>2019-12-04T03:30:00.000Z</published>
    <updated>2019-12-05T02:50:16.394Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>在使用R语言的大部分用户中，RStudio都是首选的IDE。凭借其完善的功能和特性，RStudio似乎成了R语言理所当然的选择。不过一些时候，我们可能并不需要特别多的复杂功能，因此，我尝试在VSCode这个轻量级的通用代码编辑器中配置R语言运行环境。</p><a id="more"></a><h2 id="安装R"><a href="#安装R" class="headerlink" title="安装R"></a>安装R</h2><p>首先我们需要安装<a href="https://www.r-project.org/" rel="external nofollow noopener noreferrer" target="_blank">R 核心程序</a>。</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>如果你曾经在VSCode中使用过Python插件，实际上只需要微软出品的这一个插件就差不多可以开始工作了。但作为小众语言，R的插件并不是官方开发，而是由第三方开发者贡献的。这也导致配置一个尚可的R环境需要从四处安装不同的东西，才能开始工作。</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a><a href="https://marketplace.visualstudio.com/items?itemName=Ikuyadeu.r" rel="external nofollow noopener noreferrer" target="_blank">R</a></h3><p>首先，在Visual Studio Code的应用商店中搜索扩展R，然后我们可以按照扩展说明进行配置：</p><blockquote><ul><li>For Windows, set config r.rterm.windows to your R.exe Path like “C:\Program Files\R\R-3.3.4\bin\x64\R.exe”;</li><li>For Radian console, enable config r.bracketedPaste</li><li>Open your folder that has R source file (Can’t work if you open only file)</li><li>Use F1 key and R: command or Ctrl+Enter(Mac: ⌘+Enter)</li></ul></blockquote><p>首先配置R语言的可执行文件位置，也就是<code>R.exe</code>的位置</p><img src="/archives/eb2dec05/配置R语言的可执行文件位置.png" title="配置r语言的可执行文件位置"><p>配置好之后需要重新加载。新建窗口，打开自己编写的 r 文件。</p><ul><li>选中执行是 <code>ctrl + Enter</code></li><li>执行文件是 <code>ctrl + Shift + s</code> 或者 点击右上角的小图标</li></ul><h3 id="R-LSP-Client"><a href="#R-LSP-Client" class="headerlink" title="R LSP Client"></a><a href="https://marketplace.visualstudio.com/items?itemName=REditorSupport.r-lsp" rel="external nofollow noopener noreferrer" target="_blank">R LSP Client</a></h3><p>如果只安装上面这个R插件，很多代码不能自动补全，尤其是来自第三方包的命令。这对强烈依赖第三方包的R简直是致命的。这时就需要安装另外的一个插件：R LSP Client。</p><blockquote><p>LSP 是Language Server Protocol 的缩写。简单来说，LSP 为不同语言在不同编辑器或IDE 中的自动补全、查找定义、悬停查看函数文档等功能搭建了桥梁，使得开发者可以减少针对不同语言和不同编辑器的重复开发。对用户来说，使用这一功能意味着可以获得更好的自动补全、查看帮助文档等特性。</p></blockquote><p><strong>注意：安装了这个插件后，你会发现自动补全依然没有出现。实际上，插件只是在编辑器一侧提供了实现LSP的条件，而在R语言一侧还需要另外的包languageserver来完成搭接</strong>。</p><p>在R环境中运行如下安装指令：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">"languageserver"</span>)</span><br></pre></td></tr></table></figure><p>然后重启一下VSCode，整个LSP的功能就可以实现了。</p><h3 id="radian"><a href="#radian" class="headerlink" title="radian"></a><a href="https://github.com/randy3k/radian" rel="external nofollow noopener noreferrer" target="_blank">radian</a></h3><p>使用R语言很多时候是把编辑器中的代码发送到Console中运行，一些时候也需要直接在Console中运行一些代码进行快速交互。RStudio为Console提供了语法高亮、自动补全等功能的加持，使得在Console中也可以有比较方便的输入输出体验。然而R for VSCode插件默认在Terminal中调用R进程，只会返回朴素的R Console界面，高亮、补全通通不在考虑范围之内。</p><p>radian为这件事提供了新的可能。它给“性冷淡”的R Console 穿上一身华丽的新衣，也增加了自动补全、多行输入等等特殊能力。我们可以把它加入到VSCode中，或是直接在终端中使用它运行R代码。</p><p>radian本身是一个Python项目，所以你需要安装有一个Python环境，然后使用pip安装这个包，直接在终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U radian</span><br></pre></td></tr></table></figure><p>安装完成后，就可以在终端中直接使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radian</span><br></pre></td></tr></table></figure><p>由于radian并不是VSCode插件，它可以独立在终端中运行，但带来的问题就是无法在VSCode中默认调用它。好在R for VSCode插件提供了更换R Console 路径的设置。</p><p>打开VSCode的设置项，找到r的设置。这里有三项相似的设置分别为<code>r.rterm.linux</code>、<code>r.rterm.mac</code>、<code>r.rterm.windows</code>，根据你的系统，找到需要更改的其中一个设置项。但在更改之前，需要知道radian在哪里。比较快捷的方式是在终端中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">where</span> radian</span><br></pre></td></tr></table></figure><p>然后我们将返回的路径粘贴在相应设置的值中。</p><p>但重启VSCode并运行一个R命令会发现VSCode返回一个类似的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">终端进程命令“/Users/caoyue/anaconda3/bin/rtichoke --no-save --no-restore --no-site-file”无法启动 (退出代码: 2)</span><br></pre></td></tr></table></figure><p>因为R for VSCode插件在开启一个R 进程时，默认带入了三个选项<code>--no-save</code>、<code>--no-restore</code>、<code>--no-site-file</code>。然而根据radian作者的说法，radian的<code>--no-save</code>和<code>--no-restore</code>已经作为默认选项故而无法再传入。因此，在设置中关闭<code>--no-save</code>和<code>no-restore</code>两个选项即可。在VSCode 的设置中，找到r设置下的<code>r.rterm.option</code>，将后面不需要的两项注释掉或删掉即可。当然，你也可以在这里使用自定义的选项。</p><p>另外的一个问题是，你可能发现更换掉R Console路径后，LSP 带来的效果不见了。这是因为Lanuage Server指向的路径默认随着R Console 变动，而它无法识别radian。我们通过将选项<code>r.rpath.lsp</code>更改为<code>R.exe</code>的默认路径即可修复该问题。</p><p>到此为止，radian的配置工作结束。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://neusncp.com/user/blog?id=191" rel="external nofollow noopener noreferrer" target="_blank">VS Code中使用R语言扩展的相关配置</a></li><li><a href="https://sspai.com/post/47386" rel="external nofollow noopener noreferrer" target="_blank">在VSCode 中配置R 语言运行环境</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在使用R语言的大部分用户中，RStudio都是首选的IDE。凭借其完善的功能和特性，RStudio似乎成了R语言理所当然的选择。不过一些时候，我们可能并不需要特别多的复杂功能，因此，我尝试在VSCode这个轻量级的通用代码编辑器中配置R语言运行环境。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="环境" scheme="https://tding.top/categories/R/%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="VSCode" scheme="https://tding.top/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题目总结-二叉树</title>
    <link href="https://tding.top/archives/101cdf53.html"/>
    <id>https://tding.top/archives/101cdf53.html</id>
    <published>2019-12-03T16:30:00.000Z</published>
    <updated>2019-12-03T16:30:10.769Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>树是一种以层次化方式组织和存放数据的特定数据结构。</p><p>树有两个主要特征：</p><ul><li>每个项都有多个子节点</li><li>除了叫做根的特殊的项，所有其他的项都只有一个父节点</li></ul><p>二叉树(binary tree)是一种特殊的树结构，它每个节点最多有两个子结点，亦称左孩子和右孩子。</p><p>这里总结了LeetCode中二叉树相关的题目，我把这些题目分成了以下五个部分：</p><ul><li><a href="#二叉树的性质相关题目">二叉树的性质相关题目</a></li><li><a href="#二叉树的遍历相关题目">二叉树的遍历相关题目</a></li><li><a href="#路径和相关题目">路径和相关题目</a></li><li><a href="#二叉树的构建相关题目">二叉树的构建相关题目</a></li><li><a href="#二叉搜索树相关题目">二叉搜索树相关题目</a></li></ul><a id="more"></a><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><p>二叉树的存储结构 TreeNode 为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h2 id="二叉树的性质相关题目"><a href="#二叉树的性质相关题目" class="headerlink" title="二叉树的性质相关题目"></a>二叉树的性质相关题目</h2><p>树的性质判断是树的数据结构比较基本的操作。</p><ul><li><a href="100-相同的树">100-相同的树</a></li><li><a href="#101-对称二叉树">101-对称二叉树</a></li><li><a href="#110-平衡二叉树">110-平衡二叉树</a></li><li><a href="#104-二叉树的最大深度">104-二叉树的最大深度</a></li><li><a href="#111-二叉树的最小深度">111-二叉树的最小深度</a></li><li><a href="#662-二叉树最大宽度">662-二叉树最大宽度</a></li></ul><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100-相同的树"></a>100-相同的树</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法1：递归</p><p>终止条件与返回值：</p><ul><li>当两棵树的当前节点都为 null 时返回 true</li><li>当其中一个为 null 另一个不为 null 时返回 false</li><li>当两个都不为空但是值不相等时，返回 false</li></ul><p>执行过程：当满足终止条件时进行返回，不满足时分别判断左子树和右子树是否相同，其中要注意代码中的短路效应。</p><p>下面是一个图解：</p><img src="/archives/101cdf53/100-1.png" title="相同的树-1"> <img src="/archives/101cdf53/100-2.png" title="相同的树-2"> <img src="/archives/101cdf53/100-3.png" title="相同的树-3"><p>方法2：迭代</p><p>首先用一个栈来保存根节点p，q。接着不断遍历这个栈。</p><ol><li><p>我们从栈中拿出两个元素进行比较，如果这两个元素不等(一个是空一个不为空，或者两个节点的值不等)，就直接返回false。</p></li><li><p>如果这两个节点的值相等，就继续把p节点的左孩子,q节点的左孩子放入栈中；再把p节点的右孩子，q节点的右孩子放入栈中。</p></li></ol><p>重复这个步骤，直到栈为空。</p><p>如果整个循环遍历完了，说明两个树的元素都是相等的，返回true。</p><blockquote><p><a href="https://leetcode-cn.com/problems/same-tree/solution/hua-jie-suan-fa-100-xiang-tong-de-shu-by-guanpengc/" rel="external nofollow noopener noreferrer" target="_blank">画解算法：100. 相同的树</a></p></blockquote><h4 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">or</span> q == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br></pre></td></tr></table></figure><p>方法2：迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append((p,q))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            p,q = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> p == <span class="keyword">None</span> <span class="keyword">or</span> q == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">elif</span> p.val != q.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">elif</span> p.val == q.val:</span><br><span class="line">                stack.append((p.left,q.left))</span><br><span class="line">                stack.append((p.right,q.right))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101-对称二叉树"></a>101-对称二叉树</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p>说明：如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p><p>如果同时满足下面的条件，两个树互为镜像：</p><ul><li>它们的两个根结点具有相同的值。</li><li>每个树的右子树都与另一个树的左子树镜像对称。</li></ul><img src="/archives/101cdf53/101-1.png" title="对称二叉树-1"><h4 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.isMirror(root.left,root.right)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMirror</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="keyword">None</span> <span class="keyword">and</span> t2 == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="keyword">None</span> <span class="keyword">or</span> t2 == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> t1 != <span class="keyword">None</span> <span class="keyword">and</span> t2 != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> t1.val == t2.val:</span><br><span class="line">                <span class="keyword">return</span> self.isMirror(t1.left,t2.right) <span class="keyword">and</span> self.isMirror(t1.right,t2.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110-平衡二叉树"></a>110-平衡二叉树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>方法1：自顶向下暴力递归</p><p>构造一个获取当前节点最大深度的方法 <code>depth()</code> ，通过比较左右子树最大高度差<code>abs(self.depth(root.left) - self.depth(root.right))</code>，来判断以此节点为根节点下是否是二叉平衡树；</p><ul><li>从顶至底DFS，以每个节点为根节点，递归判断是否是平衡二叉树：<ul><li>若所有根节点都满足平衡二叉树性质，则返回 True ；</li><li>若其中任何一个节点作为根节点时，不满足平衡二叉树性质，则返回False。</li></ul></li></ul><p>本方法产生大量重复的节点访问和计算，最差情况下时间复杂度 <code>O(N^2)</code>。</p><p>方法2：自底向上（提前阻断）</p><p>对二叉树做深度优先遍历DFS，递归过程中：</p><ul><li>终止条件：当DFS越过叶子节点时，返回高度0；</li><li>返回值：<ul><li>从底至顶，返回以每个节点root为根节点的子树最大高度（左右子树中最大的高度值加1，即<code>max(left,right) + 1)</code>）</li><li>当我们发现有一例 左/右子树高度差 ＞ 1 的情况时，代表此树不是平衡树，返回-1</li><li><strong>当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算</strong>。</li></ul></li></ul><p>最差情况是对树做一遍完整DFS，时间复杂度为 O(N)。</p><h4 id="Python实现-2"><a href="#Python实现-2" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点满足平衡树，继续递归判断子树是否满足平衡树条件</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.depth(root.left)-self.depth(root.right)) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算树高度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="keyword">None</span> <span class="keyword">or</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(self.depth(root.left),self.depth(root.right))</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> self.depth(root) == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        depth_left = self.depth(root.left)</span><br><span class="line">        <span class="comment"># 提前阻断</span></span><br><span class="line">        <span class="keyword">if</span> depth_left == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        depth_right = self.depth(root.right)</span><br><span class="line">        <span class="comment"># 提前阻断</span></span><br><span class="line">        <span class="keyword">if</span> depth_right == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> abs(depth_left-depth_right) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(depth_left,depth_right)</span><br><span class="line">        <span class="comment"># 提前阻断</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104-二叉树的最大深度"></a>104-二叉树的最大深度</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例：给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>方法1：迭代</p><p>层次遍历二叉树，如果树为空，直接返回0。否则将树和深度值1入队列，逐一弹出队列中节点：</p><ul><li>若某节点左右子树均为空，此节点即为叶子节点，我们将它的深度和最大深度<code>max_depth</code>进行比较，更新最大深度。</li><li>若其存在子树，则将其存在的子树和子树深度入队列。</li></ul><p>方法2：递归</p><p>递归结束条件：</p><ul><li>当 root 节点左右孩子都为空（叶子节点）时，返回 1</li><li>当 root 节点左右孩子至少有一个不为空时，返回左右孩子较大深度的节点值</li></ul><h4 id="Python实现-3"><a href="#Python实现-3" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        queue = [(root,<span class="number">1</span>)]</span><br><span class="line">        max_depth = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node,depth = queue.pop(<span class="number">0</span>)</span><br><span class="line">            max_depth = max(max_depth,depth)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                queue.append((node.left,depth+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                queue.append((node.right,depth+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_depth</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 叶子节点，返回1</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左右孩子至少有一个不为空时，返回左右孩子较大深度的节点值</span></span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="keyword">None</span> <span class="keyword">or</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(self.maxDepth(root.left),self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111-二叉树的最小深度"></a>111-二叉树的最小深度</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：给定二叉树<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最小深度2.</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>方法1：迭代</p><p>层次遍历二叉树，如果树为空，直接返回0。否则将树和深度值1入队列，逐一弹出队列中节点：</p><ul><li>若某节点左右子树均为空，此节点即为叶子节点，我们将它的深度和最小深度<code>min_depth</code>进行比较，更新最小深度。</li><li>若其存在子树，则将其存在的子树和子树深度入队列。</li></ul><p>实际上，因为层次遍历是一层一层遍历的，所以<strong>第一个叶子节点即为最小深度的叶子节点</strong>，直接返回其深度即可。这样就不用遍历所有的节点。</p><p>方法2：递归</p><p>递归解法的关键是搞清楚递归结束条件：</p><ul><li>当 root 节点左右孩子都为空（叶子节点）时，返回 1</li><li>当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度</li><li>当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值</li></ul><h4 id="Python实现-4"><a href="#Python实现-4" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      </span><br><span class="line">        queue = [(root,<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node,depth = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="keyword">None</span> <span class="keyword">and</span> node.right == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                queue.append((node.left,depth+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                queue.append((node.right,depth+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 叶子节点，返回1</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左右孩子有一个为空时，返回不为空的孩子节点的深度</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">or</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(self.minDepth(root.left),self.minDepth(root.right))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左右孩子都不为空时，返回左右孩子较小深度的节点值</span></span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="keyword">None</span> <span class="keyword">and</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+min(self.minDepth(root.left),self.minDepth(root.right))</span><br></pre></td></tr></table></figure><h3 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662-二叉树最大宽度"></a>662-二叉树最大宽度</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与<strong>满二叉树</strong>（full binary tree）结构相同，但一些节点为空。</p><p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">           1</span><br><span class="line">         /   \</span><br><span class="line">        3     2</span><br><span class="line">       / \     \  </span><br><span class="line">      5   3     9 </span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         /  </span><br><span class="line">        3    </span><br><span class="line">       / \       </span><br><span class="line">      5   3     </span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line">解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        3   2 </span><br><span class="line">       /        </span><br><span class="line">      5      </span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line">解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        3   2</span><br><span class="line">       /     \  </span><br><span class="line">      5       9 </span><br><span class="line">     /         \</span><br><span class="line">    6           7</span><br><span class="line">输出: 8</span><br><span class="line">解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。</span><br></pre></td></tr></table></figure><p>注意: 答案在32位有符号整数的表示范围内。</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>因为两端点间的None值也计入，所以这里我们不能简单的统计每一层的节点数，这里我们可以考虑给<strong>树中的每一个节点进行编号</strong>，根节点为1，然后如果是左节点，值为根节点的二倍；如果是右节点，值为根节点的二倍加一。</p><p>这里我用层次遍历，采用一个队列记录每一个节点的节点以及号码，一层的首末元素的编号差就是该层的最大宽度。</p><h4 id="Python实现-5"><a href="#Python实现-5" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">widthOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        queue = [(root,<span class="number">1</span>)]</span><br><span class="line">        width = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            length = len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">                node,nums = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 记录该层第一个节点的编号、最后一个节点的编号</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    first_num = nums</span><br><span class="line">                <span class="keyword">if</span> i == length<span class="number">-1</span>:</span><br><span class="line">                    last_num = nums</span><br><span class="line">                    <span class="comment"># 更新最大宽度</span></span><br><span class="line">                    width = max(width,last_num-first_num+<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 左右子树入队</span></span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append((node.left,<span class="number">2</span>*nums))</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append((node.right,<span class="number">2</span>*nums+<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> width</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历相关题目"><a href="#二叉树的遍历相关题目" class="headerlink" title="二叉树的遍历相关题目"></a>二叉树的遍历相关题目</h2><p>遍历的含义就是把树的所有节点（Node）按照某种顺序访问一遍。包括前序，中序，后序，层序4种遍历方法。</p><ol><li>以图的深度优先搜索为原型的遍历</li></ol><ul><li><a href="#144-二叉树的前序遍历">144-二叉树的前序遍历</a></li><li><a href="#94-二叉树的中序遍历">94-二叉树的中序遍历</a></li><li><a href="#145-二叉树的后序遍历">145-二叉树的后序遍历</a></li></ul><p>在这种类型中，递归的实现方式是非常简单的，只需要递归左右结点，直到结点为空作为结束条件就可以，哪种序就取决于你访问结点的时间。</p><p>不过一般这不能满足面试官的要求，可能会接着问能不能用非递归实现一下，这个说起来比较简单，其实就是用一个栈手动模拟递归的过程。</p><p>有时候非递归还是不能满足面试官，还会问一问，上面的做法时间和空间复杂度是多少。我们知道，正常遍历时间复杂度是<code>O(n)</code>，而空间复杂度是则是递归栈（或者自己维护的栈）的大小，也就是<code>O(logn)</code>。他会问能不能够在常量空间内解决树的遍历问题呢？确实还真可以，这里就要介绍一下Morris遍历。</p><blockquote><p>Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。这样就节省了需要用栈来记录前驱或者后继结点的额外空间，所以可以达到<code>O(1)</code>的空间复杂度。不过这种方法有一个问题就是会暂时性的改动树的结构，这在程序设计中并不是很好的习惯，这些在面试中都可以和面试官讨论，一般来说问到这里不会需要进行Morris遍历方法的代码实现了，只需要知道这种方法和他的主要优劣势就可以了。</p></blockquote><ol start="2"><li>以图的广度优先搜索为原型的遍历，在树中称为层序遍历，LeetCode中有三种：自顶向下层序、自底向上层序、锯齿层序遍历。</li></ol><ul><li><a href="#102-二叉树的层次遍历">102-二叉树的层次遍历</a></li><li><a href="#103-二叉树的锯齿形层次遍历">103-二叉树的锯齿形层次遍历</a></li><li><a href="#107-二叉树的层次遍历ii">107-二叉树的层次遍历ii</a></li></ul><p><strong>自顶向下层序遍历</strong>其实比较简单，代码基本就是图的广度优先搜索，思路就是维护一个<strong>队列</strong>存储上一层的结点，逐层访问。而<strong>自底向上层序层序遍历</strong>则要从最后一层倒序访问上来，这个我没有想到太好的方法，现在的实现就是把自顶向下层序遍历得到的层放入数据结构然后reverse过来。至于<strong>锯齿层序遍历</strong>因为每一层访问顺序有所改变，而且是每次都反转顺序，这让我们想到<strong>栈</strong>这个数据结构，所以这里不用队列而改用栈来保存，就可以满足每层反转访问顺序的要求了。</p><p>层次遍历相关的题目：</p><ul><li><a href="#116-填充每个节点的下一个右侧节点指针">116-填充每个节点的下一个右侧节点指针</a></li><li><a href="#117-填充每个节点的下一个右侧节点指针ii">117-填充每个节点的下一个右侧节点指针ii</a></li><li>513-找树左下角的值</li><li>515-在每个树行中找最大值</li></ul><h3 id="详细题解"><a href="#详细题解" class="headerlink" title="详细题解"></a>详细题解</h3><ul><li><a href="https://tding.top/archives/5f8aadd1.html">LeetCode 题目总结 - 二叉搜索树</a></li></ul><h2 id="路径和相关题目"><a href="#路径和相关题目" class="headerlink" title="路径和相关题目"></a>路径和相关题目</h2><p>树的求和属于树的题目中比较常见的，因为可以有几种变体，灵活度比较高，也可以考察到对于树的数据结构和递归的理解。</p><ul><li><a href="#112-路径总和">112-路径总和</a></li><li><a href="#113-路径总和ii">113-路径总和ii</a></li><li>124-二叉树中的最大路径和</li><li><a href="#129-求根到叶子节点数字之和">129-求根到叶子节点数字之和</a></li><li><a href="#257-二叉树的所有路径">257-二叉树的所有路径</a></li></ul><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112-路径总和"></a>112-路径总和</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>这道题是判断是否存在从根到叶子的路径和跟给定sum相同。树的题目基本都是用递归来解决，主要考虑两个问题：</p><ol><li>如何把问题分治成子问题给左子树和右子树。这里就是看看左子树和右子树有没有存在和等于sum减去当前结点值的路径，只要有一个存在，那么当前结点就存在路径。</li><li>考虑结束条件是什么：<ul><li>结束条件1：如果当前节点是空的，则返回false。</li><li>结束条件2：如果是叶子，那么如果剩余的sum等于当前叶子的值，则找到满足条件的路径，返回true。</li></ul></li></ol><p>想清楚上面两个问题，那么实现起来就是一次树的遍历，按照刚才的分析用参数或者返回值传递需要维护的值，然后按照<strong>递归条件</strong>和<strong>结束条件</strong>进行返回即可。算法的时间复杂度是一次遍历<code>O(n)</code>，空间复杂度是栈的大小<code>O(logn)</code>。</p><h4 id="Python实现——递归"><a href="#Python实现——递归" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点是叶子，检查 root.val 值是否为 sum</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span> <span class="keyword">and</span> root.val == sum:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum() 函数</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left,sum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,sum-root.val)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：我们访问每个节点一次，时间复杂度为 <code>O(N)</code> ，其中 N 是节点个数。</li><li>空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 <code>O(N)</code>。但在最好情况下，树是完全平衡的，高度只有 <code>log(N)</code>，因此在这种情况下空间复杂度只有 <code>O(log(N))</code> 。</li></ul><h4 id="Python实现——迭代"><a href="#Python实现——迭代" class="headerlink" title="Python实现——迭代"></a>Python实现——迭代</h4><p>我们可以用栈将递归转成迭代的形式。</p><p>栈中保存<strong>当前节点前的剩余值</strong>就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        stack = [(root,sum)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node,sum = stack.pop()</span><br><span class="line">            <span class="comment"># 判断叶子节点是否满足了条件</span></span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="keyword">None</span> <span class="keyword">and</span> node.right == <span class="keyword">None</span> <span class="keyword">and</span> node.val == sum:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 左节点不为空，我们把左节点和剩余值打包压栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                stack.append((node.left,sum-node.val))</span><br><span class="line">            <span class="comment"># 右节点不为空，我们把右节点和剩余值打包压栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                stack.append((node.right,sum-node.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="113-路径总和ii"><a href="#113-路径总和ii" class="headerlink" title="113-路径总和ii"></a>113-路径总和ii</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p>返回:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>这道题思路和<strong>112-路径总和</strong>是完全一样的，只是需要输出所有路径，所以需要数据结构来维护路径，添加两个参数，一个用来维护走到当前结点的路径，一个用来保存满足条件的所有路径，思路上递归条件和结束条件是完全一致的，空间上这里会依赖于结果的数量了。</p><h4 id="Python实现——递归-1"><a href="#Python实现——递归-1" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 辅助函数（因为需要一个变量记录路径）       </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, sum, temp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 路径和满足sum，路径添加到结果数组res</span></span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span> <span class="keyword">and</span> root.val == sum:</span><br><span class="line">                temp += [root.val]</span><br><span class="line">                res.append(temp)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归搜索左右子树，传入剩余和以及路径</span></span><br><span class="line">            helper(root.left,sum-root.val,temp+[root.val])</span><br><span class="line">            helper(root.right,sum-root.val,temp+[root.val])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root,sum,[])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="Python实现——迭代-1"><a href="#Python实现——迭代-1" class="headerlink" title="Python实现——迭代"></a>Python实现——迭代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        temp = []</span><br><span class="line">        stack = [(root,sum,temp)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node,sum,temp = stack.pop()</span><br><span class="line">            <span class="comment"># 判断叶子节点是否满足了条件</span></span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="keyword">None</span> <span class="keyword">and</span> node.right == <span class="keyword">None</span> <span class="keyword">and</span> node.val == sum:</span><br><span class="line">                temp += [node.val]</span><br><span class="line">                res.append(temp)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                stack.append((node.left,sum-node.val,temp + [node.val]))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                stack.append((node.right,sum-node.val,temp + [node.val]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129-求根到叶子节点数字之和"></a>129-求根到叶子节点数字之和</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13.</span><br><span class="line">因此，数字总和 = 12 + 13 = 25.</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">输出: 1026</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40.</span><br><span class="line">因此，数字总和 = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>这道题目相比<strong>112-路径总和</strong>，增加了两个变化：</p><ol><li>每一个结点相当于位上的值。我们只需要每一层乘以10加上自己的值就可以了。</li><li>所有路径需要累加起来。我们只需要在最后对结果列表进行求和即可。</li></ol><h4 id="Python实现——递归-2"><a href="#Python实现——递归-2" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, nums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新路径和</span></span><br><span class="line">            nums *= <span class="number">10</span></span><br><span class="line">            nums += root.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果已经是叶子节点，保存路径和到列表中</span></span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">                res.append(nums)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">                helper(root.left,nums)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">                helper(root.right,nums)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        helper(root,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(res)</span><br></pre></td></tr></table></figure><h4 id="Python实现——迭代-2"><a href="#Python实现——迭代-2" class="headerlink" title="Python实现——迭代"></a>Python实现——迭代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        stack = [(root,<span class="number">0</span>)]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node,nums = stack.pop()</span><br><span class="line">            <span class="comment"># 更新路径和</span></span><br><span class="line">            nums *= <span class="number">10</span></span><br><span class="line">            nums += node.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果已经是叶子节点，保存路径和到列表中</span></span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="keyword">None</span> <span class="keyword">and</span> node.right == <span class="keyword">None</span>:</span><br><span class="line">                res.append(nums)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                stack.append((node.left,nums))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                stack.append((node.right,nums))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(res)</span><br></pre></td></tr></table></figure><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257-二叉树的所有路径"></a>257-二叉树的所有路径</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是一个叶子节点，则将它对应的路径加入到答案中。如果它不是一个叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时，迭代结束。</p><h4 id="Python实现-6"><a href="#Python实现-6" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        queue = [(root,<span class="string">''</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            temp = <span class="string">''</span></span><br><span class="line">            length = len(queue)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                node,temp = queue.pop(<span class="number">0</span>)</span><br><span class="line">                temp += str(node.val)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果是叶子节点，记录路径</span></span><br><span class="line">                <span class="keyword">if</span> node.left == <span class="keyword">None</span> <span class="keyword">and</span> node.right == <span class="keyword">None</span>:    </span><br><span class="line">                    res.append(temp)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 格式要求</span></span><br><span class="line">                temp += <span class="string">'-&gt;'</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append((node.left,temp))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append((node.right,temp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="二叉树的构建相关题目"><a href="#二叉树的构建相关题目" class="headerlink" title="二叉树的构建相关题目"></a>二叉树的构建相关题目</h2><p>这类题目本质还是用递归的手法来实现，但是这类题目有一个特点，就是它是构建一棵树，而不是给定一棵树，然后进行遍历，所以实现起来思路上有点逆向。</p><ul><li><a href="#105-从前序与中序遍历序列构造二叉树">105-从前序与中序遍历序列构造二叉树</a></li><li><a href="#106-从中序与后序遍历序列构造二叉树">106-从中序与后序遍历序列构造二叉树</a></li><li><a href="#108-将有序数组转换为二叉搜索树">108-将有序数组转换为二叉搜索树</a></li><li><a href="#109-有序链表转换二叉搜索树">109-有序链表转换二叉搜索树</a></li></ul><p>思路就是在递归中创建根节点，然后找到将元素劈成左右子树的方法，递归得到左右根节点，接上创建的根然后返回。方法还是比较具有模板型的。</p><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105-从前序与中序遍历序列构造二叉树"></a>105-从前序与中序遍历序列构造二叉树</h3><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:你可以假设树中没有重复的元素。</p><p>例如，给出</p><ul><li>前序遍历 <code>preorder = [3,9,20,15,7]</code></li><li>中序遍历 <code>inorder = [9,3,15,20,7]</code></li></ul><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>前序遍历数组的第1个数（索引为0）的数一定是二叉树的根结点，于是可以在中序遍历中找这个根结点的索引，然后把“前序遍历数组”和“中序遍历数组”分为两个部分，就分别对应二叉树的左子树和右子树，分别递归完成就可以了。</p><img src="/archives/101cdf53/105-1.png" title="从前序与中序遍历序列构造二叉树-1"><p>下面是一个具体的例子，演示了如何计算数组子区间的边界：<br><img src="/archives/101cdf53/105-2.png" title="从前序与中序遍历序列构造二叉树-2"></p><blockquote><ul><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/" rel="external nofollow noopener noreferrer" target="_blank">分治法（Python 代码、Java 代码）</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/shi-yong-map-by-powcai/" rel="external nofollow noopener noreferrer" target="_blank">使用 map</a></li></ul></blockquote><h4 id="Python实现——递归-3"><a href="#Python实现——递归-3" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        mid = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归构造左子树、右子树</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:mid+<span class="number">1</span>],inorder[<span class="number">0</span>:mid])</span><br><span class="line">        root.right = self.buildTree(preorder[mid+<span class="number">1</span>:],inorder[mid+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N^2)，这里 N 是二叉树的结点个数，每调用一次递归方法创建一个结点，一共创建 N 个结点，在中序遍历中找到根结点在中序遍历中的位置，是与 N 相关的，这里不计算递归方法占用的时间。</li><li>空间复杂度：O(1)，这里不计算递归方法占用的空间。</li></ul><h4 id="Python实现——哈希表优化"><a href="#Python实现——哈希表优化" class="headerlink" title="Python实现——哈希表优化"></a>Python实现——哈希表优化</h4><p>我们可以用哈希表（字典）来存储中序遍历，这样就可以在<code>O(1)</code>时间复杂度下找到根结点在中序遍历数组中的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 哈希表存储中序遍历的值、索引</span></span><br><span class="line">        dicts = &#123;var:i <span class="keyword">for</span> i,var <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">        index = dicts[preorder[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归构造左子树、右子树</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:index+<span class="number">1</span>],inorder[:index])</span><br><span class="line">        root.right = self.buildTree(preorder[index+<span class="number">1</span>:],inorder[index+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>上面的代码在递归函数里面建立哈希表，这会导致<strong>哈希表一共建立二叉树节点个数次（即N次）</strong>，没有达到我们的优化目的，我们希望的是哈希表仅仅建立一次，后续递归中每次都能有直接调用。下面是优化后的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 辅助函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(pre_left,pre_right,in_left,in_right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> pre_left == pre_right:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建当前“根”</span></span><br><span class="line">            root = TreeNode(preorder[pre_left])</span><br><span class="line">            <span class="comment"># 从哈希表中找到当前“根”的索引</span></span><br><span class="line">            index = dicts[preorder[pre_left]]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新前序遍历、中序遍历边界，然后递归构建左右子树</span></span><br><span class="line">            <span class="comment"># 我们可以通过“前序和中序个数是相同”这个隐含条件，求出前序左右边界</span></span><br><span class="line">            root.left = helper(pre_left+<span class="number">1</span>,pre_left+<span class="number">1</span>+index-in_left,in_left,index)</span><br><span class="line">            <span class="comment"># 根据上面用过的，写出剩下的</span></span><br><span class="line">            root.right = helper(pre_left+<span class="number">1</span>+index-in_left,pre_right,index+<span class="number">1</span>,in_right)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 哈希表存储中序遍历的值、索引</span></span><br><span class="line">        dicts = &#123;var:i <span class="keyword">for</span> i,var <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用辅助函数</span></span><br><span class="line">        root = helper(<span class="number">0</span>,len(preorder),<span class="number">0</span>,len(inorder))</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106-从中序与后序遍历序列构造二叉树"></a>106-从中序与后序遍历序列构造二叉树</h3><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意：你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>这道题目类似<strong>105题</strong>。</p><p>下面是一个图解：</p><img src="/archives/101cdf53/106-1.png" title="从中序与后序遍历序列构造二叉树-1"><blockquote><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-bian-li-python-dai-ma-java-dai-ma-by-liwe-2/" rel="external nofollow noopener noreferrer" target="_blank">分治法（Python、Java）</a></p></blockquote><h4 id="Python实现——递归-4"><a href="#Python实现——递归-4" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(postorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 后序遍历的最后一个结点就是根结点</span></span><br><span class="line">        root = TreeNode(postorder[<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 在中序遍历中找到根结点的索引，得到左右子树的一个划分</span></span><br><span class="line">        mid = inorder.index(postorder[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里的列表切片使用的是复制值，使用了一些空间，因此空间复杂度是 O(N)</span></span><br><span class="line">        root.left = self.buildTree(inorder[:mid],postorder[:mid])</span><br><span class="line">        root.right = self.buildTree(inorder[mid+<span class="number">1</span>:],postorder[mid:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="Python实现——哈希表优化-1"><a href="#Python实现——哈希表优化-1" class="headerlink" title="Python实现——哈希表优化"></a>Python实现——哈希表优化</h4><p>同样的，我们可以把中序遍历的值和索引放在一个哈希表中，这样就不需要通过遍历得到当前根结点在中序遍历中的位置了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 辅助函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(in_left,in_right,post_left,post_right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> in_left == in_right:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建当前“根”</span></span><br><span class="line">            root = TreeNode(postorder[post_right<span class="number">-1</span>])</span><br><span class="line">            <span class="comment"># 从哈希表中找到当前“根”的索引</span></span><br><span class="line">            index = dicts[postorder[post_right<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新中序遍历、后序遍历边界，然后递归构建左右子树</span></span><br><span class="line">            <span class="comment"># 我们可以通过“中序和后序个数是相同”这个隐含条件，求出后序左右边界</span></span><br><span class="line">            root.left = helper(in_left,index,post_left,post_right<span class="number">-1</span>-(in_right-index<span class="number">-1</span>))</span><br><span class="line">            root.right = helper(index+<span class="number">1</span>,in_right,post_right<span class="number">-1</span>-(in_right-index<span class="number">-1</span>),post_right<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 哈希表存储中序遍历的值、索引</span></span><br><span class="line">        dicts = &#123;var:i <span class="keyword">for</span> i,var <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用辅助函数</span></span><br><span class="line">        root = helper(<span class="number">0</span>,len(inorder),<span class="number">0</span>,len(postorder))</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108-将有序数组转换为二叉搜索树"></a>108-将有序数组转换为二叉搜索树</h3><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个按照升序排列的有序数组，转换为一棵<strong>高度平衡二叉搜索树</strong>。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定有序数组: <code>[-10,-3,0,5,9]</code>，一个可能的答案是：<code>[0,-3,9,-10,null,5]</code>，它可以表示下面这个高度平衡二叉搜索树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>二叉搜索树的中序遍历刚好可以输出一个升序数组，所以题目给出的升序数组就是二叉搜索树的中序遍历。</p><p>根据中序遍历还原一颗树，又想到了 105 题 和 106 题，通过中序遍历加前序遍历或者中序遍历加后序遍历来还原一棵树。前序（后序）遍历的作用呢？提供根节点！然后根据根节点，就可以递归的生成左右子树。</p><p>这里的话怎么知道根节点呢？平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。</p><h4 id="Python实现-7"><a href="#Python实现-7" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.binarySearch(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        <span class="comment"># 递归构建左右子树</span></span><br><span class="line">        root.left = self.binarySearch(nums, left, mid<span class="number">-1</span>)</span><br><span class="line">        root.right = self.binarySearch(nums, mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109-有序链表转换二叉搜索树"></a>109-有序链表转换二叉搜索树</h3><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个<strong>单链表</strong>，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定的有序链表：<code>[-10, -3, 0, 5, 9]</code>，一个可能的答案是：<code>[0, -3, 9, -10, null, 5]</code>, 它可以表示下面这个高度平衡二叉搜索树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>这道题目跟108题是类似的，数组可以很方便的找到中点，但链表的特性导致我们无法像数组那样通过下标访问各个元素。若想按照108题的做法，就需要设置两个指针slow、fast，slow每走一步fast走两步，这样fast结束时slow就在中点。<strong>但这样会导致每次递归都需要重复遍历链表，效率较低</strong>。</p><p>注意：当找到链表中的中间元素后，我们将<strong>链表从中间元素的左侧断开</strong>，做法是slow指针初始指向dummy，最后<code>slow.next</code>才是中点，然后我们在中点的左侧断开，也就是<code>slow.next = None</code>。</p><h4 id="Python实现——二分"><a href="#Python实现——二分" class="headerlink" title="Python实现——二分"></a>Python实现——二分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链表寻找中点</span></span><br><span class="line">        <span class="comment"># 为了保证保留左子树的右边界，这里设置slow=dummy而不是head</span></span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line"></span><br><span class="line">        slow = dummy</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast.next != <span class="keyword">None</span> <span class="keyword">and</span> fast.next.next != <span class="keyword">None</span>:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 由于slow初始值为dummy，因此slow.next才为中点</span></span><br><span class="line">        root = TreeNode(slow.next.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链表从中间断开（左子树的右边界是中点的左边一个节点，右子树的左边界是中点的右边一个节点）</span></span><br><span class="line">        mid = slow.next.next</span><br><span class="line">        slow.next = <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归构建左右子树</span></span><br><span class="line">        <span class="comment"># 判断左子树是否为空</span></span><br><span class="line">        <span class="keyword">if</span> slow == dummy:</span><br><span class="line">            root.left = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.left = self.sortedListToBST(dummy.next)</span><br><span class="line">        root.right = self.sortedListToBST(mid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="Python实现——链表转换数组-二分"><a href="#Python实现——链表转换数组-二分" class="headerlink" title="Python实现——链表转换数组+二分"></a>Python实现——链表转换数组+二分</h4><p>在这个方法中，我们将给定的链表转成数组并利用数组来构建二叉搜索树。数组找中间元素只需要 O(1) 的时间，所以会降低整个算法的时间复杂度开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 链表转换成数组</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.binarySearch(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 辅助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归构建左右子树</span></span><br><span class="line">        root.left = self.binarySearch(nums,left,mid<span class="number">-1</span>)</span><br><span class="line">        root.right = self.binarySearch(nums,mid+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树相关题目"><a href="#二叉搜索树相关题目" class="headerlink" title="二叉搜索树相关题目"></a>二叉搜索树相关题目</h2><p>二叉查找树既是一颗树，又带有特别的有序性质，所以考察的方式比较多而且灵活，属于面试题目中的常客。</p><p>此部分详细题解见：</p><ul><li><a href="https://tding.top/archives/5f8aadd1.html">LeetCode 题目总结 - 二叉搜索树</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5d9f0b9551882509165ff2a8" rel="external nofollow noopener noreferrer" target="_blank">LeetCode 前1000题二叉树题目系统总结（吐血推荐！）</a></li><li><a href="https://www.jianshu.com/p/77ad56b9f128" rel="external nofollow noopener noreferrer" target="_blank">LeetCode二叉树(Tree)小结</a></li><li><a href="http://www.jintiankansha.me/t/4EJM5iEhVB" rel="external nofollow noopener noreferrer" target="_blank">LeetCode 总结 - 搞定 Binary Tree 面试题</a></li><li><a href="http://interviewsource.blogspot.com/2016/09/blog-post.html" rel="external nofollow noopener noreferrer" target="_blank">LeetCode总结 – 树</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;树是一种以层次化方式组织和存放数据的特定数据结构。&lt;/p&gt;&lt;p&gt;树有两个主要特征：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每个项都有多个子节点&lt;/li&gt;&lt;li&gt;除了叫做根的特殊的项，所有其他的项都只有一个父节点&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;二叉树(binary tree)是一种特殊的树结构，它每个节点最多有两个子结点，亦称左孩子和右孩子。&lt;/p&gt;&lt;p&gt;这里总结了LeetCode中二叉树相关的题目，我把这些题目分成了以下五个部分：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#二叉树的性质相关题目&quot;&gt;二叉树的性质相关题目&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#二叉树的遍历相关题目&quot;&gt;二叉树的遍历相关题目&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#路径和相关题目&quot;&gt;路径和相关题目&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#二叉树的构建相关题目&quot;&gt;二叉树的构建相关题目&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#二叉搜索树相关题目&quot;&gt;二叉搜索树相关题目&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="https://tding.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="LeetCode" scheme="https://tding.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://tding.top/tags/LeetCode/"/>
    
      <category term="二叉树" scheme="https://tding.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Google搜索技巧</title>
    <link href="https://tding.top/archives/b1453574.html"/>
    <id>https://tding.top/archives/b1453574.html</id>
    <published>2019-12-03T12:20:00.000Z</published>
    <updated>2019-12-03T13:32:17.500Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:00 GMT+0800 (中国标准时间) --><p>我们在日常生活中利用Google搜索的一些技巧可以更加高效的找到我们需要的信息。</p><a id="more"></a><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>谷歌的默认搜索是<strong>and逻辑</strong>，我们在输入关键字后进行搜索时，如输入：<code>program google</code>后，会搜出包含<code>program</code>和<code>google</code>的文件内容。</p><h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><p>如果你想搜索两个中的任意一个，那么就要使用关键词<strong>OR</strong>。</p><p>注意：OR是大写的，小写是不起作用的，而且，每一个关键词与<strong>OR</strong>之间是有一个空格的。</p><h3 id="短语搜索"><a href="#短语搜索" class="headerlink" title="短语搜索"></a>短语搜索</h3><p>如果你希望搜索<code>“program google”</code>的内容，而不希望这两个单词之间有任何其他的内容，那么就要使用双引号把搜索的内容组成一个词组来达到目的。</p><h3 id="“-”"><a href="#“-”" class="headerlink" title="“-”"></a>“-”</h3><p>如果我们只想看到<code>program</code>的内容，而不希望看到<code>google</code>的内容，就可以把<code>-</code>（减号或者破折号）应用到搜索当中去，语法为<code>program -google</code>。</p><p>注意：<code>-</code>之前是有一个空格的，而其后却是和下一个关键词是紧紧相连的！可以看得到结果中都会包含<code>program</code>，而不包含<code>google</code>。</p><h2 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h2><h3 id="intitle"><a href="#intitle" class="headerlink" title="intitle"></a>intitle</h3><p>这个语法的作用是<strong>将搜索的范围局限在标题上</strong>。在关键词前面加上这个，就会只对网页的标题进行搜索并且配对，最后将结果返回给用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intitle:小丁</span><br></pre></td></tr></table></figure><h3 id="intext"><a href="#intext" class="headerlink" title="intext"></a>intext</h3><p>这个语法是用来搜索<strong>网页正文内容</strong>的，这样就可以忽略网页中的超文本链接、URL和题目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intext:小丁</span><br></pre></td></tr></table></figure><h3 id="inanchor"><a href="#inanchor" class="headerlink" title="inanchor"></a>inanchor</h3><p>这个语法的意思是在页面的链接锚点进行搜索。</p><blockquote><p>链接锚点指的是一个<strong>链接的描述文本</strong>，如这样的一段HTML代码：<code>&lt;a href=https://www.baidu.com&gt;百度&lt;/a&gt;</code>，链接的锚点就是“百度”了。</p></blockquote><h3 id="site"><a href="#site" class="headerlink" title="site"></a>site</h3><p>这个语法是把<strong>搜索限制在站点域名之内</strong>。</p><p>例如我们搜索<code>program site:google.com</code>，这里呢，我们通常不需要加上前面的www，这样搜索的结果就会是包括所有含有<code>google.com</code>域名的有关内容，包括顶级域名和二级域名甚至三级域名的内容。</p><h3 id="inurl"><a href="#inurl" class="headerlink" title="inurl"></a>inurl</h3><p>这个语法会将搜索的范围限制在URL或者网站的页面上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inurl:password</span><br></pre></td></tr></table></figure><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>这个语法可以帮助我们查找到google索引过的页面副本，即使源文件界面不存在了，或者变成了其它的内容，我们依然可以搜索的到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache：www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="filetype"><a href="#filetype" class="headerlink" title="filetype"></a>filetype</h3><p>这个语法可以搜索指定后缀的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype:pdf</span><br></pre></td></tr></table></figure><h3 id="特定时间"><a href="#特定时间" class="headerlink" title="特定时间"></a>特定时间</h3><p>为了将查询结果限制在一个特定的时间段内，可以采用以下语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avengers endgame before:2019</span><br><span class="line">avengers endgame after:2019-04-01</span><br><span class="line">avengers endgame after:2019-03-01 before:2019-03-05</span><br></pre></td></tr></table></figure><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>当我们需要简单数学运算时，无需费力的点开计算机，只需要直接在Google中输入数学算式即可，算式可以包含<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和括号这些基本的算术功能。例如：<code>(4*8)/2+18-1</code></p><h2 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h2><p>方便的单位换算，只需要输入你想要换算的两种单位即可，例如：<code>100磅=?公斤</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/u014565127/article/details/53842885" rel="external nofollow noopener noreferrer" target="_blank">谷歌搜索语法（一）基本语法</a></li><li><a href="https://blog.csdn.net/u014565127/article/details/53868443" rel="external nofollow noopener noreferrer" target="_blank">谷歌搜索语法（二）高级语法</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:00 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;我们在日常生活中利用Google搜索的一些技巧可以更加高效的找到我们需要的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="搜索引擎" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="Google" scheme="https://tding.top/tags/Google/"/>
    
      <category term="搜索引擎" scheme="https://tding.top/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题目总结-二叉树的遍历</title>
    <link href="https://tding.top/archives/e1014f63.html"/>
    <id>https://tding.top/archives/e1014f63.html</id>
    <published>2019-11-27T15:27:00.000Z</published>
    <updated>2019-11-27T15:32:08.652Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>遍历的含义就是把树的所有节点（Node）按照某种顺序访问一遍。包括前序，中序，后序，层序4种遍历方法。</p><a id="more"></a><ol><li>以图的深度优先搜索为原型的遍历</li></ol><ul><li><a href="#144-二叉树的前序遍历">144-二叉树的前序遍历</a></li><li><a href="#94-二叉树的中序遍历">94-二叉树的中序遍历</a></li><li><a href="#145-二叉树的后序遍历">145-二叉树的后序遍历</a></li></ul><p>在这种类型中，递归的实现方式是非常简单的，只需要递归左右结点，直到结点为空作为结束条件就可以，哪种序就取决于你访问结点的时间。</p><p>不过一般这不能满足面试官的要求，可能会接着问能不能用非递归实现一下，这个说起来比较简单，其实就是用一个栈手动模拟递归的过程。</p><p>有时候非递归还是不能满足面试官，还会问一问，上面的做法时间和空间复杂度是多少。我们知道，正常遍历时间复杂度是<code>O(n)</code>，而空间复杂度是则是递归栈（或者自己维护的栈）的大小，也就是<code>O(logn)</code>。他会问能不能够在常量空间内解决树的遍历问题呢？确实还真可以，这里就要介绍一下Morris遍历。</p><blockquote><p>Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。这样就节省了需要用栈来记录前驱或者后继结点的额外空间，所以可以达到<code>O(1)</code>的空间复杂度。不过这种方法有一个问题就是会暂时性的改动树的结构，这在程序设计中并不是很好的习惯，这些在面试中都可以和面试官讨论，一般来说问到这里不会需要进行Morris遍历方法的代码实现了，只需要知道这种方法和他的主要优劣势就可以了。</p></blockquote><ol start="2"><li>以图的广度优先搜索为原型的遍历，在树中称为层序遍历，LeetCode中有三种：自顶向下层序、自底向上层序、锯齿层序遍历。</li></ol><ul><li><a href="#102-二叉树的层次遍历">102-二叉树的层次遍历</a></li><li><a href="#103-二叉树的锯齿形层次遍历">103-二叉树的锯齿形层次遍历</a></li><li><a href="#107-二叉树的层次遍历ii">107-二叉树的层次遍历ii</a></li></ul><p><strong>自顶向下层序遍历</strong>其实比较简单，代码基本就是图的广度优先搜索，思路就是维护一个<strong>队列</strong>存储上一层的结点，逐层访问。而<strong>自底向上层序层序遍历</strong>则要从最后一层倒序访问上来，这个我没有想到太好的方法，现在的实现就是把自顶向下层序遍历得到的层放入数据结构然后reverse过来。至于<strong>锯齿层序遍历</strong>因为每一层访问顺序有所改变，而且是每次都反转顺序，这让我们想到<strong>栈</strong>这个数据结构，所以这里不用队列而改用栈来保存，就可以满足每层反转访问顺序的要求了。</p><p>层次遍历相关的题目：</p><ul><li><a href="#116-填充每个节点的下一个右侧节点指针">116-填充每个节点的下一个右侧节点指针</a></li><li><a href="#117-填充每个节点的下一个右侧节点指针ii">117-填充每个节点的下一个右侧节点指针ii</a></li><li>513-找树左下角的值</li><li>515-在每个树行中找最大值</li></ul><h2 id="以图的深度优先搜索为原型的遍历"><a href="#以图的深度优先搜索为原型的遍历" class="headerlink" title="以图的深度优先搜索为原型的遍历"></a>以图的深度优先搜索为原型的遍历</h2><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144-二叉树的前序遍历"></a>144-二叉树的前序遍历</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回它的 <strong>前序</strong> 遍历。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>前序遍历算法先访问树的根节点，然后以类似的方式分别遍历左子树和右子树。</p><img src="/archives/e1014f63/144-1.png" title="前序遍历"><h5 id="方法1——递归"><a href="#方法1——递归" class="headerlink" title="方法1——递归"></a>方法1——递归</h5><p>定义函数<code>preorderTraversal(self, node)</code>返回以node为答案的先序遍历结果的数组，假设它的两个孩子<code>node.left</code>和<code>node.right</code>已经搞定了，即可以返回答案的输出数组。那么思考最终的输出数组是什么样的，很明显要满足<code>根 ➜ 左 ➜ 右</code>的规则，应该返回<code>[node.val] + preorderTraversal(self, node.left) + preorderTraversal(self, node.right)</code>（函数返回的就是一个数组，只需要把它们拼接起来即可）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        output = []</span><br><span class="line">        </span><br><span class="line">        output.append(root.val)</span><br><span class="line">        output += self.preorderTraversal(root.left)</span><br><span class="line">        output += self.preorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h5 id="方法2——迭代"><a href="#方法2——迭代" class="headerlink" title="方法2——迭代"></a>方法2——迭代</h5><p>递归算法使用系统栈，不好控制，性能问题比较严重，需要进一步了解不用递归如何实现。为了维护固定的访问顺序，使用栈数据结构的先入后出特性。</p><p>先处理根节点，根据访问顺序<code>根 ➜ 左 ➜ 右</code>，先入栈的后访问，为了保持访问顺序（先入后出），<strong>先把右孩子入栈，再入栈左孩子（此处需要注意，出栈才是访问顺序）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        output = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">                <span class="comment"># 先入栈右节点</span></span><br><span class="line">                stack.append(root.right)</span><br><span class="line">                <span class="comment"># 后入栈左节点</span></span><br><span class="line">                stack.append(root.left)</span><br><span class="line">                <span class="comment"># 栈顶元素并入输出</span></span><br><span class="line">                output.append(root.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>注意：我这里是把所有迭代过程中的root节点的right节点、left节点（包括空节点）均放入栈，然后在循环里面弹出栈顶元素，检查是否是空，如果为空节点，则不操作。</p><ul><li>时间复杂度：访问每个节点恰好一次，时间复杂度为 O(N) ，其中 N 是节点的个数，也就是树的大小。</li><li>空间复杂度：取决于树的结构，最坏情况存储整棵树，因此空间复杂度是 O(N)。</li></ul><h5 id="方法3——颜色标记法"><a href="#方法3——颜色标记法" class="headerlink" title="方法3——颜色标记法"></a>方法3——颜色标记法</h5><p>其核心思想是使用<strong>颜色标记节点的状态，新节点为白色，已访问的节点为灰色</strong>：</p><ul><li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、左子节点、自身依次入栈。</li><li>如果遇到的节点为灰色，则将节点的值输出。</li></ul><p><strong>颜色标记法的优势</strong>：兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        WHITE,GRAY = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        stack = [(WHITE,root)]</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            color,root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> color == WHITE:</span><br><span class="line">                    stack.append((WHITE,root.right))</span><br><span class="line">                    stack.append((WHITE,root.left))</span><br><span class="line">                    stack.append((GRAY,root))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    output.append(root.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94-二叉树的中序遍历"></a>94-二叉树的中序遍历</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回它的 <strong>中序</strong> 遍历。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>中序遍历的算法先遍历左子树，然后访问根节点，最后遍历右子树，这个算法先尽量移动到树的最左边，然后才开始访问节点。</p><img src="/archives/e1014f63/94-1.png" title="中序遍历"><h5 id="方法1——递归-1"><a href="#方法1——递归-1" class="headerlink" title="方法1——递归"></a>方法1——递归</h5><p>同理于前序遍历，一模一样的处理方法，考虑访问顺序为<code>左 ➜ 根 ➜ 右</code>即可，快速模仿并写出代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        output += self.inorderTraversal(root.left)</span><br><span class="line">        output.append(root.val)</span><br><span class="line">        output += self.inorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h5 id="方法2——迭代-1"><a href="#方法2——迭代-1" class="headerlink" title="方法2——迭代"></a>方法2——迭代</h5><p>核心思路依旧是利用栈维护节点的访问顺序：<code>左 ➜ 根 ➜ 右</code>。使用一个<code>p_node</code>来指向当前访问节点，p是代表指针point，另外有一个变量<code>cur_node</code>表示当前正在操作节点（把出栈节点值加入输出数组中），算法步骤如下（可以对照代码注释）:</p><ul><li><p>访问当前节点，如果当前节点有左孩子，则把它的左孩子都入栈，移动当前节点到左孩子，重复第一步直到当前节点没有左孩子</p></li><li><p>当当前节点没有左孩子时，栈顶节点出栈，加入结果数组</p></li><li><p>当前节点指向栈顶节点的右节点</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前访问节点指针</span></span><br><span class="line">        p_node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p_node:</span><br><span class="line">            <span class="comment"># 把所有当前访问节点的左孩子都入栈</span></span><br><span class="line">            <span class="keyword">while</span> p_node:</span><br><span class="line">                stack.append(p_node)</span><br><span class="line">                p_node = p_node.left</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 操作栈顶节点，如果是第一次运行到这步，那么这是整棵树的最左节点</span></span><br><span class="line">            cur_node = stack.pop()</span><br><span class="line">            <span class="comment"># 因为已经保证没有左节点，可以访问根节点</span></span><br><span class="line">            output.append(cur_node.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                <span class="comment"># 将指针指向当前节点的右节点</span></span><br><span class="line">                p_node = cur_node.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h5 id="方法3——颜色标记法-1"><a href="#方法3——颜色标记法-1" class="headerlink" title="方法3——颜色标记法"></a>方法3——颜色标记法</h5><p>其核心思想是使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色：</p><ul><li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。</li><li>如果遇到的节点为灰色，则将节点的值输出。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        WHITE,GRAY = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        stack = [(WHITE,root)]</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            color,root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> color == WHITE:</span><br><span class="line">                    stack.append((WHITE,root.right))</span><br><span class="line">                    stack.append((GRAY,root))</span><br><span class="line">                    stack.append((WHITE,root.left))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    output.append(root.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145-二叉树的后序遍历"></a>145-二叉树的后序遍历</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回它的 <strong>后序</strong> 遍历。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>后序遍历算法会先遍历左子树，然后是右子树，最后访问根节点。</p><img src="/archives/e1014f63/145-1.png" title="后序遍历"><h5 id="方法1——递归-2"><a href="#方法1——递归-2" class="headerlink" title="方法1——递归"></a>方法1——递归</h5><p>类似前序遍历，只需要改变<strong>节点访问顺序</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        output = []</span><br><span class="line">        </span><br><span class="line">        output += self.postorderTraversal(root.left)</span><br><span class="line">        output += self.postorderTraversal(root.right)</span><br><span class="line">        output.append(root.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h5 id="方法2——迭代-2"><a href="#方法2——迭代-2" class="headerlink" title="方法2——迭代"></a>方法2——迭代</h5><p>我们发现后序遍历的顺序是<code>左 ➜ 右 ➜ 根</code>，那么反序的话，就直接倒序的输出结果，即反后序：<code>根 ➜ 右 ➜ 左</code>，和先序遍历的<code>根 ➜ 左 ➜ 右</code>对比，发现只需要稍微改一下代码就可以得到反后序的结果，参考先序遍历，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">                output.append(root.val)</span><br><span class="line">                stack.append(root.left)</span><br><span class="line">                stack.append(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h5 id="方法3——迭代（颜色标记法）"><a href="#方法3——迭代（颜色标记法）" class="headerlink" title="方法3——迭代（颜色标记法）"></a>方法3——迭代（颜色标记法）</h5><p>后序遍历访问顺序要求为<code>左 ➜ 右 ➜ 根</code>，<strong>在对访问节点进行操作的条件是，它的左子树和右子树都已经被访问</strong>。这样算法的框架就出来了：只需要对每个节点进行标记，表示这个节点有没有被访问，一个节点能否进行操作的条件就是这个节点的左右节点都被访问过了。</p><p>因为栈先入后出，为了维护访问顺序满足条件，入栈顺序应该是<code>根 ➜ 右 ➜ 左</code>（和要求访问顺序相反）。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        WHITE,GRAY = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        stack = [(WHITE,root)]</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            color,root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> color == WHITE:</span><br><span class="line">                    stack.append((GRAY,root))</span><br><span class="line">                    stack.append((WHITE,root.right))                </span><br><span class="line">                    stack.append((WHITE,root.left))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    output.append(root.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h2 id="以图的广度优先搜索为原型的遍历"><a href="#以图的广度优先搜索为原型的遍历" class="headerlink" title="以图的广度优先搜索为原型的遍历"></a>以图的广度优先搜索为原型的遍历</h2><h3 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102-二叉树的层次遍历"></a>102-二叉树的层次遍历</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回其按层次遍历的节点值。（即逐层地，从左到右访问所有节点）。</p><p>例如：给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><h5 id="方法1——借助队列的迭代方法"><a href="#方法1——借助队列的迭代方法" class="headerlink" title="方法1——借助队列的迭代方法"></a>方法1——借助队列的迭代方法</h5><p>我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Python 中如果使用 Queue 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 Python 中可以使用 deque 的 <code>append()</code> 和 <code>popleft()</code> 函数来快速实现队列的功能。</p><p>注意：输出要求<code>List[List[int]]</code>。</p><p>算法步骤：</p><ul><li>计算当前层级节点数目，然后从队列中循环取出当前层级的全部节点（节点放入到列表中），并且将其左右子节点放入队列。</li><li>循环上步直到队列为空</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        queue = deque([root,])</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当前层级节点数目</span></span><br><span class="line">            level_length = len(queue)</span><br><span class="line"></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_length):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            </span><br><span class="line">            output.append(temp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h5 id="方法2——递归"><a href="#方法2——递归" class="headerlink" title="方法2——递归"></a>方法2——递归</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 辅助函数（添加变量res，depth）</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res, depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 比较访问节点所在的层次 depth 和当前最高层次 len(res) 的大小，如果前者更大就向 res 添加一个空列表</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == depth:</span><br><span class="line">                res.append([])</span><br><span class="line">            <span class="comment"># 当前节点插入到对应层的列表 res[depth] 中</span></span><br><span class="line">            res[depth].append(root.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            helper(root.left,res,depth+<span class="number">1</span>)</span><br><span class="line">            helper(root.right,res,depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root,res,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)，因为每个节点恰好会被运算一次。</li><li>空间复杂度：O(N)，保存输出结果的数组包含 N 个节点的值。</li></ul><h3 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103-二叉树的锯齿形层次遍历"></a>103-二叉树的锯齿形层次遍历</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回锯齿形层次遍历如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><h5 id="方法1——借助队列的迭代方法-1"><a href="#方法1——借助队列的迭代方法-1" class="headerlink" title="方法1——借助队列的迭代方法"></a>方法1——借助队列的迭代方法</h5><p>与102题相同，这道题的本质是树的层次遍历（广度优先遍历）。只需要把偶数层的结果进行反转即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 标记是否需要翻转结果</span></span><br><span class="line">        signal = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 队列的长度（这层的节点数）</span></span><br><span class="line">            length = len(queue)     </span><br><span class="line"></span><br><span class="line">            temp = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                temp.append(node.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据标记决定是否翻转结果</span></span><br><span class="line">            <span class="keyword">if</span> signal == <span class="keyword">False</span>:</span><br><span class="line">                temp = temp[::<span class="number">-1</span>]</span><br><span class="line">                signal = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                signal = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            output.append(temp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="107-二叉树的层次遍历ii"><a href="#107-二叉树的层次遍历ii" class="headerlink" title="107-二叉树的层次遍历ii"></a>107-二叉树的层次遍历ii</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其自底向上的层次遍历为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><h3 id="方法1——层次遍历迭代（反转结果）"><a href="#方法1——层次遍历迭代（反转结果）" class="headerlink" title="方法1——层次遍历迭代（反转结果）"></a>方法1——层次遍历迭代（反转结果）</h3><p>我这里用层次遍历得到节点列表，然后将这个节点列表进行反转即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = output[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>整体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 当前层级节点数目</span></span><br><span class="line">            length = len(queue)</span><br><span class="line">            temp = []</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line"></span><br><span class="line">            output.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h5 id="方法2——层次遍历迭代（从头添加数组）"><a href="#方法2——层次遍历迭代（从头添加数组）" class="headerlink" title="方法2——层次遍历迭代（从头添加数组）"></a>方法2——层次遍历迭代（从头添加数组）</h5><p>当然，我们也可以每次从头添加数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output.insert(<span class="number">0</span>,temp)</span><br></pre></td></tr></table></figure><p>整体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 当前层级节点数目</span></span><br><span class="line">            length = len(queue)</span><br><span class="line">            temp = []</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line"></span><br><span class="line">            output.insert(<span class="number">0</span>,temp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116-填充每个节点的下一个右侧节点指针"></a>116-填充每个节点的下一个右侧节点指针</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>示例：</p><img src="/archives/e1014f63/116-1.png" title="填充每个节点的下一个右侧节点指针-1"><p>输入：<code>{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}</code></p><p>输出：<code>{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:6},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:{&quot;$ref&quot;:&quot;5&quot;},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;6&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;$ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;7&quot;},&quot;val&quot;:1}</code></p><p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p><p>提示：</p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><h5 id="方法1——层次遍历-迭代"><a href="#方法1——层次遍历-迭代" class="headerlink" title="方法1——层次遍历-迭代"></a>方法1——层次遍历-迭代</h5><p>首先想到层次遍历入队，各层中的点都逐一连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, left, right, next):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            length = len(queue)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 先弹出一个节点，便于循环中填充next指针</span></span><br><span class="line">            pre = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 左右子树入队</span></span><br><span class="line">            <span class="keyword">if</span> pre.left != <span class="keyword">None</span>:</span><br><span class="line">                queue.append(pre.left)</span><br><span class="line">            <span class="keyword">if</span> pre.right != <span class="keyword">None</span>:</span><br><span class="line">                queue.append(pre.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length<span class="number">-1</span>):</span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                pre.next = cur</span><br><span class="line">                <span class="comment"># 左右子树入队</span></span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">                <span class="comment"># 更新pre指针</span></span><br><span class="line">                pre = cur</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h5 id="方法2——常数空间复杂度"><a href="#方法2——常数空间复杂度" class="headerlink" title="方法2——常数空间复杂度"></a>方法2——常数空间复杂度</h5><p>之前是用队列将下一层的节点保存了起来。这里的话，其实只需要<strong>提前把下一层的next构造完成，到了下一层的时候就可以遍历了</strong>。</p><p>我们可以通过判断当前遍历的节点是不是null来决定是否进入下一层。</p><p>然后，我们需要一个额外的变量存储每一层的开头节点。</p><p>下面是一个图解：</p><img src="/archives/e1014f63/116-2.png" title="填充每个节点的下一个右侧节点指针-2"> <img src="/archives/e1014f63/116-3.png" title="填充每个节点的下一个右侧节点指针-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, left, right, next):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        start = root</span><br><span class="line">        pre = root</span><br><span class="line">        cur = root.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start.left != <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># 构造下一层的next指针</span></span><br><span class="line">            pre.left.next = pre.right</span><br><span class="line">            <span class="keyword">while</span> cur != <span class="keyword">None</span>:</span><br><span class="line">                pre.right.next = cur.left</span><br><span class="line">                cur.left.next = cur.right</span><br><span class="line">                <span class="comment"># 更新pre、cur</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新pre、cur、start</span></span><br><span class="line">            pre = start.left</span><br><span class="line">            cur = start.right</span><br><span class="line">            start = pre</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">### 117-填充每个节点的下一个右侧节点指针ii</span></span><br><span class="line"><span class="comment">#### 题目描述</span></span><br><span class="line">给定一个二叉树</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>示例：</p><img src="/archives/e1014f63/117-1.png" title="填充每个节点的下一个右侧节点指针ii-1"><p>输入：<code>{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}</code></p><p>输出：<code>{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;5&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;$ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;6&quot;},&quot;val&quot;:1}</code></p><p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p><p>提示：</p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><h5 id="方法1——层次遍历"><a href="#方法1——层次遍历" class="headerlink" title="方法1——层次遍历"></a>方法1——层次遍历</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, left, right, next):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            length = len(queue)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 先弹出一个节点，便于循环中填充next指针</span></span><br><span class="line">            pre = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 左右子树入队</span></span><br><span class="line">            <span class="keyword">if</span> pre.left != <span class="keyword">None</span>:</span><br><span class="line">                queue.append(pre.left)</span><br><span class="line">            <span class="keyword">if</span> pre.right != <span class="keyword">None</span>:</span><br><span class="line">                queue.append(pre.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length<span class="number">-1</span>):</span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                pre.next = cur</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 左右子树入队</span></span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line"></span><br><span class="line">                pre = cur</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h5 id="方法2——常数空间解法"><a href="#方法2——常数空间解法" class="headerlink" title="方法2——常数空间解法"></a>方法2——常数空间解法</h5><p>我们用一个dummy指针，当连接第一个节点的时候，就将dummy指针指向他。</p><p>cur 指针利用 next 不停的遍历当前层。如果 cur 的孩子不为 null 就将它接到 tail 后边，然后更新tail。<strong>当 cur 为 null 的时候，再利用 dummy 指针得到新的一层的开始节点</strong>。</p><p>下面是一个示意图：</p><img src="/archives/e1014f63/117-2.png" title="填充每个节点的下一个右侧节点指针ii-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, left, right, next):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        cur = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="keyword">None</span>:</span><br><span class="line">            dummy = Node()</span><br><span class="line">            tail = dummy</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历cur所在的当前层</span></span><br><span class="line">            <span class="keyword">while</span> cur != <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="keyword">None</span>:</span><br><span class="line">                    tail.next = cur.left</span><br><span class="line">                    tail = tail.next</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="keyword">None</span>:</span><br><span class="line">                    tail.next = cur.right</span><br><span class="line">                    tail = tail.next</span><br><span class="line"></span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新cur到下一层</span></span><br><span class="line">            cur = dummy.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://charlesliuyx.github.io/2018/10/22/%E3%80%90%E7%9B%B4%E8%A7%82%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" rel="external nofollow noopener noreferrer" target="_blank">【直观算法】二叉树遍历算法总结</a></li><li><a href="http://interviewsource.blogspot.com/2016/09/blog-post.html" rel="external nofollow noopener noreferrer" target="_blank">LeetCode总结 – 树</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;遍历的含义就是把树的所有节点（Node）按照某种顺序访问一遍。包括前序，中序，后序，层序4种遍历方法。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="https://tding.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="LeetCode" scheme="https://tding.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://tding.top/tags/LeetCode/"/>
    
      <category term="二叉树" scheme="https://tding.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题目总结-二叉搜索树</title>
    <link href="https://tding.top/archives/5f8aadd1.html"/>
    <id>https://tding.top/archives/5f8aadd1.html</id>
    <published>2019-11-21T15:51:00.000Z</published>
    <updated>2019-11-28T08:51:30.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --><p>我们发现：</p><ul><li>在链表中，插入、删除速度很快<code>O(1)</code>，但查找速度较慢<code>O(n)</code>。</li><li>在数组中，查找速度很快<code>O(1)</code>，但插入、删除速度很慢<code>O(n)</code>。</li></ul><p>为了解决这个问题，我们需要寻找一种能够在插入、删除、查找、遍历等操作都相对快的容器，于是人们发明了二叉搜索树（二叉树仅作为二叉搜索树的基础）。二叉搜索树的插入、删除、查找成本均为<code>O(log n)</code></p><a id="more"></a><h2 id="二叉搜索树的性质"><a href="#二叉搜索树的性质" class="headerlink" title="二叉搜索树的性质"></a>二叉搜索树的性质</h2><ul><li>如果节点的左子树不空，则左子树上所有结点的值均小于等于它的根结点的值；</li><li>如果节点的右子树不空，则右子树上所有结点的值均大于等于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉搜索树；</li></ul><h2 id="二叉搜索树的查找、插入、删除过程"><a href="#二叉搜索树的查找、插入、删除过程" class="headerlink" title="二叉搜索树的查找、插入、删除过程"></a>二叉搜索树的查找、插入、删除过程</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>通过二叉搜索树查找节点，理想情况下我们需要检查的节点数可以减半。</p><p>但是<strong>二叉搜索树十分依赖于树中节点的拓扑结构</strong>，也就是节点间的布局关系。下图描绘了一个节点插入顺序为 <code>20, 50, 90, 150, 175, 200</code> 的二叉搜索树。这些节点是按照递升顺序被插入的，结果就是这棵树没有广度（Breadth）可言。也就是说，它的拓扑结构其实就是将节点排布在一条线上，而不是以扇形结构散开，所以查找时间也为 <code>O(n)</code>。</p><img src="/archives/5f8aadd1/二叉搜索树-查找-2.gif" title="二叉搜索树-查找-2"><p>下面是一个查找过程：</p><img src="/archives/5f8aadd1/二叉搜索树-查找-1.gif" title="二叉搜索树-查找-1"><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>当向树中插入一个新的节点时，<strong>该节点将总是作为叶子节点</strong>。所以，最困难的地方就是如何找到该节点的父节点。</p><p>下面是一个插入过程：</p><img src="/archives/5f8aadd1/二叉搜索树-插入.gif" title="二叉搜索树-插入"><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除节点算法的第一步是定位要被删除的节点，这可以使用前面介绍的查找算法，因此运行时间为 <code>O(logn)</code>。接着应该选择合适的节点来代替删除节点的位置，它共有三种情况需要考虑。</p><ul><li>情况 1：如果<strong>被删除的节点没有右孩子</strong>，那么就选择它的左孩子来代替原来的节点。二叉搜索树的性质保证了被删除节点的左子树必然符合二叉搜索树的性质。因此左子树的值要么都大于，要么都小于被删除节点的父节点的值，这取决于被删除节点是左孩子还是右孩子。因此用被删除节点的左子树来替代被删除节点，是完全符合二叉搜索树的性质的。</li><li>情况 2：如果<strong>被删除节点的右孩子没有左孩子</strong>，那么这个右孩子被用来替换被删除节点。因为被删除节点的右孩子都大于被删除节点左子树的所有节点，同时也大于或小于被删除节点的父节点，这同样取决于被删除节点是左孩子还是右孩子。因此，用右孩子来替换被删除节点，符合二叉搜索树的性质。</li><li>情况 3：如果<strong>被删除节点的右孩子有左孩子</strong>，就需要用被删除节点右孩子的左子树中的最下面的节点来替换它，就是说，我们用<strong>被删除节点的右子树中最小值的节点来替换</strong>。</li></ul><img src="/archives/5f8aadd1/二叉搜索树-删除.gif" title="二叉搜索树-删除"><h2 id="LeetCode相关题目"><a href="#LeetCode相关题目" class="headerlink" title="LeetCode相关题目"></a>LeetCode相关题目</h2><ul><li><p><strong>基本操作</strong></p><ul><li><a href="#235-二叉搜索树的最近公共祖先">235-二叉搜索树的最近公共祖先</a></li><li><a href="#450-删除二叉搜索树中的节点">450-删除二叉搜索树中的节点</a></li><li><a href="#669-修剪二叉搜索树">669-修剪二叉搜索树</a></li><li><a href="#700-二叉搜索树中的搜索">700-二叉搜索树中的搜索</a></li><li><a href="#701-二叉搜索树中的插入操作">701-二叉搜索树中的插入操作</a></li></ul></li><li><p><strong>基于中序遍历</strong></p><ul><li><a href="#98-验证二叉搜索树">98-验证二叉搜索树</a></li><li><a href="#99-恢复二叉搜索树">99-恢复二叉搜索树</a></li><li><a href="#230-二叉搜索树中第K小的元素">230-二叉搜索树中第K小的元素</a></li><li><a href="#501-二叉搜索树中的众数">501-二叉搜索树中的众数</a></li></ul></li></ul><h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235-二叉搜索树的最近公共祖先"></a>235-二叉搜索树的最近公共祖先</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树: <code>root = [6,2,8,0,4,7,9,null,null,3,5]</code></p><img src="/archives/5f8aadd1/235-1.png" title="二叉搜索树的最近公共祖先-1"><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最近公共子节点有可能是下面这几种情况：</p><img src="/archives/5f8aadd1/235-2.png" title="二叉搜索树的最近公共祖先-2"><p>具体步骤如下：</p><ul><li>从根节点开始遍历树</li><li>如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 1 的操作</li><li>如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 1 的操作</li><li>如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 LCA 了</li></ul><blockquote><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian--2/" rel="external nofollow noopener noreferrer" target="_blank">二叉搜索树的最近公共祖先</a></p></blockquote><h4 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>方法2：迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        cur_node = root</span><br><span class="line">        <span class="keyword">while</span> cur_node:</span><br><span class="line">            <span class="keyword">if</span> p.val &gt; cur_node.val <span class="keyword">and</span> q.val &gt; cur_node.val:</span><br><span class="line">                cur_node = cur_node.right</span><br><span class="line">            <span class="keyword">elif</span> p.val &lt; cur_node.val <span class="keyword">and</span> q.val &lt; cur_node.val:</span><br><span class="line">                cur_node = cur_node.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> cur_node</span><br></pre></td></tr></table></figure><h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450-删除二叉搜索树中的节点"></a>450-删除二叉搜索树中的节点</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root = [5,3,6,2,4,null,7]</span><br><span class="line">key = 3</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br></pre></td></tr></table></figure><p>给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</p><p>一个正确的答案是 <code>[5,4,6,2,null,null,7]</code>, 如下图所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  4   6</span><br><span class="line"> /     \</span><br><span class="line">2       7</span><br></pre></td></tr></table></figure><p>另一个正确答案是 <code>[5,2,6,null,4,null,7]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">2   6</span><br><span class="line"> \   \</span><br><span class="line">  4   7</span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>理解这个算法的关键在于保持 BST 中序遍历的顺序性。</p><p>删除一个节点会有三种情况，具体见下面的图解：</p><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">流程1</a></li><li class="tab"><a href="#tab-2">流程2</a></li><li class="tab"><a href="#tab-3">流程3</a></li><li class="tab"><a href="#tab-4">流程4</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><img src="/archives/5f8aadd1/450-1.png" title="删除二叉搜索树中的节点-1"></p></div><div class="tab-pane" id="tab-2"><p><img src="/archives/5f8aadd1/450-2.png" title="删除二叉搜索树中的节点-2"></p></div><div class="tab-pane" id="tab-3"><p><img src="/archives/5f8aadd1/450-3.png" title="删除二叉搜索树中的节点-3"></p></div><div class="tab-pane" id="tab-4"><p><img src="/archives/5f8aadd1/450-4.png" title="删除二叉搜索树中的节点-4"></p></div></div></div><blockquote><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/yong-qian-qu-huo-zhe-hou-ji-jie-dian-zi-shu-dai-ti/" rel="external nofollow noopener noreferrer" target="_blank">用前驱或者后继结点代替被删除结点（Python、Java 代码）</a></p></blockquote><h4 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, root: TreeNode, key: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归调用左子树</span></span><br><span class="line">        <span class="keyword">if</span> key &lt; root.val:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归调用右子树</span></span><br><span class="line">        <span class="keyword">if</span> key &gt; root.val:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点的val正好等于key</span></span><br><span class="line">        <span class="comment"># 当前节点的左子节点不存在，直接提升右子节点即可</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            new_root = root.right</span><br><span class="line">            root.right = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> new_root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点的右子节点不存在，直接提升左子节点即可</span></span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            new_root = root.left</span><br><span class="line">            root.left = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> new_root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点的左右子节点均存在，这里我用左子树中最大的点来替换</span></span><br><span class="line">        <span class="comment"># 寻找左子树中最大的点（即最右边这个节点）</span></span><br><span class="line">        node = root.left</span><br><span class="line">        <span class="keyword">while</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="comment"># 左子树中最大的点变为新的根节点</span></span><br><span class="line">        new_root = TreeNode(node.val)</span><br><span class="line">        <span class="comment"># 新的根节点的左子树需要更新</span></span><br><span class="line">        new_root.left = self.removeMax(root.left)</span><br><span class="line">        <span class="comment"># 新的根节点的右子树即为原来的右子树</span></span><br><span class="line">        new_root.right = root.right</span><br><span class="line"></span><br><span class="line">        root.left = <span class="keyword">None</span></span><br><span class="line">        root.right = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> new_root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeMax</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.right == <span class="keyword">None</span>:</span><br><span class="line">            new_root = node.left</span><br><span class="line">            node.left = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> new_root</span><br><span class="line">        node.right = self.removeMax(node.right)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><blockquote><p>如果不把待删除节点的左右节点设置为None会怎么样？</p></blockquote><p>写这两行代码是出于面向对象的程序语言（Python 和 Java 都是）的垃圾回收机制（Garbage Collection，GC）的考虑。如果一个对象没有被其它对象引用，它会在合适的时候被垃圾回收机制回收，被垃圾回收机制回收即是真正从内存中删除了，语义上也没有必要保留这两个引用。</p><h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669-修剪二叉搜索树"></a>669-修剪二叉搜索树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在<code>[L, R]</code>中 (<code>R&gt;=L</code>) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  0   2</span><br><span class="line"></span><br><span class="line">  L = 1</span><br><span class="line">  R = 2</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">    1</span><br><span class="line">      \</span><br><span class="line">       2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  0   4</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">   /</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">  L = 1</span><br><span class="line">  R = 3</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">      3</span><br><span class="line">     / </span><br><span class="line">   2   </span><br><span class="line">  /</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>这里我用递归来进行修建：</p><ul><li>当 <code>node.val &gt; R</code>，那么修剪后的二叉树必定出现在节点的左边。</li><li>当 <code>node.val &lt; L</code>，那么修剪后的二叉树出现在节点的右边。</li><li>否则，我们将会修剪树的两边。</li></ul><h4 id="Python实现-2"><a href="#Python实现-2" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span><span class="params">(self, root: TreeNode, L: int, R: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; R:</span><br><span class="line">            <span class="keyword">return</span> self.trimBST(root.left,L,R)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.val &lt; L:</span><br><span class="line">            <span class="keyword">return</span> self.trimBST(root.right,L,R)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &gt;= L <span class="keyword">and</span> root.val &lt;= R:</span><br><span class="line">            root.left = self.trimBST(root.left,L,R)</span><br><span class="line">            root.right = self.trimBST(root.right,L,R)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700-二叉搜索树中的搜索"></a>700-二叉搜索树中的搜索</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，给定二叉搜索树:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p>和值：2</p><p>你应该返回如下子树:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2     </span><br><span class="line"> / \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>根据二叉搜索树的性质：如果val小于当前结点的值，转向其左子树继续搜索；如果val大于当前结点的值，转向其右子树继续搜索；如果已找到，则返回当前结点。如果搜索到最后仍未找到结点，则返回None。</p><h4 id="Python实现-3"><a href="#Python实现-3" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right,val)</span><br><span class="line">        <span class="keyword">elif</span> val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left,val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>方法2：迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> val &gt; root.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> val &lt; root.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701-二叉搜索树中的插入操作"></a>701-二叉搜索树中的插入操作</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。<strong>保证原始二叉搜索树中不存在新值</strong>。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如，给定二叉搜索树:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p>和 插入的值: 5</p><p>你可以返回这个二叉搜索树:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   /</span><br><span class="line">1   3 5</span><br></pre></td></tr></table></figure><p>或者这个树也是有效的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     5</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   </span><br><span class="line">1   3</span><br><span class="line">     \</span><br><span class="line">      4</span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>这里我们采用经典的插入方法，使整体操作变化最小。</p><ol><li>直接深拷贝构造新树，然后修改</li><li>寻找到合适的叶位置后插入新节点，这样只需要在原树的某个叶节点处延伸一个节点</li></ol><h4 id="Python实现-4"><a href="#Python实现-4" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        res = copy.deepcopy(root)</span><br><span class="line">        cur_node = res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果二叉搜索树为空树，用val构造二叉树节点作为根节点并返回</span></span><br><span class="line">        <span class="keyword">if</span> cur_node == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur_node:</span><br><span class="line">            <span class="keyword">if</span> val &gt; cur_node.val:</span><br><span class="line">                <span class="comment"># 走向右子树</span></span><br><span class="line">                <span class="keyword">if</span> cur_node.right != <span class="keyword">None</span>:</span><br><span class="line">                    cur_node = cur_node.right</span><br><span class="line">                <span class="comment"># 应该走向右子树而右子树为空，即找到了插入位置</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur_node.right = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">elif</span> val &lt; cur_node.val:</span><br><span class="line">                <span class="comment"># 走向左子树</span></span><br><span class="line">                <span class="keyword">if</span> cur_node.left != <span class="keyword">None</span>:</span><br><span class="line">                    cur_node = cur_node.left</span><br><span class="line">                <span class="comment"># 应该走向左子树而左子树为空，即找到了插入位置</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur_node.left = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98-验证二叉搜索树"></a>98-验证二叉搜索树</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。根节点的值为 5 ，但是其右子节点值为 4</span><br></pre></td></tr></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>方法1：递归</p><p>看到这道题目，我们首先想到遍历整棵树，检查 <code>node.right.val &gt; node.val</code> 和 <code>node.left.val &lt; node.val</code> 对每个结点是否成立。但是这种方法并不总是正确。因为<strong>不仅右子结点要大于该节点，整个右子树的元素都应该大于该节点</strong>。</p><p>这意味着我们需要在遍历树的同时保留结点的上界与下界，在比较时不仅比较子结点的值，也要与上下界比较。</p><p>方法2：中序遍历</p><p>中序遍历按照<code>左子树 -&gt; 结点 -&gt; 右子树</code>的顺序，这意味着一个<strong>二叉搜索树的中序遍历得到的每个元素都应该比下一个元素小</strong>。</p><p>具体步骤：</p><ol><li>计算中序遍历列表inorder</li><li>检查中序遍历列表是否从小到大</li></ol><h4 id="Python实现-5"><a href="#Python实现-5" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root,max_val,min_val)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.val &lt; max_val <span class="keyword">and</span> root.val &gt; min_val:</span><br><span class="line">                <span class="keyword">return</span> helper(root.left,root.val,min_val) <span class="keyword">and</span> helper(root.right,max_val,root.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        max_val = float(<span class="string">'inf'</span>)</span><br><span class="line">        min_val = -float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">return</span> helper(root,max_val,min_val)</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        pre = -float(<span class="string">'inf'</span>)</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        p_node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p_node:</span><br><span class="line">            <span class="comment"># 把所有当前访问节点的左孩子都入栈</span></span><br><span class="line">            <span class="keyword">while</span> p_node:</span><br><span class="line">                stack.append(p_node)</span><br><span class="line">                p_node = p_node.left</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 操作栈顶节点，如果是第一次运行到这步，那么这是整棵树的最左节点</span></span><br><span class="line">            cur_node = stack.pop()</span><br><span class="line">            <span class="comment"># 检查是否从小到大</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.val &gt; pre:</span><br><span class="line">                pre = cur_node.val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将指针指向当前节点的右节点</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.right != <span class="keyword">None</span>:</span><br><span class="line">                p_node = cur_node.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99-恢复二叉搜索树"></a>99-恢复二叉搜索树</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  /</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">输出: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><p>进阶:</p><ul><li>使用 O(n) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>二叉搜索树中序遍历输出应该是递增的，在遍历二叉树的过程中找到不满足递增的点（即错误交换的点），交换两者的值即可。</p><p><strong>注意：错误交换的点在中序遍历结果中可能是相邻的，也可能是不相邻的</strong>。</p><ul><li><strong>错误交换的点是相邻的（中序遍历结果1324）</strong>：使用first和second表示错误交换的两个点，在第一次遇到不递增的情况时，将first置为3，second置为2，遍历结束后交换first与second。</li><li><strong>错误交换的点是不相邻的（中序遍历结果3214）</strong>：在第一次遇到不递增的情况时，将first设置为3，second设置为2，在第二次遇到不递增的情况时，只改变second，将second置为1.遍历结束后交换first与second。</li></ul><h4 id="Python实现-6"><a href="#Python实现-6" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        pre = TreeNode(-float(<span class="string">'inf'</span>))</span><br><span class="line">        first_node = <span class="keyword">None</span></span><br><span class="line">        second_node = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        p_node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p_node:</span><br><span class="line">            <span class="keyword">while</span> p_node:</span><br><span class="line">                stack.append(p_node)</span><br><span class="line">                p_node = p_node.left</span><br><span class="line"></span><br><span class="line">            cur_node = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 根据当前节点和前一个节点的值来判断节点是否错误</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.val &gt; pre.val:</span><br><span class="line">                pre = cur_node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 第一次相遇</span></span><br><span class="line">                <span class="keyword">if</span> first_node == <span class="keyword">None</span>:</span><br><span class="line">                    first_node = pre</span><br><span class="line">                    second_node = cur_node</span><br><span class="line">                <span class="comment"># 第二次相遇</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    second_node = cur_node</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> cur_node.right != <span class="keyword">None</span>:</span><br><span class="line">                p_node = cur_node.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 交换两个错误交换的节点</span></span><br><span class="line">        first_node.val,second_node.val = second_node.val,first_node.val</span><br></pre></td></tr></table></figure><h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230-二叉搜索树中第K小的元素"></a>230-二叉搜索树中第K小的元素</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p>说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>二叉搜索树的中序遍历序列为递增序列，因此可中序遍历二叉搜索树，返回第K个元素。</p><h4 id="Python实现-7"><a href="#Python实现-7" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 中序遍历二叉树</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        p_node = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p_node:</span><br><span class="line">            <span class="keyword">while</span> p_node:</span><br><span class="line">                stack.append(p_node)</span><br><span class="line">                p_node = p_node.left</span><br><span class="line"></span><br><span class="line">            cur_node = stack.pop()</span><br><span class="line">            res.append(cur_node.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_node.right != <span class="keyword">None</span>:</span><br><span class="line">                p_node = cur_node.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回第k个元素</span></span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>我们也可以提前中止中序遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 中序遍历二叉树</span></span><br><span class="line">        stack = []</span><br><span class="line">        p_node = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p_node:</span><br><span class="line">            <span class="keyword">while</span> p_node:</span><br><span class="line">                stack.append(p_node)</span><br><span class="line">                p_node = p_node.left</span><br><span class="line"></span><br><span class="line">            cur_node = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 返回第k个元素</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> cur_node.val</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_node.right != <span class="keyword">None</span>:</span><br><span class="line">                p_node = cur_node.right</span><br></pre></td></tr></table></figure><h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501-二叉搜索树中的众数"></a>501-二叉搜索树中的众数</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><ul><li>结点左子树中所含结点的值小于等于当前结点的值</li><li>结点右子树中所含结点的值大于等于当前结点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定 BST [1,null,2,2],</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line">返回[2].</span><br></pre></td></tr></table></figure><p>提示：如果众数超过1个，不需考虑输出顺序</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>方法1：层序遍历+字典</p><p>这里我用层次遍历，然后用一个字典记录每个值出现的次数，最后在字典中搜索最大值（即出现次数最多的值，也就是众数）。</p><p>但是这种方法用了额外的空间。</p><p>方法2：中序遍历</p><p>二叉搜索树的中序遍历是一个<strong>升序序列</strong>，逐个比对当前结点值<code>cur_node.val</code>与前驱结点值<code>pre_node.val</code>。更新当前节点值出现次数<code>curTimes</code>及最大出现次数<code>maxTimes</code>，更新规则：</p><ul><li>若<code>curTimes=maxTimes</code>，将<code>cur_node.val</code>添加到结果向量<code>res</code>中</li><li>若<code>curTimes&gt;maxTimes</code>，清空<code>res</code>，将<code>cur_node.val</code>添加到<code>res</code>，并更新<code>maxTimes</code>为<code>curTimes</code></li></ul><h4 id="Python实现-8"><a href="#Python实现-8" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        dicts = &#123;&#125;</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            length = len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 节点值存入字典</span></span><br><span class="line">                <span class="keyword">if</span> node.val <span class="keyword">in</span> dicts:</span><br><span class="line">                    dicts[node.val] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dicts[node.val] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算众数</span></span><br><span class="line">        max_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,counts <span class="keyword">in</span> dicts.items():</span><br><span class="line">            <span class="keyword">if</span> counts &gt; max_num:</span><br><span class="line">                res = [i]</span><br><span class="line">                max_num = counts</span><br><span class="line">            <span class="comment"># 输出所有众数</span></span><br><span class="line">            <span class="keyword">elif</span> counts == max_num:</span><br><span class="line">                res.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        p_node = root</span><br><span class="line">        pre_node = TreeNode(float(<span class="string">'inf'</span>))</span><br><span class="line">        maxTimes = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p_node:</span><br><span class="line">            <span class="comment"># 把所有当前访问节点的左孩子都入栈</span></span><br><span class="line">            <span class="keyword">while</span> p_node != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(p_node)</span><br><span class="line">                p_node = p_node.left</span><br><span class="line"></span><br><span class="line">            cur_node = stack.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新当前节点出现次数</span></span><br><span class="line">            <span class="keyword">if</span> pre_node.val == cur_node.val:</span><br><span class="line">                curTimes += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curTimes = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 最大出现次数</span></span><br><span class="line">            <span class="keyword">if</span> maxTimes == curTimes:</span><br><span class="line">                res.append(cur_node.val)</span><br><span class="line">            <span class="keyword">elif</span> maxTimes &lt; curTimes:</span><br><span class="line">                res = [cur_node.val]</span><br><span class="line">                maxTimes = curTimes</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新前驱节点</span></span><br><span class="line">            pre_node = cur_node</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_node.right != <span class="keyword">None</span>:</span><br><span class="line">                <span class="comment"># 将指针指向当前节点的右节点</span></span><br><span class="line">                p_node = cur_node.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://lufficc.com/blog/binary-search-tree" rel="external nofollow noopener noreferrer" target="_blank">多动态图详细讲解二叉搜索树</a></li><li><a href="https://www.cnblogs.com/gaochundong/p/binary_search_tree.html" rel="external nofollow noopener noreferrer" target="_blank">二叉查找树</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Dec 22 2019 23:36:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;我们发现：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在链表中，插入、删除速度很快&lt;code&gt;O(1)&lt;/code&gt;，但查找速度较慢&lt;code&gt;O(n)&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;在数组中，查找速度很快&lt;code&gt;O(1)&lt;/code&gt;，但插入、删除速度很慢&lt;code&gt;O(n)&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了解决这个问题，我们需要寻找一种能够在插入、删除、查找、遍历等操作都相对快的容器，于是人们发明了二叉搜索树（二叉树仅作为二叉搜索树的基础）。二叉搜索树的插入、删除、查找成本均为&lt;code&gt;O(log n)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="https://tding.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="LeetCode" scheme="https://tding.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://tding.top/tags/LeetCode/"/>
    
      <category term="二叉树" scheme="https://tding.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="https://tding.top/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
</feed>
