<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/Totoroanimationcharacter-180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Totoroanimationcharacter-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Totoroanimationcharacter-16.png">
  <link rel="mask-icon" href="/images/Totoroanimationcharacter.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="smrzctX4--4QKjd_jAPttPxWy06c4SLQo2v1sHBA5rE">
  <meta name="msvalidate.01" content="72019D3672DF2E28BB07FE56B439CB80">
  <meta name="baidu-site-verification" content="bfzCl5Q4EF">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tding.top","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":false,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="树是一种以层次化方式组织和存放数据的特定数据结构。 树有两个主要特征：  每个项都有多个子节点 除了叫做根的特殊的项，所有其他的项都只有一个父节点  二叉树(binary tree)是一种特殊的树结构，它每个节点最多有两个子结点，亦称左孩子和右孩子。 这里总结了LeetCode中二叉树相关的题目，我把这些题目分成了以下五个部分：  二叉树的性质相关题目 二叉树的遍历相关题目 路径和相关题目 二叉树">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode题目总结-二叉树">
<meta property="og:url" content="https://tding.top/archives/101cdf53.html">
<meta property="og:site_name" content="小丁的个人博客">
<meta property="og:description" content="树是一种以层次化方式组织和存放数据的特定数据结构。 树有两个主要特征：  每个项都有多个子节点 除了叫做根的特殊的项，所有其他的项都只有一个父节点  二叉树(binary tree)是一种特殊的树结构，它每个节点最多有两个子结点，亦称左孩子和右孩子。 这里总结了LeetCode中二叉树相关的题目，我把这些题目分成了以下五个部分：  二叉树的性质相关题目 二叉树的遍历相关题目 路径和相关题目 二叉树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tding.top/archives/101cdf53/100-1.png">
<meta property="og:image" content="https://tding.top/archives/101cdf53/100-2.png">
<meta property="og:image" content="https://tding.top/archives/101cdf53/100-3.png">
<meta property="og:image" content="https://tding.top/archives/101cdf53/101-1.png">
<meta property="og:image" content="https://tding.top/archives/101cdf53/105-1.png">
<meta property="og:image" content="https://tding.top/archives/101cdf53/105-2.png">
<meta property="og:image" content="https://tding.top/archives/101cdf53/106-1.png">
<meta property="article:published_time" content="2019-12-03T16:30:00.000Z">
<meta property="article:modified_time" content="2019-12-03T16:30:10.000Z">
<meta property="article:author" content="小丁">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="二叉树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tding.top/archives/101cdf53/100-1.png">

<link rel="canonical" href="https://tding.top/archives/101cdf53.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>LeetCode题目总结-二叉树 | 小丁的个人博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-142510809-2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-142510809-2');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="小丁的个人博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小丁的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">世间所有的相遇，都是久别重逢</h1>
      
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-top">

    <a href="/top/" rel="section"><i class="fa fa-fw fa-signal"></i>热榜</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">111</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">63</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">173</span></a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="fa fa-fw fa-photo"></i>画廊</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>


      
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fa fa-fw fa-rocket"></i>实用工具</a>

  </li>
        
            
  <li class="menu-item menu-item-docs">

    <a href="/docs/" rel="section"><i class="fa fa-fw fa-book"></i>NexT中文文档</a>

  </li>


      
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dta0502" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener external nofollow noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tding.top/archives/101cdf53.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.webp">
      <meta itemprop="name" content="小丁">
      <meta itemprop="description" content="酒，越喝越暖，水会越喝越寒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小丁的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          LeetCode题目总结-二叉树
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-04 00:30:00" itemprop="dateCreated datePublished" datetime="2019-12-04T00:30:00+08:00">2019-12-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          
            <span id="/archives/101cdf53.html" class="post-meta-item leancloud_visitors" data-flag-title="LeetCode题目总结-二叉树" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/archives/101cdf53.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="archives/101cdf53.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/archives/101cdf53.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/archives/101cdf53.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>树是一种以层次化方式组织和存放数据的特定数据结构。</p>
<p>树有两个主要特征：</p>
<ul>
<li>每个项都有多个子节点</li>
<li>除了叫做根的特殊的项，所有其他的项都只有一个父节点</li>
</ul>
<p>二叉树(binary tree)是一种特殊的树结构，它每个节点最多有两个子结点，亦称左孩子和右孩子。</p>
<p>这里总结了LeetCode中二叉树相关的题目，我把这些题目分成了以下五个部分：</p>
<ul>
<li><a href="#二叉树的性质相关题目">二叉树的性质相关题目</a></li>
<li><a href="#二叉树的遍历相关题目">二叉树的遍历相关题目</a></li>
<li><a href="#路径和相关题目">路径和相关题目</a></li>
<li><a href="#二叉树的构建相关题目">二叉树的构建相关题目</a></li>
<li><a href="#二叉搜索树相关题目">二叉搜索树相关题目</a></li>
</ul>
<a id="more"></a>

<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><p>二叉树的存储结构 TreeNode 为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="二叉树的性质相关题目"><a href="#二叉树的性质相关题目" class="headerlink" title="二叉树的性质相关题目"></a>二叉树的性质相关题目</h2><p>树的性质判断是树的数据结构比较基本的操作。</p>
<ul>
<li><a href="100-相同的树">100-相同的树</a></li>
<li><a href="#101-对称二叉树">101-对称二叉树</a></li>
<li><a href="#110-平衡二叉树">110-平衡二叉树</a></li>
<li><a href="#104-二叉树的最大深度">104-二叉树的最大深度</a></li>
<li><a href="#111-二叉树的最小深度">111-二叉树的最小深度</a></li>
<li><a href="#662-二叉树最大宽度">662-二叉树最大宽度</a></li>
</ul>
<h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100-相同的树"></a>100-相同的树</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>方法1：递归</p>
<p>终止条件与返回值：</p>
<ul>
<li>当两棵树的当前节点都为 null 时返回 true</li>
<li>当其中一个为 null 另一个不为 null 时返回 false</li>
<li>当两个都不为空但是值不相等时，返回 false</li>
</ul>
<p>执行过程：当满足终止条件时进行返回，不满足时分别判断左子树和右子树是否相同，其中要注意代码中的短路效应。</p>
<p>下面是一个图解：</p>
<img src="/archives/101cdf53/100-1.png" class="" title="相同的树-1">

<img src="/archives/101cdf53/100-2.png" class="" title="相同的树-2">

<img src="/archives/101cdf53/100-3.png" class="" title="相同的树-3">


<p>方法2：迭代</p>
<p>首先用一个栈来保存根节点p，q。接着不断遍历这个栈。</p>
<ol>
<li><p>我们从栈中拿出两个元素进行比较，如果这两个元素不等(一个是空一个不为空，或者两个节点的值不等)，就直接返回false。</p>
</li>
<li><p>如果这两个节点的值相等，就继续把p节点的左孩子,q节点的左孩子放入栈中；再把p节点的右孩子，q节点的右孩子放入栈中。</p>
</li>
</ol>
<p>重复这个步骤，直到栈为空。</p>
<p>如果整个循环遍历完了，说明两个树的元素都是相等的，返回true。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/same-tree/solution/hua-jie-suan-fa-100-xiang-tong-de-shu-by-guanpengc/" target="_blank" rel="noopener external nofollow noreferrer">画解算法：100. 相同的树</a></p>
</blockquote>
<h4 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">None</span> <span class="keyword">and</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">None</span> <span class="keyword">or</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br></pre></td></tr></table></figure>

<p>方法2：迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append((p,q))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            p,q = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> p == <span class="literal">None</span> <span class="keyword">and</span> q == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> p == <span class="literal">None</span> <span class="keyword">or</span> q == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> p.val != q.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> p.val == q.val:</span><br><span class="line">                stack.append((p.left,q.left))</span><br><span class="line">                stack.append((p.right,q.right))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101-对称二叉树"></a>101-对称二叉树</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p>说明：如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p>
<p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>
<p>如果同时满足下面的条件，两个树互为镜像：</p>
<ul>
<li>它们的两个根结点具有相同的值。</li>
<li>每个树的右子树都与另一个树的左子树镜像对称。</li>
</ul>
<img src="/archives/101cdf53/101-1.png" class="" title="对称二叉树-1">

<h4 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.isMirror(root.left,root.right)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMirror</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="literal">None</span> <span class="keyword">and</span> t2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="literal">None</span> <span class="keyword">or</span> t2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> t1 != <span class="literal">None</span> <span class="keyword">and</span> t2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> t1.val == t2.val:</span><br><span class="line">                <span class="keyword">return</span> self.isMirror(t1.left,t2.right) <span class="keyword">and</span> self.isMirror(t1.right,t2.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110-平衡二叉树"></a>110-平衡二叉树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure>

<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>方法1：自顶向下暴力递归</p>
<p>构造一个获取当前节点最大深度的方法 <code>depth()</code> ，通过比较左右子树最大高度差<code>abs(self.depth(root.left) - self.depth(root.right))</code>，来判断以此节点为根节点下是否是二叉平衡树；</p>
<ul>
<li>从顶至底DFS，以每个节点为根节点，递归判断是否是平衡二叉树：<ul>
<li>若所有根节点都满足平衡二叉树性质，则返回 True ；</li>
<li>若其中任何一个节点作为根节点时，不满足平衡二叉树性质，则返回False。</li>
</ul>
</li>
</ul>
<p>本方法产生大量重复的节点访问和计算，最差情况下时间复杂度 <code>O(N^2)</code>。</p>
<p>方法2：自底向上（提前阻断）</p>
<p>对二叉树做深度优先遍历DFS，递归过程中：</p>
<ul>
<li>终止条件：当DFS越过叶子节点时，返回高度0；</li>
<li>返回值：<ul>
<li>从底至顶，返回以每个节点root为根节点的子树最大高度（左右子树中最大的高度值加1，即<code>max(left,right) + 1)</code>）</li>
<li>当我们发现有一例 左/右子树高度差 ＞ 1 的情况时，代表此树不是平衡树，返回-1</li>
<li><strong>当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算</strong>。</li>
</ul>
</li>
</ul>
<p>最差情况是对树做一遍完整DFS，时间复杂度为 O(N)。</p>
<h4 id="Python实现-2"><a href="#Python实现-2" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点满足平衡树，继续递归判断子树是否满足平衡树条件</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.depth(root.left)-self.depth(root.right)) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算树高度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span> <span class="keyword">or</span> root.right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(self.depth(root.left),self.depth(root.right))</span><br></pre></td></tr></table></figure>

<p>方法2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> self.depth(root) == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        depth_left = self.depth(root.left)</span><br><span class="line">        <span class="comment"># 提前阻断</span></span><br><span class="line">        <span class="keyword">if</span> depth_left == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        depth_right = self.depth(root.right)</span><br><span class="line">        <span class="comment"># 提前阻断</span></span><br><span class="line">        <span class="keyword">if</span> depth_right == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> abs(depth_left-depth_right) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(depth_left,depth_right)</span><br><span class="line">        <span class="comment"># 提前阻断</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104-二叉树的最大深度"></a>104-二叉树的最大深度</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<p>示例：给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>方法1：迭代</p>
<p>层次遍历二叉树，如果树为空，直接返回0。否则将树和深度值1入队列，逐一弹出队列中节点：</p>
<ul>
<li>若某节点左右子树均为空，此节点即为叶子节点，我们将它的深度和最大深度<code>max_depth</code>进行比较，更新最大深度。</li>
<li>若其存在子树，则将其存在的子树和子树深度入队列。</li>
</ul>
<p>方法2：递归</p>
<p>递归结束条件：</p>
<ul>
<li>当 root 节点左右孩子都为空（叶子节点）时，返回 1</li>
<li>当 root 节点左右孩子至少有一个不为空时，返回左右孩子较大深度的节点值</li>
</ul>
<h4 id="Python实现-3"><a href="#Python实现-3" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        queue = [(root,<span class="number">1</span>)]</span><br><span class="line">        max_depth = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node,depth = queue.pop(<span class="number">0</span>)</span><br><span class="line">            max_depth = max(max_depth,depth)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                queue.append((node.left,depth+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                queue.append((node.right,depth+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_depth</span><br></pre></td></tr></table></figure>

<p>方法2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 叶子节点，返回1</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左右孩子至少有一个不为空时，返回左右孩子较大深度的节点值</span></span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span> <span class="keyword">or</span> root.right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(self.maxDepth(root.left),self.maxDepth(root.right))</span><br></pre></td></tr></table></figure>


<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111-二叉树的最小深度"></a>111-二叉树的最小深度</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：给定二叉树<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最小深度2.</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>方法1：迭代</p>
<p>层次遍历二叉树，如果树为空，直接返回0。否则将树和深度值1入队列，逐一弹出队列中节点：</p>
<ul>
<li>若某节点左右子树均为空，此节点即为叶子节点，我们将它的深度和最小深度<code>min_depth</code>进行比较，更新最小深度。</li>
<li>若其存在子树，则将其存在的子树和子树深度入队列。</li>
</ul>
<p>实际上，因为层次遍历是一层一层遍历的，所以<strong>第一个叶子节点即为最小深度的叶子节点</strong>，直接返回其深度即可。这样就不用遍历所有的节点。</p>
<p>方法2：递归</p>
<p>递归解法的关键是搞清楚递归结束条件：</p>
<ul>
<li>当 root 节点左右孩子都为空（叶子节点）时，返回 1</li>
<li>当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度</li>
<li>当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值</li>
</ul>
<h4 id="Python实现-4"><a href="#Python实现-4" class="headerlink" title="Python实现"></a>Python实现</h4><p>方法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      </span><br><span class="line">        queue = [(root,<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node,depth = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                queue.append((node.left,depth+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                queue.append((node.right,depth+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>方法2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 叶子节点，返回1</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左右孩子有一个为空时，返回不为空的孩子节点的深度</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">or</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(self.minDepth(root.left),self.minDepth(root.right))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左右孩子都不为空时，返回左右孩子较小深度的节点值</span></span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span> <span class="keyword">and</span> root.right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+min(self.minDepth(root.left),self.minDepth(root.right))</span><br></pre></td></tr></table></figure>

<h3 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662-二叉树最大宽度"></a>662-二叉树最大宽度</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与<strong>满二叉树</strong>（full binary tree）结构相同，但一些节点为空。</p>
<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">           1</span><br><span class="line">         &#x2F;   \</span><br><span class="line">        3     2</span><br><span class="line">       &#x2F; \     \  </span><br><span class="line">      5   3     9 </span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         &#x2F;  </span><br><span class="line">        3    </span><br><span class="line">       &#x2F; \       </span><br><span class="line">      5   3     </span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line">解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         &#x2F; \</span><br><span class="line">        3   2 </span><br><span class="line">       &#x2F;        </span><br><span class="line">      5      </span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line">解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。</span><br></pre></td></tr></table></figure>

<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         &#x2F; \</span><br><span class="line">        3   2</span><br><span class="line">       &#x2F;     \  </span><br><span class="line">      5       9 </span><br><span class="line">     &#x2F;         \</span><br><span class="line">    6           7</span><br><span class="line">输出: 8</span><br><span class="line">解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。</span><br></pre></td></tr></table></figure>

<p>注意: 答案在32位有符号整数的表示范围内。</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>因为两端点间的None值也计入，所以这里我们不能简单的统计每一层的节点数，这里我们可以考虑给<strong>树中的每一个节点进行编号</strong>，根节点为1，然后如果是左节点，值为根节点的二倍；如果是右节点，值为根节点的二倍加一。</p>
<p>这里我用层次遍历，采用一个队列记录每一个节点的节点以及号码，一层的首末元素的编号差就是该层的最大宽度。</p>
<h4 id="Python实现-5"><a href="#Python实现-5" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">widthOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        queue = [(root,<span class="number">1</span>)]</span><br><span class="line">        width = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            length = len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">                node,nums = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 记录该层第一个节点的编号、最后一个节点的编号</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    first_num = nums</span><br><span class="line">                <span class="keyword">if</span> i == length<span class="number">-1</span>:</span><br><span class="line">                    last_num = nums</span><br><span class="line">                    <span class="comment"># 更新最大宽度</span></span><br><span class="line">                    width = max(width,last_num-first_num+<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 左右子树入队</span></span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append((node.left,<span class="number">2</span>*nums))</span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append((node.right,<span class="number">2</span>*nums+<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> width</span><br></pre></td></tr></table></figure>


<h2 id="二叉树的遍历相关题目"><a href="#二叉树的遍历相关题目" class="headerlink" title="二叉树的遍历相关题目"></a>二叉树的遍历相关题目</h2><p>遍历的含义就是把树的所有节点（Node）按照某种顺序访问一遍。包括前序，中序，后序，层序4种遍历方法。</p>
<ol>
<li>以图的深度优先搜索为原型的遍历</li>
</ol>
<ul>
<li><a href="#144-二叉树的前序遍历">144-二叉树的前序遍历</a></li>
<li><a href="#94-二叉树的中序遍历">94-二叉树的中序遍历</a></li>
<li><a href="#145-二叉树的后序遍历">145-二叉树的后序遍历</a></li>
</ul>
<p>在这种类型中，递归的实现方式是非常简单的，只需要递归左右结点，直到结点为空作为结束条件就可以，哪种序就取决于你访问结点的时间。</p>
<p>不过一般这不能满足面试官的要求，可能会接着问能不能用非递归实现一下，这个说起来比较简单，其实就是用一个栈手动模拟递归的过程。</p>
<p>有时候非递归还是不能满足面试官，还会问一问，上面的做法时间和空间复杂度是多少。我们知道，正常遍历时间复杂度是<code>O(n)</code>，而空间复杂度是则是递归栈（或者自己维护的栈）的大小，也就是<code>O(logn)</code>。他会问能不能够在常量空间内解决树的遍历问题呢？确实还真可以，这里就要介绍一下Morris遍历。</p>
<blockquote>
<p>Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。这样就节省了需要用栈来记录前驱或者后继结点的额外空间，所以可以达到<code>O(1)</code>的空间复杂度。不过这种方法有一个问题就是会暂时性的改动树的结构，这在程序设计中并不是很好的习惯，这些在面试中都可以和面试官讨论，一般来说问到这里不会需要进行Morris遍历方法的代码实现了，只需要知道这种方法和他的主要优劣势就可以了。</p>
</blockquote>
<ol start="2">
<li>以图的广度优先搜索为原型的遍历，在树中称为层序遍历，LeetCode中有三种：自顶向下层序、自底向上层序、锯齿层序遍历。</li>
</ol>
<ul>
<li><a href="#102-二叉树的层次遍历">102-二叉树的层次遍历</a></li>
<li><a href="#103-二叉树的锯齿形层次遍历">103-二叉树的锯齿形层次遍历</a></li>
<li><a href="#107-二叉树的层次遍历ii">107-二叉树的层次遍历ii</a></li>
</ul>
<p><strong>自顶向下层序遍历</strong>其实比较简单，代码基本就是图的广度优先搜索，思路就是维护一个<strong>队列</strong>存储上一层的结点，逐层访问。而<strong>自底向上层序层序遍历</strong>则要从最后一层倒序访问上来，这个我没有想到太好的方法，现在的实现就是把自顶向下层序遍历得到的层放入数据结构然后reverse过来。至于<strong>锯齿层序遍历</strong>因为每一层访问顺序有所改变，而且是每次都反转顺序，这让我们想到<strong>栈</strong>这个数据结构，所以这里不用队列而改用栈来保存，就可以满足每层反转访问顺序的要求了。</p>
<p>层次遍历相关的题目：</p>
<ul>
<li><a href="#116-填充每个节点的下一个右侧节点指针">116-填充每个节点的下一个右侧节点指针</a></li>
<li><a href="#117-填充每个节点的下一个右侧节点指针ii">117-填充每个节点的下一个右侧节点指针ii</a></li>
<li>513-找树左下角的值</li>
<li>515-在每个树行中找最大值</li>
</ul>
<h3 id="详细题解"><a href="#详细题解" class="headerlink" title="详细题解"></a>详细题解</h3><ul>
<li><a href="https://tding.top/archives/5f8aadd1.html">LeetCode 题目总结 - 二叉搜索树</a></li>
</ul>
<h2 id="路径和相关题目"><a href="#路径和相关题目" class="headerlink" title="路径和相关题目"></a>路径和相关题目</h2><p>树的求和属于树的题目中比较常见的，因为可以有几种变体，灵活度比较高，也可以考察到对于树的数据结构和递归的理解。</p>
<ul>
<li><a href="#112-路径总和">112-路径总和</a></li>
<li><a href="#113-路径总和ii">113-路径总和ii</a></li>
<li>124-二叉树中的最大路径和</li>
<li><a href="#129-求根到叶子节点数字之和">129-求根到叶子节点数字之和</a></li>
<li><a href="#257-二叉树的所有路径">257-二叉树的所有路径</a></li>
</ul>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112-路径总和"></a>112-路径总和</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>

<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>这道题是判断是否存在从根到叶子的路径和跟给定sum相同。树的题目基本都是用递归来解决，主要考虑两个问题：</p>
<ol>
<li>如何把问题分治成子问题给左子树和右子树。这里就是看看左子树和右子树有没有存在和等于sum减去当前结点值的路径，只要有一个存在，那么当前结点就存在路径。</li>
<li>考虑结束条件是什么：<ul>
<li>结束条件1：如果当前节点是空的，则返回false。</li>
<li>结束条件2：如果是叶子，那么如果剩余的sum等于当前叶子的值，则找到满足条件的路径，返回true。</li>
</ul>
</li>
</ol>
<p>想清楚上面两个问题，那么实现起来就是一次树的遍历，按照刚才的分析用参数或者返回值传递需要维护的值，然后按照<strong>递归条件</strong>和<strong>结束条件</strong>进行返回即可。算法的时间复杂度是一次遍历<code>O(n)</code>，空间复杂度是栈的大小<code>O(logn)</code>。</p>
<h4 id="Python实现——递归"><a href="#Python实现——递归" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点是叶子，检查 root.val 值是否为 sum</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span> <span class="keyword">and</span> root.val == sum:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum() 函数</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left,sum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,sum-root.val)</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：我们访问每个节点一次，时间复杂度为 <code>O(N)</code> ，其中 N 是节点个数。</li>
<li>空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 <code>O(N)</code>。但在最好情况下，树是完全平衡的，高度只有 <code>log(N)</code>，因此在这种情况下空间复杂度只有 <code>O(log(N))</code> 。</li>
</ul>
<h4 id="Python实现——迭代"><a href="#Python实现——迭代" class="headerlink" title="Python实现——迭代"></a>Python实现——迭代</h4><p>我们可以用栈将递归转成迭代的形式。</p>
<p>栈中保存<strong>当前节点前的剩余值</strong>就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        stack = [(root,sum)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node,sum = stack.pop()</span><br><span class="line">            <span class="comment"># 判断叶子节点是否满足了条件</span></span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span> <span class="keyword">and</span> node.val == sum:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 左节点不为空，我们把左节点和剩余值打包压栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                stack.append((node.left,sum-node.val))</span><br><span class="line">            <span class="comment"># 右节点不为空，我们把右节点和剩余值打包压栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                stack.append((node.right,sum-node.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h3 id="113-路径总和ii"><a href="#113-路径总和ii" class="headerlink" title="113-路径总和ii"></a>113-路径总和ii</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>这道题思路和<strong>112-路径总和</strong>是完全一样的，只是需要输出所有路径，所以需要数据结构来维护路径，添加两个参数，一个用来维护走到当前结点的路径，一个用来保存满足条件的所有路径，思路上递归条件和结束条件是完全一致的，空间上这里会依赖于结果的数量了。</p>
<h4 id="Python实现——递归-1"><a href="#Python实现——递归-1" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 辅助函数（因为需要一个变量记录路径）       </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, sum, temp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 路径和满足sum，路径添加到结果数组res</span></span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span> <span class="keyword">and</span> root.val == sum:</span><br><span class="line">                temp += [root.val]</span><br><span class="line">                res.append(temp)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归搜索左右子树，传入剩余和以及路径</span></span><br><span class="line">            helper(root.left,sum-root.val,temp+[root.val])</span><br><span class="line">            helper(root.right,sum-root.val,temp+[root.val])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root,sum,[])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="Python实现——迭代-1"><a href="#Python实现——迭代-1" class="headerlink" title="Python实现——迭代"></a>Python实现——迭代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        temp = []</span><br><span class="line">        stack = [(root,sum,temp)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node,sum,temp = stack.pop()</span><br><span class="line">            <span class="comment"># 判断叶子节点是否满足了条件</span></span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span> <span class="keyword">and</span> node.val == sum:</span><br><span class="line">                temp += [node.val]</span><br><span class="line">                res.append(temp)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                stack.append((node.left,sum-node.val,temp + [node.val]))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                stack.append((node.right,sum-node.val,temp + [node.val]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h3 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129-求根到叶子节点数字之和"></a>129-求根到叶子节点数字之和</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 123。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13.</span><br><span class="line">因此，数字总和 &#x3D; 12 + 13 &#x3D; 25.</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">输出: 1026</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40.</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure>

<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>这道题目相比<strong>112-路径总和</strong>，增加了两个变化：</p>
<ol>
<li>每一个结点相当于位上的值。我们只需要每一层乘以10加上自己的值就可以了。</li>
<li>所有路径需要累加起来。我们只需要在最后对结果列表进行求和即可。</li>
</ol>
<h4 id="Python实现——递归-2"><a href="#Python实现——递归-2" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, nums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新路径和</span></span><br><span class="line">            nums *= <span class="number">10</span></span><br><span class="line">            nums += root.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果已经是叶子节点，保存路径和到列表中</span></span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">                res.append(nums)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                helper(root.left,nums)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                helper(root.right,nums)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        helper(root,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(res)</span><br></pre></td></tr></table></figure>

<h4 id="Python实现——迭代-2"><a href="#Python实现——迭代-2" class="headerlink" title="Python实现——迭代"></a>Python实现——迭代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        stack = [(root,<span class="number">0</span>)]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node,nums = stack.pop()</span><br><span class="line">            <span class="comment"># 更新路径和</span></span><br><span class="line">            nums *= <span class="number">10</span></span><br><span class="line">            nums += node.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果已经是叶子节点，保存路径和到列表中</span></span><br><span class="line">            <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">                res.append(nums)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                stack.append((node.left,nums))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                stack.append((node.right,nums))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(res)</span><br></pre></td></tr></table></figure>


<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257-二叉树的所有路径"></a>257-二叉树的所有路径</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>

<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是一个叶子节点，则将它对应的路径加入到答案中。如果它不是一个叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时，迭代结束。</p>
<h4 id="Python实现-6"><a href="#Python实现-6" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        queue = [(root,<span class="string">''</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            temp = <span class="string">''</span></span><br><span class="line">            length = len(queue)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                node,temp = queue.pop(<span class="number">0</span>)</span><br><span class="line">                temp += str(node.val)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果是叶子节点，记录路径</span></span><br><span class="line">                <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:    </span><br><span class="line">                    res.append(temp)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 格式要求</span></span><br><span class="line">                temp += <span class="string">'-&gt;'</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                    queue.append((node.left,temp))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    queue.append((node.right,temp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="二叉树的构建相关题目"><a href="#二叉树的构建相关题目" class="headerlink" title="二叉树的构建相关题目"></a>二叉树的构建相关题目</h2><p>这类题目本质还是用递归的手法来实现，但是这类题目有一个特点，就是它是构建一棵树，而不是给定一棵树，然后进行遍历，所以实现起来思路上有点逆向。</p>
<ul>
<li><a href="#105-从前序与中序遍历序列构造二叉树">105-从前序与中序遍历序列构造二叉树</a></li>
<li><a href="#106-从中序与后序遍历序列构造二叉树">106-从中序与后序遍历序列构造二叉树</a></li>
<li><a href="#108-将有序数组转换为二叉搜索树">108-将有序数组转换为二叉搜索树</a></li>
<li><a href="#109-有序链表转换二叉搜索树">109-有序链表转换二叉搜索树</a></li>
</ul>
<p>思路就是在递归中创建根节点，然后找到将元素劈成左右子树的方法，递归得到左右根节点，接上创建的根然后返回。方法还是比较具有模板型的。</p>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105-从前序与中序遍历序列构造二叉树"></a>105-从前序与中序遍历序列构造二叉树</h3><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<ul>
<li>前序遍历 <code>preorder = [3,9,20,15,7]</code></li>
<li>中序遍历 <code>inorder = [9,3,15,20,7]</code></li>
</ul>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>前序遍历数组的第1个数（索引为0）的数一定是二叉树的根结点，于是可以在中序遍历中找这个根结点的索引，然后把“前序遍历数组”和“中序遍历数组”分为两个部分，就分别对应二叉树的左子树和右子树，分别递归完成就可以了。</p>
<img src="/archives/101cdf53/105-1.png" class="" title="从前序与中序遍历序列构造二叉树-1">

<p>下面是一个具体的例子，演示了如何计算数组子区间的边界：</p>
<img src="/archives/101cdf53/105-2.png" class="" title="从前序与中序遍历序列构造二叉树-2">

<blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/" target="_blank" rel="noopener external nofollow noreferrer">分治法（Python 代码、Java 代码）</a></li>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/shi-yong-map-by-powcai/" target="_blank" rel="noopener external nofollow noreferrer">使用 map</a></li>
</ul>
</blockquote>
<h4 id="Python实现——递归-3"><a href="#Python实现——递归-3" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        mid = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归构造左子树、右子树</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:mid+<span class="number">1</span>],inorder[<span class="number">0</span>:mid])</span><br><span class="line">        root.right = self.buildTree(preorder[mid+<span class="number">1</span>:],inorder[mid+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N^2)，这里 N 是二叉树的结点个数，每调用一次递归方法创建一个结点，一共创建 N 个结点，在中序遍历中找到根结点在中序遍历中的位置，是与 N 相关的，这里不计算递归方法占用的时间。</li>
<li>空间复杂度：O(1)，这里不计算递归方法占用的空间。</li>
</ul>
<h4 id="Python实现——哈希表优化"><a href="#Python实现——哈希表优化" class="headerlink" title="Python实现——哈希表优化"></a>Python实现——哈希表优化</h4><p>我们可以用哈希表（字典）来存储中序遍历，这样就可以在<code>O(1)</code>时间复杂度下找到根结点在中序遍历数组中的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 哈希表存储中序遍历的值、索引</span></span><br><span class="line">        dicts = &#123;var:i <span class="keyword">for</span> i,var <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">        index = dicts[preorder[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归构造左子树、右子树</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:index+<span class="number">1</span>],inorder[:index])</span><br><span class="line">        root.right = self.buildTree(preorder[index+<span class="number">1</span>:],inorder[index+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>上面的代码在递归函数里面建立哈希表，这会导致<strong>哈希表一共建立二叉树节点个数次（即N次）</strong>，没有达到我们的优化目的，我们希望的是哈希表仅仅建立一次，后续递归中每次都能有直接调用。下面是优化后的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 辅助函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(pre_left,pre_right,in_left,in_right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> pre_left == pre_right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建当前“根”</span></span><br><span class="line">            root = TreeNode(preorder[pre_left])</span><br><span class="line">            <span class="comment"># 从哈希表中找到当前“根”的索引</span></span><br><span class="line">            index = dicts[preorder[pre_left]]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新前序遍历、中序遍历边界，然后递归构建左右子树</span></span><br><span class="line">            <span class="comment"># 我们可以通过“前序和中序个数是相同”这个隐含条件，求出前序左右边界</span></span><br><span class="line">            root.left = helper(pre_left+<span class="number">1</span>,pre_left+<span class="number">1</span>+index-in_left,in_left,index)</span><br><span class="line">            <span class="comment"># 根据上面用过的，写出剩下的</span></span><br><span class="line">            root.right = helper(pre_left+<span class="number">1</span>+index-in_left,pre_right,index+<span class="number">1</span>,in_right)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 哈希表存储中序遍历的值、索引</span></span><br><span class="line">        dicts = &#123;var:i <span class="keyword">for</span> i,var <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用辅助函数</span></span><br><span class="line">        root = helper(<span class="number">0</span>,len(preorder),<span class="number">0</span>,len(inorder))</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106-从中序与后序遍历序列构造二叉树"></a>106-从中序与后序遍历序列构造二叉树</h3><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意：你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>这道题目类似<strong>105题</strong>。</p>
<p>下面是一个图解：</p>
<img src="/archives/101cdf53/106-1.png" class="" title="从中序与后序遍历序列构造二叉树-1">

<blockquote>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-bian-li-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener external nofollow noreferrer">分治法（Python、Java）</a></p>
</blockquote>
<h4 id="Python实现——递归-4"><a href="#Python实现——递归-4" class="headerlink" title="Python实现——递归"></a>Python实现——递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(postorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 后序遍历的最后一个结点就是根结点</span></span><br><span class="line">        root = TreeNode(postorder[<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 在中序遍历中找到根结点的索引，得到左右子树的一个划分</span></span><br><span class="line">        mid = inorder.index(postorder[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里的列表切片使用的是复制值，使用了一些空间，因此空间复杂度是 O(N)</span></span><br><span class="line">        root.left = self.buildTree(inorder[:mid],postorder[:mid])</span><br><span class="line">        root.right = self.buildTree(inorder[mid+<span class="number">1</span>:],postorder[mid:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="Python实现——哈希表优化-1"><a href="#Python实现——哈希表优化-1" class="headerlink" title="Python实现——哈希表优化"></a>Python实现——哈希表优化</h4><p>同样的，我们可以把中序遍历的值和索引放在一个哈希表中，这样就不需要通过遍历得到当前根结点在中序遍历中的位置了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 辅助函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(in_left,in_right,post_left,post_right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> in_left == in_right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建当前“根”</span></span><br><span class="line">            root = TreeNode(postorder[post_right<span class="number">-1</span>])</span><br><span class="line">            <span class="comment"># 从哈希表中找到当前“根”的索引</span></span><br><span class="line">            index = dicts[postorder[post_right<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新中序遍历、后序遍历边界，然后递归构建左右子树</span></span><br><span class="line">            <span class="comment"># 我们可以通过“中序和后序个数是相同”这个隐含条件，求出后序左右边界</span></span><br><span class="line">            root.left = helper(in_left,index,post_left,post_right<span class="number">-1</span>-(in_right-index<span class="number">-1</span>))</span><br><span class="line">            root.right = helper(index+<span class="number">1</span>,in_right,post_right<span class="number">-1</span>-(in_right-index<span class="number">-1</span>),post_right<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 哈希表存储中序遍历的值、索引</span></span><br><span class="line">        dicts = &#123;var:i <span class="keyword">for</span> i,var <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用辅助函数</span></span><br><span class="line">        root = helper(<span class="number">0</span>,len(inorder),<span class="number">0</span>,len(postorder))</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>


<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108-将有序数组转换为二叉搜索树"></a>108-将有序数组转换为二叉搜索树</h3><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个按照升序排列的有序数组，转换为一棵<strong>高度平衡二叉搜索树</strong>。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<p>给定有序数组: <code>[-10,-3,0,5,9]</code>，一个可能的答案是：<code>[0,-3,9,-10,null,5]</code>，它可以表示下面这个高度平衡二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    &#x2F; \</span><br><span class="line">  -3   9</span><br><span class="line">  &#x2F;   &#x2F;</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure>

<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>二叉搜索树的中序遍历刚好可以输出一个升序数组，所以题目给出的升序数组就是二叉搜索树的中序遍历。</p>
<p>根据中序遍历还原一颗树，又想到了 105 题 和 106 题，通过中序遍历加前序遍历或者中序遍历加后序遍历来还原一棵树。前序（后序）遍历的作用呢？提供根节点！然后根据根节点，就可以递归的生成左右子树。</p>
<p>这里的话怎么知道根节点呢？平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。</p>
<h4 id="Python实现-7"><a href="#Python实现-7" class="headerlink" title="Python实现"></a>Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.binarySearch(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        <span class="comment"># 递归构建左右子树</span></span><br><span class="line">        root.left = self.binarySearch(nums, left, mid<span class="number">-1</span>)</span><br><span class="line">        root.right = self.binarySearch(nums, mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109-有序链表转换二叉搜索树"></a>109-有序链表转换二叉搜索树</h3><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个<strong>单链表</strong>，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<p>给定的有序链表：<code>[-10, -3, 0, 5, 9]</code>，一个可能的答案是：<code>[0, -3, 9, -10, null, 5]</code>, 它可以表示下面这个高度平衡二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    &#x2F; \</span><br><span class="line">  -3   9</span><br><span class="line">  &#x2F;   &#x2F;</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure>

<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>这道题目跟108题是类似的，数组可以很方便的找到中点，但链表的特性导致我们无法像数组那样通过下标访问各个元素。若想按照108题的做法，就需要设置两个指针slow、fast，slow每走一步fast走两步，这样fast结束时slow就在中点。<strong>但这样会导致每次递归都需要重复遍历链表，效率较低</strong>。</p>
<p>注意：当找到链表中的中间元素后，我们将<strong>链表从中间元素的左侧断开</strong>，做法是slow指针初始指向dummy，最后<code>slow.next</code>才是中点，然后我们在中点的左侧断开，也就是<code>slow.next = None</code>。</p>
<h4 id="Python实现——二分"><a href="#Python实现——二分" class="headerlink" title="Python实现——二分"></a>Python实现——二分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链表寻找中点</span></span><br><span class="line">        <span class="comment"># 为了保证保留左子树的右边界，这里设置slow=dummy而不是head</span></span><br><span class="line">        dummy = ListNode(<span class="literal">None</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line"></span><br><span class="line">        slow = dummy</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast.next != <span class="literal">None</span> <span class="keyword">and</span> fast.next.next != <span class="literal">None</span>:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 由于slow初始值为dummy，因此slow.next才为中点</span></span><br><span class="line">        root = TreeNode(slow.next.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链表从中间断开（左子树的右边界是中点的左边一个节点，右子树的左边界是中点的右边一个节点）</span></span><br><span class="line">        mid = slow.next.next</span><br><span class="line">        slow.next = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归构建左右子树</span></span><br><span class="line">        <span class="comment"># 判断左子树是否为空</span></span><br><span class="line">        <span class="keyword">if</span> slow == dummy:</span><br><span class="line">            root.left = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.left = self.sortedListToBST(dummy.next)</span><br><span class="line">        root.right = self.sortedListToBST(mid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="Python实现——链表转换数组-二分"><a href="#Python实现——链表转换数组-二分" class="headerlink" title="Python实现——链表转换数组+二分"></a>Python实现——链表转换数组+二分</h4><p>在这个方法中，我们将给定的链表转成数组并利用数组来构建二叉搜索树。数组找中间元素只需要 O(1) 的时间，所以会降低整个算法的时间复杂度开销。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 链表转换成数组</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.binarySearch(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 辅助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归构建左右子树</span></span><br><span class="line">        root.left = self.binarySearch(nums,left,mid<span class="number">-1</span>)</span><br><span class="line">        root.right = self.binarySearch(nums,mid+<span class="number">1</span>,right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>


<h2 id="二叉搜索树相关题目"><a href="#二叉搜索树相关题目" class="headerlink" title="二叉搜索树相关题目"></a>二叉搜索树相关题目</h2><p>二叉查找树既是一颗树，又带有特别的有序性质，所以考察的方式比较多而且灵活，属于面试题目中的常客。</p>
<p>此部分详细题解见：</p>
<ul>
<li><a href="https://tding.top/archives/5f8aadd1.html">LeetCode 题目总结 - 二叉搜索树</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.im/post/5d9f0b9551882509165ff2a8" target="_blank" rel="noopener external nofollow noreferrer">LeetCode 前1000题二叉树题目系统总结（吐血推荐！）</a></li>
<li><a href="https://www.jianshu.com/p/77ad56b9f128" target="_blank" rel="noopener external nofollow noreferrer">LeetCode二叉树(Tree)小结</a></li>
<li><a href="http://www.jintiankansha.me/t/4EJM5iEhVB" target="_blank" rel="noopener external nofollow noreferrer">LeetCode 总结 - 搞定 Binary Tree 面试题</a></li>
<li><a href="http://interviewsource.blogspot.com/2016/09/blog-post.html" target="_blank" rel="noopener external nofollow noreferrer">LeetCode总结 – 树</a></li>
</ul>

    </div>

    
    
    
      
  <div class="popular-posts-header">推荐文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\91220368.html" rel="bookmark">LeetCode题解汇总</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\e1014f63.html" rel="bookmark">LeetCode题目总结-二叉树的遍历</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\5f8aadd1.html" rel="bookmark">LeetCode题目总结-二叉搜索树</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\551df4d4.html" rel="bookmark">LeetCode题目总结-链表</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\647f3958.html" rel="bookmark">LeetCode题目总结-数组中的双指针问题</a></div>
    </li>
  </ul>
<div>
    
        <div class="end-slogan" style="text-align:center;font-size:22px;letter-spacing:10px;user-select:none;color:#bbb;"><br/>----------- 本文结束啦<i class="fa fa-star"></i>感谢您阅读 -----------<br/><br/></div>
    
</div> 
        <div class="reward-container">
  <div>赞赏一杯咖啡</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    <i class="fa fa-qrcode fa-2x" style="line-height:35px;"></i>
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="小丁 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="小丁 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>小丁
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://tding.top/archives/101cdf53.html" title="LeetCode题目总结-二叉树">https://tding.top/archives/101cdf53.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i> LeetCode</a>
              <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag"><i class="fa fa-tag"></i> 二叉树</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/b1453574.html" rel="prev" title="Google搜索技巧">
      <i class="fa fa-chevron-left"></i> Google搜索技巧
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/eb2dec05.html" rel="next" title="VSCode中配置R语言运行环境">
      VSCode中配置R语言运行环境 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
      <div class="comment-button-group">
          <a class="btn comment-button disqus">disqus</a>
          <a class="btn comment-button valine">valine</a>
      </div>
        <div class="comment-position disqus">
          
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  
        </div>
        <div class="comment-position valine">
          <div class="comments" id="valine-comments"></div>
        </div>
      <script>
        (function() {
          let commentButton = document.querySelectorAll('.comment-button');
            commentButton.forEach(element => {
            let commentClass = element.classList[2];
            element.addEventListener('click', () => {
              commentButton.forEach(rmActive => rmActive.classList.remove('active'));
              element.classList.add('active');
              document.querySelectorAll('.comment-position').forEach(rmActive => rmActive.classList.remove('active'));
              document.querySelector(`.comment-position.${commentClass}`).classList.add('active');
              if (CONFIG.comments.storage) {
                localStorage.setItem('comments_active', commentClass);
              }
            });
          });
          let activeClass = CONFIG.comments.activeClass;
          if (CONFIG.comments.storage) {
            activeClass = localStorage.getItem('comments_active') || activeClass;
          }
          if (activeClass) {
            let activeButton = document.querySelector(`.comment-button.${activeClass}`);
            if (activeButton) {
              activeButton.click();
            }
          }
        })();
      </script>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的存储结构"><span class="nav-number">1.</span> <span class="nav-text">二叉树的存储结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的性质相关题目"><span class="nav-number">2.</span> <span class="nav-text">二叉树的性质相关题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#100-相同的树"><span class="nav-number">2.1.</span> <span class="nav-text">100-相同的树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述"><span class="nav-number">2.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路"><span class="nav-number">2.1.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现"><span class="nav-number">2.1.3.</span> <span class="nav-text">Python实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-对称二叉树"><span class="nav-number">2.2.</span> <span class="nav-text">101-对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">Python实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-平衡二叉树"><span class="nav-number">2.3.</span> <span class="nav-text">110-平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现-2"><span class="nav-number">2.3.3.</span> <span class="nav-text">Python实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-二叉树的最大深度"><span class="nav-number">2.4.</span> <span class="nav-text">104-二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-3"><span class="nav-number">2.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现-3"><span class="nav-number">2.4.3.</span> <span class="nav-text">Python实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-二叉树的最小深度"><span class="nav-number">2.5.</span> <span class="nav-text">111-二叉树的最小深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-4"><span class="nav-number">2.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-4"><span class="nav-number">2.5.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现-4"><span class="nav-number">2.5.3.</span> <span class="nav-text">Python实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#662-二叉树最大宽度"><span class="nav-number">2.6.</span> <span class="nav-text">662-二叉树最大宽度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-5"><span class="nav-number">2.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-5"><span class="nav-number">2.6.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现-5"><span class="nav-number">2.6.3.</span> <span class="nav-text">Python实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的遍历相关题目"><span class="nav-number">3.</span> <span class="nav-text">二叉树的遍历相关题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#详细题解"><span class="nav-number">3.1.</span> <span class="nav-text">详细题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径和相关题目"><span class="nav-number">4.</span> <span class="nav-text">路径和相关题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#112-路径总和"><span class="nav-number">4.1.</span> <span class="nav-text">112-路径总和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-6"><span class="nav-number">4.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-6"><span class="nav-number">4.1.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——递归"><span class="nav-number">4.1.3.</span> <span class="nav-text">Python实现——递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——迭代"><span class="nav-number">4.1.4.</span> <span class="nav-text">Python实现——迭代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-路径总和ii"><span class="nav-number">4.2.</span> <span class="nav-text">113-路径总和ii</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-7"><span class="nav-number">4.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-7"><span class="nav-number">4.2.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——递归-1"><span class="nav-number">4.2.3.</span> <span class="nav-text">Python实现——递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——迭代-1"><span class="nav-number">4.2.4.</span> <span class="nav-text">Python实现——迭代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#129-求根到叶子节点数字之和"><span class="nav-number">4.3.</span> <span class="nav-text">129-求根到叶子节点数字之和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-8"><span class="nav-number">4.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-8"><span class="nav-number">4.3.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——递归-2"><span class="nav-number">4.3.3.</span> <span class="nav-text">Python实现——递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——迭代-2"><span class="nav-number">4.3.4.</span> <span class="nav-text">Python实现——迭代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#257-二叉树的所有路径"><span class="nav-number">4.4.</span> <span class="nav-text">257-二叉树的所有路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-9"><span class="nav-number">4.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-9"><span class="nav-number">4.4.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现-6"><span class="nav-number">4.4.3.</span> <span class="nav-text">Python实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的构建相关题目"><span class="nav-number">5.</span> <span class="nav-text">二叉树的构建相关题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="nav-number">5.1.</span> <span class="nav-text">105-从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-10"><span class="nav-number">5.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-10"><span class="nav-number">5.1.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——递归-3"><span class="nav-number">5.1.3.</span> <span class="nav-text">Python实现——递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——哈希表优化"><span class="nav-number">5.1.4.</span> <span class="nav-text">Python实现——哈希表优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-从中序与后序遍历序列构造二叉树"><span class="nav-number">5.2.</span> <span class="nav-text">106-从中序与后序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-11"><span class="nav-number">5.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-11"><span class="nav-number">5.2.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——递归-4"><span class="nav-number">5.2.3.</span> <span class="nav-text">Python实现——递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——哈希表优化-1"><span class="nav-number">5.2.4.</span> <span class="nav-text">Python实现——哈希表优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-将有序数组转换为二叉搜索树"><span class="nav-number">5.3.</span> <span class="nav-text">108-将有序数组转换为二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-12"><span class="nav-number">5.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-12"><span class="nav-number">5.3.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现-7"><span class="nav-number">5.3.3.</span> <span class="nav-text">Python实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#109-有序链表转换二叉搜索树"><span class="nav-number">5.4.</span> <span class="nav-text">109-有序链表转换二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-13"><span class="nav-number">5.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-13"><span class="nav-number">5.4.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——二分"><span class="nav-number">5.4.3.</span> <span class="nav-text">Python实现——二分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python实现——链表转换数组-二分"><span class="nav-number">5.4.4.</span> <span class="nav-text">Python实现——链表转换数组+二分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉搜索树相关题目"><span class="nav-number">6.</span> <span class="nav-text">二叉搜索树相关题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小丁"
      src="/images/avatar.webp">
  <p class="site-author-name" itemprop="name">小丁</p>
  <div class="site-description" itemprop="description">酒，越喝越暖，水会越喝越寒</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dta0502" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dta0502" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:dta0502@126.com" title="E-Mail → mailto:dta0502@126.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



    <div class="links-of-blogroll motion-element links-of-blogroll-block">
      <div class="links-of-blogroll-title">
        <!-- modify icon to fire by szw -->
        <i class="fa fa-history fa-" aria-hidden="true"></i>
        近期文章
      </div>
      <ul class="links-of-blogroll-list">
        
        
          <li>
            <a href="/archives/bc52c916.html" title="Performance API详解" target="_blank">Performance API详解</a>
          </li>
        
          <li>
            <a href="/archives/a896eef1.html" title="Lighthouse介绍" target="_blank">Lighthouse介绍</a>
          </li>
        
          <li>
            <a href="/archives/9c7d6d63.html" title="Nginx反向代理配置总结" target="_blank">Nginx反向代理配置总结</a>
          </li>
        
          <li>
            <a href="/archives/9d6997a4.html" title="ElasticSearch基本操作" target="_blank">ElasticSearch基本操作</a>
          </li>
        
          <li>
            <a href="/archives/d5e02e8f.html" title="Vue nextTick的原理及用法" target="_blank">Vue nextTick的原理及用法</a>
          </li>
        
      </ul>
    </div>



<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小丁</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">928k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">14:04</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> v7.7.2
  </div><div class="translate-style">
繁/简：<a id="translateLink" href="javascript:translatePage();" rel="external nofollow noreferrer">繁体
</a>
</div>
<script type="text/javascript" src="/js/tw_cn.js"></script>
<script type="text/javascript">
var defaultEncoding = 2;
var translateDelay = 0;
var cookieDomain = "https://tding.top/";
var msgToTraditionalChinese = "繁体";
var msgToSimplifiedChinese = "简体";
var translateButtonId = "translateLink";
translateInitilization();
</script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 19729,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri == 'https://tding.top/archives/101cdf53.html',]
      });
      });
  </script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
      <div class="moon-menu-item" onclick="back2bottom()">
        <i class="fa fa-chevron-down"></i>
      </div>
    
      <div class="moon-menu-item" onclick="back2top()">
        <i class="fa fa-chevron-up"></i>
      </div>
    
  </div>
  <div class="moon-menu-button" onclick="moonMenuClick()">
    <svg class="moon-menu-svg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
      <g class="moon-menu-points">
        <circle class="moon-menu-point" r=".2rem" cx="0" cy="-.8rem"></circle>
        <circle class="moon-menu-point" r=".2rem"></circle>
        <circle class="moon-menu-point" r=".2rem" cx="0" cy=".8rem"></circle>
      </g>
    </svg>
    <div class="moon-menu-icon">
    </div>
    <div class="moon-menu-text">
    </div>
  </div>
</div>

<script>

const moonMenuListener = function () {

  //Get scroll percent
  let offsetHeight =document.documentElement.offsetHeight;
  let scrollHeight =document.documentElement.scrollHeight;
  var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;
  let percent = Math.round(scrollTop/(scrollHeight - offsetHeight)*100);
  if (percent > 100) percent = 100;
  
  let menuText = document.querySelector('.moon-menu-text');
  let menuPoints = document.querySelector('.moon-menu-points');
  if (!percent){
    percent = 0;
    menuText.style.display = 'none';
    menuPoints.style.display = 'block';
  } else {
    menuText.style.display = 'block';
    menuPoints.style.display = 'none';
    menuText.innerHTML = percent + '%';
  }
  
  //Update strokeDasharray
  let length = 196;
  document.querySelector('.moon-menu-border').style.strokeDasharray = percent*length/100 + ' ' + length;

}

window.addEventListener('load' , () => {
  moonMenuListener();
});
window.addEventListener('scroll' , moonMenuListener);

const moonMenuClick = function () {
  let items = document.querySelector('.moon-menu-items')
  items.classList.toggle('active');
  let points = document.querySelectorAll('.moon-menu-point');
  let childItems = document.querySelectorAll('.moon-menu-item');
  if (items.classList.contains('active')) {
    points[0].setAttribute("cx","-.8rem");
    points[0].setAttribute("cy","0");
    points[2].setAttribute("cx",".8rem");
    points[2].setAttribute("cy","0");
    for (let i=0; i<childItems.length; i++) {
      childItems[i].style.top = -3 - 3*i + 'rem';
      childItems[i].style.opacity = .9;
    }
  } else {
    points[0].setAttribute("cx","0");
    points[0].setAttribute("cy","-.8rem");
    points[2].setAttribute("cx","0");
    points[2].setAttribute("cy",".8rem");
    for (let i=0; i<childItems.length; i++) {
      childItems[i].style.top = '1rem';
      childItems[i].style.opacity = 0;
    }
  }
};

const back2top = () => {
  window.scroll({top: 0, behavior: 'smooth'});
}

const back2bottom = () => {
  let offsetHeight =document.documentElement.offsetHeight;
  let scrollHeight =document.documentElement.scrollHeight;
  window.scroll({top: (scrollHeight - offsetHeight), behavior: 'smooth'});
}

</script>

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://tding01.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://tding.top/archives/101cdf53.html";
    this.page.identifier = "archives/101cdf53.html";
    this.page.title = "LeetCode题目总结-二叉树";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://tding01.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Y3lMe8B29LX1pTTL22OWDXBr-MdYXbMMI',
      appKey     : 'IODE6dTrgVtFS4Q40LAS2ush',
      placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <script async src="/js/cursor/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>










<script type="text/javascript" src="/js/fold_action.js"></script>

</body>
</html>
